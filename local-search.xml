<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>链表例题-02</title>
    <link href="/2022/02/03/%E9%93%BE%E8%A1%A8%E4%BE%8B%E9%A2%98-02/"/>
    <url>/2022/02/03/%E9%93%BE%E8%A1%A8%E4%BE%8B%E9%A2%98-02/</url>
    
    <content type="html"><![CDATA[<p>这一份有两题，都是有规律的</p><h1 id="剑指-Offer-II-022-链表中环的入口节点"><a href="#剑指-Offer-II-022-链表中环的入口节点" class="headerlink" title="剑指 Offer II 022. 链表中环的入口节点"></a><a href="https://leetcode-cn.com/problems/c32eOV/">剑指 Offer II 022. 链表中环的入口节点</a></h1><p><img src="/2022/02/03/%E9%93%BE%E8%A1%A8%E4%BE%8B%E9%A2%98-02/image-20220203111659223.png"></p><p><img src="/2022/02/03/%E9%93%BE%E8%A1%A8%E4%BE%8B%E9%A2%98-02/image-20220203111716174.png" alt="题目简介"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>实际上最简单的思路就是哈希表，就是走一个存一个，存到相同就返回，太没有技术含量了，不讲这个。</p><p>我们使用两个指针，fat 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。</p><p>如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b 的距离与 fast 相遇。此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 a+n(b+c)+b=a+(n+1)b+nca+n(b+c)+b=a+(n+1)b+nc。</p><p>根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 2 倍。因此，我们有</p><p><em>a</em>+(<em>n</em>+1)<em>b</em>+<em>nc</em>=2(<em>a</em>+<em>b</em>)⟹<em>a</em>=<em>c</em>+(<em>n</em>−1)(<em>b</em>+<em>c</em>)</p><p>有了 a=c+(n-1)(b+c)a=c+(n−1)(b+c) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n-1n−1 圈的环长，恰好等于从链表头部到入环点的距离。</p><p>因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        ListNode slow = head, fast = head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span>) &#123;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span> (fast.next != <span class="hljs-keyword">null</span>) &#123;<br>                fast = fast.next.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (fast == slow) &#123;<br>                ListNode ptr = head;<br>                <span class="hljs-keyword">while</span> (ptr != slow) &#123;<br>                    ptr = ptr.next;<br>                    slow = slow.next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> ptr;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="/2022/02/03/%E9%93%BE%E8%A1%A8%E4%BE%8B%E9%A2%98-02/image-20220203121329716.png" alt="结果"></p><h1 id="剑指-Offer-II-023-两个链表的第一个重合节点"><a href="#剑指-Offer-II-023-两个链表的第一个重合节点" class="headerlink" title="剑指 Offer II 023. 两个链表的第一个重合节点"></a><a href="https://leetcode-cn.com/problems/3u1WK4/">剑指 Offer II 023. 两个链表的第一个重合节点</a></h1><p><img src="/2022/02/03/%E9%93%BE%E8%A1%A8%E4%BE%8B%E9%A2%98-02/image-20220203122035750.png"></p><p><img src="/2022/02/03/%E9%93%BE%E8%A1%A8%E4%BE%8B%E9%A2%98-02/image-20220203122055887.png"></p><p><img src="/2022/02/03/%E9%93%BE%E8%A1%A8%E4%BE%8B%E9%A2%98-02/image-20220203122114388.png" alt="题目简介"></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>有点小办法</p><p>定义两个指针 node1、node2 分别指向 headA 和 headB 的头节点，当两者不等时，同时移动 node1、node2 遍历两个链表，当有一个为空时，让其指向另外一个链表的头，不断移动，最终相遇，相遇节点即为相交节点。</p><p>为什么自己仔细想想就能明白。二者走的路程一样的。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (headA == <span class="hljs-keyword">null</span> || headB == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        ListNode pA = headA, pB = headB;<br>        <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>            pA = pA == <span class="hljs-keyword">null</span> ? headB : pA.next;<br>            pB = pB == <span class="hljs-keyword">null</span> ? headA : pB.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><p><img src="/2022/02/03/%E9%93%BE%E8%A1%A8%E4%BE%8B%E9%A2%98-02/image-20220203122425049.png" alt="结果"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>双指针</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot自动装配原理</title>
    <link href="/2022/02/03/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"/>
    <url>/2022/02/03/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot-自动装配原理"><a href="#Spring-Boot-自动装配原理" class="headerlink" title="Spring Boot 自动装配原理"></a>Spring Boot 自动装配原理</h1><p>可以从几个方面回答：</p><ol><li>什么是 Spring Boot 自动装配？</li><li>Spring Boot 是如何实现自动装配的？如何实现按需加载？</li><li>如何实现一个 Starter？</li></ol><p>来源 <a href="https://javaguide.cn/system-design/framework/spring/spring-boot-auto-assembly-principles/#enableautoconfiguration-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B3%A8%E8%A7%A3">Java Guide</a></p><p>使用过 Spring 的小伙伴，一定有被 XML 配置统治的恐惧。即使 Spring 后面引入了基于注解的配置，我们在开启某些 Spring 特性或者引入第三方依赖的时候，还是需要用 XML 或 Java 进行显式配置。</p><p>在Spring Boot后只要通过注解和<code>application.properties</code> 或者 <code>application.yml</code> 即可对项目进行设置。</p><h2 id="什么是-Spring-Boot-自动装配？"><a href="#什么是-Spring-Boot-自动装配？" class="headerlink" title="什么是 Spring Boot 自动装配？"></a>什么是 Spring Boot 自动装配？</h2><p>我们现在提到自动装配的时候，一般会和 Spring Boot 联系在一起。但是，实际上 Spring Framework 早就实现了这个功能。Spring Boot 只是在其基础上，通过 SPI 的方式，做了进一步优化。</p><blockquote><p>SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的<code>META-INF/spring.factories</code>文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。</p></blockquote><p>没有 Spring Boot 的情况下，如果我们需要引入第三方依赖，需要手动配置，非常麻烦。但是，Spring Boot 中，我们直接引入一个 starter 即可。比如你想要在项目中使用 redis 的话，直接在项目中引入对应的 starter 即可。 </p><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>引入 starter 之后，我们通过少量注解和一些简单的配置就能使用第三方组件提供的功能了。</p><p>在我看来，自动装配可以简单理解为：<strong>通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</strong></p><h2 id="Spring-Boot-是如何实现自动装配的？"><a href="#Spring-Boot-是如何实现自动装配的？" class="headerlink" title="Spring Boot 是如何实现自动装配的？"></a>Spring Boot 是如何实现自动装配的？</h2><p>SpringBoot 的核心注解 <code>SpringBootApplication</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br>&lt;<span class="hljs-number">1.</span>&gt;<span class="hljs-meta">@SpringBootConfiguration</span><br>&lt;<span class="hljs-number">2.</span>&gt;<span class="hljs-meta">@ComponentScan</span><br>&lt;<span class="hljs-number">3.</span>&gt;<span class="hljs-meta">@EnableAutoConfiguration</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;<br><br>&#125;<br><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Configuration</span> <span class="hljs-comment">//实际上它也是一个配置类</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootConfiguration &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>大概可以把 <code>@SpringBootApplication</code> 看作是 <code>@Configuration</code> 、<code>@EnableAutoConfiguration</code>、 <code>@ComponentScan</code> 注解的集合。</p><p>根据 SpringBoot 官网，这三个注解的作用分别是：</p><ul><li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li><li><code>@Configuration</code>：允许在上下文中注册额外的 bean 或导入其他配置类。</li><li><code>@ComponentScan</code>：扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。如下图所示，容器中将排除<code>TypeExcludeFilter</code>和<code>AutoConfigurationExcludeFilter</code>。</li></ul><p><img src="/2022/02/03/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/bcc73490afbe4c6ba62acde6a94ffdfd~tplv-k3u1fbpfcp-watermark.image.png"></p><p><code>@EnableAutoConfiguration</code> 是实现自动装配的重要注解，我们以这个注解入手。</p><h3 id="EnableAutoConfiguration-实现自动装配的核心注解"><a href="#EnableAutoConfiguration-实现自动装配的核心注解" class="headerlink" title="@EnableAutoConfiguration:实现自动装配的核心注解"></a>@EnableAutoConfiguration:实现自动装配的核心注解</h3><p><code>EnableAutoConfiguration</code> 只是一个简单地注解，自动装配核心功能的实现实际是通过 <code>AutoConfigurationImportSelector</code>类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span> <span class="hljs-comment">//作用：将main包下的所欲组件注册到容器中</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class="hljs-comment">//加载自动装配类 xxxAutoconfiguration</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br>    String ENABLED_OVERRIDE_PROPERTY = <span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>;<br><br>    Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    String[] excludeName() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们现在重点分析下<code>AutoConfigurationImportSelector</code> 类到底做了什么？</p><h3 id="AutoConfigurationImportSelector：加载自动装配类"><a href="#AutoConfigurationImportSelector：加载自动装配类" class="headerlink" title="AutoConfigurationImportSelector：加载自动装配类"></a>AutoConfigurationImportSelector：加载自动装配类</h3><p><code>AutoConfigurationImportSelector</code>类的继承体系如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoConfigurationImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DeferredImportSelector</span>, <span class="hljs-title">BeanClassLoaderAware</span>, <span class="hljs-title">ResourceLoaderAware</span>, <span class="hljs-title">BeanFactoryAware</span>, <span class="hljs-title">EnvironmentAware</span>, <span class="hljs-title">Ordered</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DeferredImportSelector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ImportSelector</span> </span>&#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ImportSelector</span> </span>&#123;<br>    String[] selectImports(AnnotationMetadata var1);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，<code>AutoConfigurationImportSelector</code> 类只要实现了 <code>ImportSelector</code> 接口，也就是实现了这个接口中的 <code>selectImports</code> 方法，该方法主要用于获取符合条件的类的全限定名，这些类需要被加载到 <strong>IOC 容器中</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] NO_IMPORTS = <span class="hljs-keyword">new</span> String[<span class="hljs-number">0</span>];<br><br><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br>        <span class="hljs-comment">// &lt;1&gt;.判断自动装配开关是否打开</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isEnabled(annotationMetadata)) &#123;<br>            <span class="hljs-keyword">return</span> NO_IMPORTS;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">//&lt;2&gt;.获取所有需要装配的bean</span><br>            AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="hljs-keyword">this</span>.beanClassLoader);<br>            AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = <span class="hljs-keyword">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);<br>            <span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里我们需要重点关注一下<code>getAutoConfigurationEntry()</code>方法，这个方法主要负责加载自动配置类的。</p><p>该方法调用链如下：</p><p><img src="/2022/02/03/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/3c1200712655443ca4b38500d615bb70~tplv-k3u1fbpfcp-watermark-3904643.image" alt="调用链"></p><p>现在我们结合<code>getAutoConfigurationEntry()</code>的源码来详细分析一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AutoConfigurationEntry EMPTY_ENTRY = <span class="hljs-keyword">new</span> AutoConfigurationEntry();<br><br><span class="hljs-function">AutoConfigurationEntry <span class="hljs-title">getAutoConfigurationEntry</span><span class="hljs-params">(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata)</span> </span>&#123;<br>        <span class="hljs-comment">//&lt;1&gt;.</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isEnabled(annotationMetadata)) &#123;<br>            <span class="hljs-keyword">return</span> EMPTY_ENTRY;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//&lt;2&gt;.</span><br>            AnnotationAttributes attributes = <span class="hljs-keyword">this</span>.getAttributes(annotationMetadata);<br>            <span class="hljs-comment">//&lt;3&gt;.</span><br>            List&lt;String&gt; configurations = <span class="hljs-keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);<br>            <span class="hljs-comment">//&lt;4&gt;.</span><br>            configurations = <span class="hljs-keyword">this</span>.removeDuplicates(configurations);<br>            Set&lt;String&gt; exclusions = <span class="hljs-keyword">this</span>.getExclusions(annotationMetadata, attributes);<br>            <span class="hljs-keyword">this</span>.checkExcludedClasses(configurations, exclusions);<br>            configurations.removeAll(exclusions);<br>            configurations = <span class="hljs-keyword">this</span>.filter(configurations, autoConfigurationMetadata);<br>            <span class="hljs-keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>第 1 步：</p><p>判断自动装配开关是否打开。默认<code>spring.boot.enableautoconfiguration=true</code>，可在 <code>application.properties</code> 或 <code>application.yml</code> 中设置。</p><p><img src="/2022/02/03/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/77aa6a3727ea4392870f5cccd09844ab~tplv-k3u1fbpfcp-watermark-3904791.image"></p><p><strong>第 2 步</strong> ：</p><p>用于获取<code>EnableAutoConfiguration</code>注解中的 <code>exclude</code> 和 <code>excludeName</code>。</p><p><img src="/2022/02/03/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/3d6ec93bbda1453aa08c52b49516c05a~tplv-k3u1fbpfcp-zoom-1-3904862.image"></p><p><strong>第 3 步</strong></p><p>获取需要自动装配的所有配置类，读取<code>META-INF/spring.factories</code></p><p><img src="/2022/02/03/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/58c51920efea4757aa1ec29c6d5f9e36~tplv-k3u1fbpfcp-watermark-3904910.image"></p><p>从下图可以看到这个文件的配置内容都被我们读取到了。<code>XXXAutoConfiguration</code>的作用就是按需加载组件。</p><p><img src="/2022/02/03/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/94d6e1a060ac41db97043e1758789026~tplv-k3u1fbpfcp-watermark-3904938.image"></p><p>不光是这个依赖下的<code>META-INF/spring.factories</code>被读取到，所有 Spring Boot Starter 下的<code>META-INF/spring.factories</code>都会被读取到。</p><p>所以，你可以清楚滴看到， druid 数据库连接池的 Spring Boot Starter 就创建了<code>META-INF/spring.factories</code>文件。</p><p>如果，我们自己要创建一个 Spring Boot Starter，这一步是必不可少的。</p><p><img src="/2022/02/03/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/68fa66aeee474b0385f94d23bcfe1745~tplv-k3u1fbpfcp-watermark.image"></p><p><strong>第 4 步</strong> ：</p><p>到这里可能面试官会问你:“<code>spring.factories</code>中这么多配置，每次启动都要全部加载么？”。</p><p>很明显，这是不现实的。我们 debug 到后面你会发现，<code>configurations</code> 的值变小了。</p><p><img src="/2022/02/03/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/267f8231ae2e48d982154140af6437b0~tplv-k3u1fbpfcp-watermark.image"></p><p>因为，这一步有经历了一遍筛选，<code>@ConditionalOnXXX</code> 中的所有条件都满足，该类才会生效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-comment">// 检查相关的类：RabbitTemplate 和 Channel是否存在</span><br><span class="hljs-comment">// 存在才会加载</span><br><span class="hljs-meta">@ConditionalOnClass(&#123; RabbitTemplate.class, Channel.class &#125;)</span><br><span class="hljs-meta">@EnableConfigurationProperties(RabbitProperties.class)</span><br><span class="hljs-meta">@Import(RabbitAnnotationDrivenConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitAutoConfiguration</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>有兴趣的童鞋可以详细了解下 Spring Boot 提供的条件注解</p><ul><li><code>@ConditionalOnBean</code>：当容器里有指定 Bean 的条件下</li><li><code>@ConditionalOnMissingBean</code>：当容器里没有指定 Bean 的情况下</li><li><code>@ConditionalOnSingleCandidate</code>：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean</li><li><code>@ConditionalOnClass</code>：当类路径下有指定类的条件下</li><li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定类的条件下</li><li><code>@ConditionalOnProperty</code>：指定的属性是否有指定的值</li><li><code>@ConditionalOnResource</code>：类路径是否有指定的值</li><li><code>@ConditionalOnExpression</code>：基于 SpEL 表达式作为判断条件</li><li><code>@ConditionalOnJava</code>：基于 Java 版本作为判断条件</li><li><code>@ConditionalOnJndi</code>：在 JNDI 存在的条件下差在指定的位置</li><li><code>@ConditionalOnNotWebApplication</code>：当前项目不是 Web 项目的条件下</li><li><code>@ConditionalOnWebApplication</code>：当前项目是 Web 项 目的条件下</li></ul><h2 id="如何实现一个-Starter"><a href="#如何实现一个-Starter" class="headerlink" title="如何实现一个 Starter"></a>如何实现一个 Starter</h2><p>第一步，创建<code>threadpool-spring-boot-starter</code>工程</p><p><img src="/2022/02/03/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/1ff0ebe7844f40289eb60213af72c5a6~tplv-k3u1fbpfcp-watermark.image"></p><p>第二步，引入 Spring Boot 相关依赖</p><p><img src="/2022/02/03/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/5e14254276604f87b261e5a80a354cc0~tplv-k3u1fbpfcp-watermark.image"></p><p>第三步，创建<code>ThreadPoolAutoConfiguration</code></p><p><img src="/2022/02/03/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/1843f1d12c5649fba85fd7b4e4a59e39~tplv-k3u1fbpfcp-watermark.image"></p><p>第四步，在<code>threadpool-spring-boot-starter</code>工程的 resources 包下创建<code>META-INF/spring.factories</code>文件</p><p><img src="/2022/02/03/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/97b738321f1542ea8140484d6aaf0728~tplv-k3u1fbpfcp-watermark.image"></p><p>最后新建工程引入<code>threadpool-spring-boot-starter</code></p><p><img src="/2022/02/03/springboot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/edcdd8595a024aba85b6bb20d0e3fed4~tplv-k3u1fbpfcp-watermark.image"></p>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
      <category>自动装配原理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程-01</title>
    <link href="/2022/02/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-01/"/>
    <url>/2022/02/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-01/</url>
    
    <content type="html"><![CDATA[<h2 id="何为进程？"><a href="#何为进程？" class="headerlink" title="何为进程？"></a>何为进程？</h2><p>进程是一个程序一次执行的过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，启动 main 函数其实就是启动了一个 JVM 进程，而 main 函数所在的线程就是这个进程中的一个线程，也称为主线程。</p><h2 id="何为线程？"><a href="#何为线程？" class="headerlink" title="何为线程？"></a>何为线程？</h2><p>线程是比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。</p><p>与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但是每个线程有自己的<strong>程序计数器、虚拟机栈和本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小的多，也正因为如此，线程也被称为轻量级进程。</p><p><strong>Java 程序的运行就是 main 线程和多个其他线程同时运行</strong>。</p><h2 id="进程和线程的关系，区别及优缺点？"><a href="#进程和线程的关系，区别及优缺点？" class="headerlink" title="进程和线程的关系，区别及优缺点？"></a>进程和线程的关系，区别及优缺点？</h2><p><img src="/2022/02/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-01/image-20220203153309198-3873591.png" alt="内存区域"></p><p>在 JDK 1.8 之前，方法区没有变成元空间，多个线程共享堆和方法去，每个线程有自己的程序计数器，虚拟机栈和本地方法栈。</p><p>总结来说：</p><p>线程是进程划分的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而个线程不一定，因为同意进程中的线程可能会互相影响。线程的执行开销小，但不利于资源的管理与保护，而进程正相反。</p><h2 id="程序计数器为什么是私有的？"><a href="#程序计数器为什么是私有的？" class="headerlink" title="程序计数器为什么是私有的？"></a>程序计数器为什么是私有的？</h2><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>需要注意的是，如果执行的是 native 方法，那么程序计数器地址记录的是 undefined 地址，只有执行的是 Java 代码时，程序计数器记录的才是吓一跳指令地址。</p><p>所以，程序计数器私有主要是为了<strong>线程切换后能够恢复到正确的执行位置</strong>。</p><h2 id="虚拟机栈和本地方法栈为什么是私有的？"><a href="#虚拟机栈和本地方法栈为什么是私有的？" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的？"></a>虚拟机栈和本地方法栈为什么是私有的？</h2><ul><li><strong>虚拟机栈</strong>：每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈</strong>：和虚拟机栈锁发挥的作用非常相似，区别是：<strong>虚拟机栈作为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务</strong>。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以为了<strong>保证线程中局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><h2 id="介绍堆和方法区"><a href="#介绍堆和方法区" class="headerlink" title="介绍堆和方法区"></a>介绍堆和方法区</h2><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h2 id="并发和并行的区别？"><a href="#并发和并行的区别？" class="headerlink" title="并发和并行的区别？"></a>并发和并行的区别？</h2><ul><li><strong>并发</strong>：同一时间段，多个任务都在执行（单位时间内不一定同时执行）。</li><li><strong>并行</strong>：单位时间内，多个任务同时执行。</li></ul><h2 id="为什么要使用多线程？"><a href="#为什么要使用多线程？" class="headerlink" title="为什么要使用多线程？"></a>为什么要使用多线程？</h2><p>总体上来说：</p><ul><li><strong>从计算机等层来说</strong>：线程可以比做是轻量级的进程，是程序执行的最小单位，线程之间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li><li><strong>从当代互联网发展趋势来看</strong>：现在的系统动不动就要求百万千万级别的并发，多线程并发编程正式开发高并发系统的基础，利用好多线程机制能大大提高系统对的性能。</li></ul><h2 id="使用多线程会带来什么问题？"><a href="#使用多线程会带来什么问题？" class="headerlink" title="使用多线程会带来什么问题？"></a>使用多线程会带来什么问题？</h2><p>并发编程的⽬的就是为了能提⾼程序的执⾏效率提⾼程序运⾏速度，但是并发编程并不总是能提⾼程序运⾏速度的，⽽且并发编程可能会遇到很多问题，⽐如：内存泄漏、上下⽂切换、死锁 。</p><h2 id="线程的生命周期与状态？"><a href="#线程的生命周期与状态？" class="headerlink" title="线程的生命周期与状态？"></a>线程的生命周期与状态？</h2><p><img src="/2022/02/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-01/image-20220203155218273.png" alt="线程的生命周期"></p><p><img src="/2022/02/03/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-01/image-20220203155245142.png" alt="线程创建活动图"></p><p>线程创建之后将处于 <strong>NEW（新建状态）</strong>，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>Ready（就绪）</strong>状态。就绪状态的线程获得了 CPU 时间片之后，处于 <strong>RUNNING（运行）</strong>状态。</p><p>当线程执行 <code>wait()</code> 方法后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能返回到运行状态，而 <strong>TIME_WAITING（超时等待）</strong>状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep(long millis)</code> 或者 <code>wait(long millis)</code> 方法可以让 Java线程进入超市等待的状态。当超时等待到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法是，在没有获取到锁的情况下；线程会进入 <strong>BLOCKED（阻塞）</strong>状态。在线程执行 Runnable 的 <code>run()</code> 方法之后将会进入到 <strong>TERMINATED（终止）</strong>状态。</p><h2 id="什么是上下文切换？"><a href="#什么是上下文切换？" class="headerlink" title="什么是上下文切换？"></a>什么是上下文切换？</h2><p>多线程编程一种线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能狗有效的执行，CPU 采用的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让其他线程使用，这个过程就属于一次上下文切换。</p><p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会保存自己的状态，以便上次再切换回这个任务时，可以再加载这个任务。<strong>任务从保存到加载的过程就是一次上下文切换</strong>。</p><p>上下⽂切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒⼏⼗上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下⽂切换对系统来说意味着消耗⼤量的CPU 时间，事实上，可能是操作系统中时间消耗最⼤的操作。</p><p>Linux 相⽐与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有⼀项就是，其上下⽂切换和模式切换的时间消耗⾮常少。</p><h2 id="什么是线程死锁，如何避免？"><a href="#什么是线程死锁，如何避免？" class="headerlink" title="什么是线程死锁，如何避免？"></a>什么是线程死锁，如何避免？</h2><h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><p>线程死锁是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等某个资源被释放。由于线程被无限期的阻塞，因此程序不可能能正常终止。</p><p>死锁的必要条件：</p><ul><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>等待与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有完成之后才会释放资源。</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ul><h3 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h3><p>只要破坏上面四个必要条件的任意一个就行</p><ol><li><strong>破坏互斥条件</strong>：这个没办法破坏，因为我们用锁本来就是想让它们互斥的（临界资源需要互斥访问）。</li><li><strong>破坏请求与保持条件</strong>：一次性申请所有资源。</li><li><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li><li><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。</li></ol><h2 id="sleep-方法和-wait-方法的异同点？"><a href="#sleep-方法和-wait-方法的异同点？" class="headerlink" title="sleep() 方法和 wait() 方法的异同点？"></a>sleep() 方法和 wait() 方法的异同点？</h2><ul><li>两者的最主要区别在于：<code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁。</li><li>两者都可以暂停线程的执行。</li><li><code>wait()</code> 通常被用于线程间 交互/通信，<code>sleep()</code> 通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code> 或者 <code>notifyAll()</code> 方法。<code>sleep()</code> 方法在执行完成后，线程会自动苏醒。</li></ul>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
      <category>多线程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表例题-01</title>
    <link href="/2022/02/03/%E9%93%BE%E8%A1%A8%E4%BE%8B%E9%A2%98-01/"/>
    <url>/2022/02/03/%E9%93%BE%E8%A1%A8%E4%BE%8B%E9%A2%98-01/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-II-021-删除链表的倒数第-n-个结点"><a href="#剑指-Offer-II-021-删除链表的倒数第-n-个结点" class="headerlink" title="剑指 Offer II 021. 删除链表的倒数第 n 个结点"></a><a href="https://leetcode-cn.com/problems/SLwz0R/">剑指 Offer II 021. 删除链表的倒数第 n 个结点</a></h1><p><img src="/2022/02/03/%E9%93%BE%E8%A1%A8%E4%BE%8B%E9%A2%98-01/image-20220203110732323.png"></p><p><img src="/2022/02/03/%E9%93%BE%E8%A1%A8%E4%BE%8B%E9%A2%98-01/image-20220203110752768.png" alt="题目介绍"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先题目中的链表不是双向的，所以要找倒数第 n 的节点，需要一点技巧。</p><p>这里就可以用一个双指针，右边的指针先偷跑 n 个身位，然后和左指针一起跑，那么到终点的时候，就是左指针在倒数 n 位的时候。</p><p>但是我们要删除倒数第 n 个节点，所以得到倒数 n + 1 个节点，意思就是让倒数 n + 1 节点指向倒数 n - 1 节点。</p><p>这里有一个问题，就是如果倒数第 n 个节点就是头指针，这个时候就直接返回 head.next 就好</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        ListNode right = head, left = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            right = right.next;<br>        &#125;<br>        ListNode temp = left;<br>        <span class="hljs-keyword">while</span>(right != <span class="hljs-keyword">null</span>)&#123;<br>            temp = left;<br>            left = left.next;<br>            right = right.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left == head)&#123;<br>            head = head.next;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        temp.next = left.next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="/2022/02/03/%E9%93%BE%E8%A1%A8%E4%BE%8B%E9%A2%98-01/image-20220203111408348.png" alt="结果"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>双指针</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑窗法例题-2</title>
    <link href="/2022/02/02/%E6%BB%91%E7%AA%97%E6%B3%95%E4%BE%8B%E9%A2%98-2/"/>
    <url>/2022/02/02/%E6%BB%91%E7%AA%97%E6%B3%95%E4%BE%8B%E9%A2%98-2/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-II-017-含有所有字符的最短字符串"><a href="#剑指-Offer-II-017-含有所有字符的最短字符串" class="headerlink" title="剑指 Offer II 017. 含有所有字符的最短字符串"></a><a href="https://leetcode-cn.com/problems/M1oyTv/">剑指 Offer II 017. 含有所有字符的最短字符串</a></h1><span id="more"></span><p><img src="/2022/02/02/%E6%BB%91%E7%AA%97%E6%B3%95%E4%BE%8B%E9%A2%98-2/image-20220202103634336.png" alt="image-20220202103634336"></p><h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>不能怕困难题，万变不离其中</p><p>首先能想到符合条件的子字符串的判断方式，就是将两个字符串的字符统计进两个数组（hash表），然后比对各个字符的出现次数。</p><p>具体代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] sta1, <span class="hljs-keyword">int</span>[] sta2)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sta1.length; i++)&#123;<br>        <span class="hljs-keyword">if</span>(sta2[i] &lt; sta1[i]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>sta1 是子串的字符统计，sta2 是另一个字符串的统计。</p><p>然后就可以比较轻松的知道普通的滑动窗口解法，关键在于什么时候移动 left。</p><p>在滑窗的长度大于 t.length() 的情况下，失去最左侧的字符不会影响 judge 的正确性。</p><p>什么叫不影响正确性呢？每次都判断一次的成本太高了，就是失去这个 left 之后，<code>sta2[(int) s.charAt(left)]</code> 仍大于 <code>sta1[(int) s.charAt(left)]</code>。</p><p>总体步骤：</p><ol><li><p>若 s.length() &lt; t.length()，没有对应的结果字符串 ans，需要 特判，直接返回 0；</p></li><li><p>设置滑动窗口的左边界 left 和右边界 right，其中 right - left &gt;= t.length() 且 left &gt; 0，right &lt; s.length()；</p></li><li><p>在 每一次 循环的操作中，右边界 right 均要向右移动 1 位，并计入其指向的字符。再判断左边界是否需要向右移动，若左边界向右移动会导致 缺失需要的字符 或 滑动窗口大小小于字符串 t 的长度，则 不可右移。否则右移 1 位并 判断是否可以继续右移；</p></li><li><p>每一次循环的边界移动操作结束后，判断此时的 区间子字符串是否将 t 的字符全部包括在内，若全部包括且 ans 为 null 或 ans 的长度大于区间子字符串的长度，更新 ans。</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(t.length() &gt; s.length())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] sta1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [<span class="hljs-number">128</span>];<br>        <span class="hljs-keyword">int</span>[] sta2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [<span class="hljs-number">128</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t.length(); i ++)&#123;<br>            <span class="hljs-keyword">int</span> index = t.charAt(i);<br>            sta1[index] ++;<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = t.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; right; j ++)&#123;<br>            <span class="hljs-keyword">int</span> index = s.charAt(j);<br>            sta2[index] ++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(Arrays.equals(sta1, sta2)) &#123;<br>            <span class="hljs-keyword">return</span> s.subSequence(left, right).toString();<br>        &#125;<br>        String res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span>(right &lt; s.length())&#123;<br>            <span class="hljs-keyword">int</span> index = s.charAt(right);<br>            sta2[index]++;<br>            right ++;<br>            <span class="hljs-keyword">while</span>(left &lt; right - t.length())&#123;<br>                <span class="hljs-keyword">int</span> inx = s.charAt(left);<br>                <span class="hljs-keyword">if</span>(sta2[inx] &lt;= sta1[inx])&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    sta2[inx]--;<br>                    left ++;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(judge(sta1, sta2))&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;&quot;</span>.equals(res) || res.length() &gt; right - left)&#123;<br>                    res = s.subSequence(left, right).toString();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] sta1, <span class="hljs-keyword">int</span>[] sta2)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sta1.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(sta2[i] &lt; sta1[i]) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="/2022/02/02/%E6%BB%91%E7%AA%97%E6%B3%95%E4%BE%8B%E9%A2%98-2/image-20220202224644091.png" alt="结果"></p><p>实际上时间效率并不是很高，主要的时间复杂度就出在 judge 这个判断方法。</p><p>如果想优化时间复杂度，就可以往这个方向优化，方法不一，本篇就不说了。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>滑动窗口法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>滑窗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑窗法例题-1</title>
    <link href="/2022/02/02/%E6%BB%91%E7%AA%97%E6%B3%95%E4%BE%8B%E9%A2%98-1/"/>
    <url>/2022/02/02/%E6%BB%91%E7%AA%97%E6%B3%95%E4%BE%8B%E9%A2%98-1/</url>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-II-014-字符串中的变位词"><a href="#剑指-Offer-II-014-字符串中的变位词" class="headerlink" title="剑指 Offer II 014. 字符串中的变位词"></a><a href="https://leetcode-cn.com/problems/MPnaiL/">剑指 Offer II 014. 字符串中的变位词</a></h1><span id="more"></span><p><img src="/2022/02/02/%E6%BB%91%E7%AA%97%E6%B3%95%E4%BE%8B%E9%A2%98-1/image-20220202102138596.png" alt="题目介绍"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>变位词，就是在一定范围内，各个字母的个数与 s1 相同，换句话说，在 s2 中维护一个大小为 s1 的窗口，这个窗口内的各个字母的个数与 s1 相同。</p><ol><li>判断 s2 的长度是否大于 s1，如果小于肯定就是扯犊子啊，直接false不犹豫。</li><li>将 s1 各个字符的个数统计到长度为 26 的数组中，0 代表 ‘a’，1 代表 ‘b’ 。。。。</li><li>在 s2 中维护一个长度为 s1 长度的窗口，不停向右滑动，如果 Arrays.equal(s1的统计，s2窗口的统计)，就返回true。</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(String s1, String s2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s1.length() &gt; s2.length())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s1.length() == s2.length())&#123;<br>            <span class="hljs-keyword">if</span>(s1.equals(s2)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] sta1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c : s1.toCharArray())&#123;<br>            <span class="hljs-keyword">int</span> index = c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            sta1[index] ++;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] sta2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = s1.length();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; right ;j++)&#123;<br>            <span class="hljs-keyword">int</span> index = s2.charAt(j) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            sta2[index] ++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(Arrays.equals(sta1, sta2))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(right &lt; s2.length())&#123;<br>            sta2[s2.charAt(right++) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            sta2[s2.charAt(left++) - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            <span class="hljs-keyword">if</span>(Arrays.equals(sta1, sta2))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>纯纯的空间换时间~</p><p><img src="/2022/02/02/%E6%BB%91%E7%AA%97%E6%B3%95%E4%BE%8B%E9%A2%98-1/image-20220202103038083.png" alt="结果"></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>滑动窗口法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>滑窗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>锁及Java的实现</title>
    <link href="/2022/02/01/%E9%94%81%E5%8F%8AJava%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/02/01/%E9%94%81%E5%8F%8AJava%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="各种锁的概述及-Java-实现"><a href="#各种锁的概述及-Java-实现" class="headerlink" title="各种锁的概述及 Java 实现"></a>各种锁的概述及 Java 实现</h1><p>通俗易懂理解 悲观锁、乐观锁、可重入锁、自旋锁、偏向锁、轻量/重量级锁、读写锁等等等等锁。</p><span id="more"></span><p>首先有一个思想就是，一个锁不是只能属于一种分类的，一个锁可能同时是悲观锁，可充如梭，公平锁等等等，并不矛盾。</p><p>资料来源《Java 虚拟机》、<a href="https://zhuanlan.zhihu.com/p/71156910">知乎</a></p><h2 id="synchronized-与-Lock"><a href="#synchronized-与-Lock" class="headerlink" title="synchronized 与 Lock"></a>synchronized 与 Lock</h2><p>Java 中有两种加锁的方法，一种是<strong>synchronized关键字</strong>，另一种是<strong>Lock接口</strong>的实现类。</p><p>形象的说，synchronized 关键字是自动档，可以满足一切日常驾驶。但是如果想玩漂移，就需要手动挡 – Lock接口的实现类了。</p><p>如果只是想简单加个锁，对性能没有特殊的要求，使用 synchronized 关键字就足够了。自从 Java5 后，才在 java.util.concurrent.locks 包下又了另一种方式来实现锁，就是 Lock 接口。也就是说，synchronized 是 Java 语言的内置关键字，而 Lock 是一个接口，这个接口的实现类代码层面实现了锁的功能，具体细节不展开，可以看看源码 <code>AbstractQueueSynchronizer</code> 类，很牛逼～～。</p><p> <img src="/2022/02/01/%E9%94%81%E5%8F%8AJava%E7%9A%84%E5%AE%9E%E7%8E%B0/v2-ddb71ab0b68d65ae70244bfdeb0d6704_1440w-3682285.jpg" alt="关注ReentrantLock类、ReadLock类、WriteLock类。"></p><p><strong>ReentrantReadWriteLock、ReadLock、WriteLock</strong> 是 Lock 接口最重要的三个实现类。对应了 “可重入锁”、“读锁” 和 “写锁”，后面会讲它们的用途。</p><p>ReadWriteLock 其实是一个工厂接口，而 ReentrantReadWriteLock 是 ReadWriteLock 的实现类，它包含两个静态内部类 ReadLock 和 WriteLock。这两个静态内部类又分别实现了 Lock 接口。</p><h2 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h2><p>锁的一种宏观分类方式是<strong>悲观锁</strong>和<strong>乐观锁</strong>。悲观锁与乐观锁<strong>并不是特指某个锁</strong>，Java 中也没有哪个 Lock 实现类就叫这两个，而是在并发情况下的两种策略。</p><p>悲观锁（Pessimistic Lock），很悲观，认为每次拿数据的时候，别人都会修改，所以每次拿数据时候都会上锁，别人想拿数据就会被挡住，直到悲观锁释放。</p><p>乐观锁（Optimistic Lock），很乐观，每次拿数据的时候都认为别人不会修改，所以<strong>不上锁！</strong>。但是如果想要更新数据，则会在<strong>更新前检查在读取至更新这段时间别人有没有修改这个数据</strong>。如果有修改过，则重新读取，知道成功为止。（也允许更新失败的线程放弃操作）</p><p><strong>悲观锁阻塞事务，乐观锁回滚尝试</strong>，它们褒贬不一，也没有优劣之分。乐观锁比较适合写比较少的情况下，即冲突很少发生的情况，这样就可以省去锁的开销，加大了系统的整个的吞吐量。但如果经常产生冲突，上层应用会不断进行重试，这样反而降低了性能，所以这种情况选用悲观锁比较合适。</p><h2 id="乐观锁的基础-——-CAS"><a href="#乐观锁的基础-——-CAS" class="headerlink" title="乐观锁的基础 —— CAS"></a>乐观锁的基础 —— CAS</h2><p>什么是 CAS？Compare and Swap，即<strong>比较替换</strong>，也有叫做 Compare-and-Set 的，就是<strong>比较并设置</strong>。</p><ol><li>比较：读取到一个值 A，在将其更新为 B 之前，检查原值是否为 A（未被改动）。</li><li>设置：如果是，将 A 更新为 B，否则什么都不做。</li></ol><p>其中有一种情况是，A 可能更新为 C 之后又更新回了 A，但是 CAS 仍会认为它是没有被更新的，并发包下的 AtomicStampedReference 有提供版本号来判断的扩展，这样就能规避这种情况。</p><p>有了 CAS，就可以实现一个乐观锁。</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs java">data = <span class="hljs-number">123</span>; <span class="hljs-comment">// 共享数据</span><br><br><span class="hljs-comment">/* 更新数据的线程会进行如下操作 */</span><br>flag = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">while</span> (flag) &#123;<br>    oldValue = data; <span class="hljs-comment">// 保存原始数据</span><br>    newValue = doSomething(oldValue); <br><br>    <span class="hljs-comment">// 下面的部分为CAS操作，尝试更新data的值</span><br>    <span class="hljs-keyword">if</span> (data == oldValue) &#123; <span class="hljs-comment">// 比较</span><br>        data = newValue; <span class="hljs-comment">// 设置</span><br>        flag = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// 结束</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 啥也不干，循环重试</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">   很明显，这样的代码根本不是原子性的，</span><br><span class="hljs-comment">   因为真正的CAS利用了CPU指令，</span><br><span class="hljs-comment">   这里只是为了展示执行流程，本意是一样的。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这是一个简单直观的乐观锁实现，它允许多个线程同时读取（因为根本没有加锁操作），但是只有一个线程可以成功更新数据，并导致其他要更新数据的线程回滚重试。 CAS利用CPU指令，从硬件层面保证了操作的原子性，以达到类似于锁的效果。</p><p><img src="/2022/02/01/%E9%94%81%E5%8F%8AJava%E7%9A%84%E5%AE%9E%E7%8E%B0/v2-3c683e1f88faa31152fc35d14b8fb8de_1440w-3683912.jpg" alt="Java中真正的CAS操作调用的native方法"></p><p>整个过程没有加锁变成，所以乐观锁策略也被称为<strong>无锁编程</strong>。换句话说，乐观锁并不是锁，仅仅是一个循环重试的 CAS 算法。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>有一种锁叫<strong>自旋锁</strong>。就是一个 while(true) 的无限循环。</p><p>乐观锁也有类似的无限循环，它是自旋锁吗？</p><p>并不是，经过乐观锁也有类似的无限循环，但是 “自旋” 两个字，特指  “自旋锁” 的 “自旋”。</p><p>具体内容下面介绍</p><h2 id="synchronized-锁升级：偏向锁-gt-轻量级锁-gt-重量级锁"><a href="#synchronized-锁升级：偏向锁-gt-轻量级锁-gt-重量级锁" class="headerlink" title="synchronized 锁升级：偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁"></a>synchronized 锁升级：偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</h2><p>前面提到，synchronized关键字就像是汽车的<strong>自动档，</strong>现在详细讲这个过程。一脚油门踩下去，synchronized会从<strong>无锁</strong>升级为<strong>偏向锁</strong>，再升级为<strong>轻量级锁</strong>，最后升级为<strong>重量级锁</strong>，就像自动换挡一样。那么自旋锁在哪里呢？这里的轻量级锁就是一种<strong>自旋锁</strong>。</p><p>初次执行到synchronized代码块的时候，锁对象变成<strong>偏向锁</strong>（通过CAS修改对象头里的锁标志位），字面意思是“偏向于第一个获得它的线程”的锁。执行完同步代码块后，线程并<strong>不会主动释放偏向锁</strong>。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。<strong>由于之前没有释放锁，这里也就不需要重新加锁。</strong>如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</p><p>偏向锁的一个特性是，持有锁的线程在执行完同步代码块时不会释放锁。那么当第二个线程执行到这个synchronized代码块时是否一定会发生锁竞争然后升级为轻量级锁呢？</p><p>线程A第一次执行完同步代码块后，当线程B尝试获取锁的时候，发现是偏向锁，会判断线程A是否仍然存活。<strong>如果线程A仍然存活，</strong>将线程A暂停，此时偏向锁升级为轻量级锁，之后线程A继续执行，线程B自旋。但是<strong>如果判断结果是线程A不存在了</strong>，则线程B持有此偏向锁，锁不升级。</p><p>一旦有第二个线程加入<strong>锁竞争</strong>，偏向锁就升级为<strong>轻量级锁（自旋锁）</strong>。这里要明确一下什么是锁竞争：如果多个线程轮流获取一个锁，但是每次获取锁的时候都很顺利，没有发生阻塞，那么就不存在锁竞争。只有当某线程尝试获取锁的时候，发现该锁已经被占用，只能等待其释放，这才发生了锁竞争。</p><p>在轻量级锁状态下继续锁竞争，没有抢到锁的线程将<strong>自旋</strong>，即不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。先<strong>比较</strong>当前锁标志位是否为“释放”，如果是则将其<strong>设置</strong>为“锁定”，比较并设置是<strong>原子性</strong>发生的。这就算抢到锁了，然后线程将当前锁的持有者信息修改为自己。</p><p>长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做<strong>忙等（busy-waiting）</strong>。如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么synchronized就用轻量级锁，允许短时间的忙等现象。这是一种折衷的想法，<strong>短时间的忙等，换取线程在用户态和内核态之间切换的开销。</strong></p><p>显然，此忙等是有限度的（有个计数器记录自旋次数，默认允许循环10次，可以通过虚拟机参数更改）。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为<strong>重量级锁</strong>（依然是CAS修改锁标志位，但不修改持有锁的线程ID）。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。在JDK1.6之前，synchronized直接加重量级锁，很明显现在得到了很好的优化。</p><p>一个锁只能按照 偏向锁、轻量级锁、重量级锁的顺序逐渐升级（也有叫<strong>锁膨胀</strong>的），不允许降级。</p><h2 id="可重入锁（递归锁）"><a href="#可重入锁（递归锁）" class="headerlink" title="可重入锁（递归锁）"></a>可重入锁（递归锁）</h2><p>可重入锁的字面意思是 “可以重新进入的锁”，即<strong>允许同一个线程多次获取同一把锁</strong>。比如一个递归函数中有加锁的操作，递归过程中这个锁会阻塞自己吗？如果不会，那么这个锁就是<strong>可重入锁</strong>。</p><p>Java 里只要以 Reentrant 开头命名的锁都是可重入锁，而且 <strong>JDK 提供的所有现成的 Lock 实现类，包括 synchronized 关键字锁都是可重入的。</strong></p><p>如果你不需要可重入锁，可以自己实现。绝大部分场景，可重入锁就可以了。</p><p><img src="/2022/02/01/%E9%94%81%E5%8F%8AJava%E7%9A%84%E5%AE%9E%E7%8E%B0/v2-ffbe0e21512c64a1b444cf55d4b3bf61_1440w.jpg" alt="JDK提供的Lock的实现类都是可重入的"></p><h2 id="公平锁、非公平锁"><a href="#公平锁、非公平锁" class="headerlink" title="公平锁、非公平锁"></a>公平锁、非公平锁</h2><p>如果多个线程申请一把<strong>公平锁</strong>，那么当锁释放的时候，先申请的先得到，非常公平。显然如果是<strong>非公平锁</strong>，后申请的线程可能先获取到锁，是随机或者按照其他优先级排序的。</p><p>对ReentrantLock类而言，通过构造函数传参<strong>可以指定该锁是否是公平锁，默认是非公平锁</strong>。一般情况下，非公平锁的吞吐量比公平锁大，如果没有特殊要求，优先使用非公平锁。</p><p><img src="/2022/02/01/%E9%94%81%E5%8F%8AJava%E7%9A%84%E5%AE%9E%E7%8E%B0/v2-7a4a72fe7ace46095cd3ca2e6c5212d9_1440w.jpg" alt="ReentrantLock构造器可以指定为公平或非公平"></p><p>对于synchronized而言，它也是一种<strong>非公平锁</strong>，但是并没有任何办法使其变成公平锁。</p><h2 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h2><p>可中断锁，字面意思是“可以<strong>响应中断</strong>的锁”。</p><p>这里的关键是理解什么是<strong>中断</strong>。Java并没有提供任何直接中断某线程的方法，只提供了<strong>中断机制</strong>。何谓“中断机制”？线程A向线程B发出“请你停止运行”的请求（线程B也可以自己给自己发送此请求），但线程B并不会立刻停止运行，而是自行选择合适的时机以自己的方式响应中断，也可以直接忽略此中断。也就是说，Java的<strong>中断不能直接终止线程</strong>，而是需要被中断的线程自己决定怎么处理。这好比是父母叮嘱在外的子女要注意身体，但子女是否注意身体，怎么注意身体则完全取决于自己。</p><p>回到锁的话题上来，如果线程A持有锁，线程B等待获取该锁。由于线程A持有锁的时间过长，线程B不想继续等待了，我们可以让线程B中断自己或者在别的线程里中断它，这种就是<strong>可中断锁</strong>。</p><p>在Java中，synchronized就是<strong>不可中断锁</strong>，而Lock的实现类都是<strong>可中断锁，</strong>可以简单看下Lock接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* Lock接口 */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Lock</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 拿不到锁就一直等，拿到马上返回。</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>; <span class="hljs-comment">// 拿不到锁就一直等，如果等待时收到中断请求，则需要处理InterruptedException。</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 无论拿不拿得到锁，都马上返回。拿到返回true，拿不到返回false。</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>; <span class="hljs-comment">// 同上，可以自定义等待的时间。</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="读写锁、共享锁、互斥锁"><a href="#读写锁、共享锁、互斥锁" class="headerlink" title="读写锁、共享锁、互斥锁"></a>读写锁、共享锁、互斥锁</h2><p>读写锁就是一对锁，一个读锁（共享锁）和一个写锁（互斥锁、拍他锁）。</p><p>看下Java里的ReadWriteLock接口，它只规定了两个方法，一个返回读锁，一个返回写锁。</p><p><img src="/2022/02/01/%E9%94%81%E5%8F%8AJava%E7%9A%84%E5%AE%9E%E7%8E%B0/v2-5ec6ed066c75e59c4f3829ca51db8148_1440w.jpg"></p><p>读写锁和乐观锁做的事情是一样的，所有现成都可以读取，仅在写之前判断值有没有被修改。</p><p>很多情况下，线程知道自己读取数据后，是否是为了更新他。如果我读取值时候就是为了更新它（MySQL for update），那么加锁的时候就直接加上写锁，我持有写锁的时候别的线程无论读还是写都需要等待；如果我读取数据仅仅为了展示，那么加锁就明确的加一个<strong>读锁</strong>，其他线程如果也要读，就无需等待，直接加读锁获取（读锁计数器 + 1）。</p><p>虽然读写锁感觉与乐观锁有点像，但是<strong>读写锁是悲观锁策略</strong>。因为读写锁并没有在<strong>更新前</strong>判断值有没有被修改过，而是在<strong>加锁前</strong>决定应该用读锁还是写锁。乐观锁特指无锁编程。</p><p>JDK提供的唯一一个 ReadWriteLock 接口实现类是 ReentrantReadWriteLock。看名字就知道，它不仅提供了读写锁，而是都是可重入锁。 除了两个接口方法以外，ReentrantReadWriteLock 还提供了一些便于外界监控其内部工作状态的方法，这里就不一一展开。</p><h2 id="回到悲观锁和乐观锁"><a href="#回到悲观锁和乐观锁" class="headerlink" title="回到悲观锁和乐观锁"></a>回到悲观锁和乐观锁</h2><p>在 Java 中使用的各种锁，<strong>几乎都是悲观锁</strong>。synchronized 从偏向锁、轻量级锁到重量级锁，全是悲观锁。JDK提供的Lock实现类全是悲观锁。其实只要有“锁对象”出现，那么就一定是悲观锁。因为<strong>乐观锁不是锁，而是一个在循环里尝试CAS的算法。</strong></p><p>那JDK并发包里到底有没有乐观锁呢？</p><p>有。java.util.concurrent.atomic包里面的<strong>原子类</strong>都是利用乐观锁实现的。</p><p><img src="/2022/02/01/%E9%94%81%E5%8F%8AJava%E7%9A%84%E5%AE%9E%E7%8E%B0/v2-98cd919fe09521bac03aa66d6968aeb2_1440w.jpg" alt="原子类AtomicInteger的自增方法为乐观锁策略"></p><p>虽然轻量级锁上用到了 CAS 循环等待，感觉好像是乐观锁。但是问题的关键是，我们说一个锁是乐观锁还是倍感锁，总是应该站在应用层的层面，看它们是如何锁住数据的，等后续更新时再决定要不要重试？对于偏向锁、轻量级锁来说，显然答案是否定的。无论是挂起还是忙等，对应用数据的读取操作都被“挡住”了。从这个角度看，它们确实是悲观锁。</p>]]></content>
    
    
    <categories>
      
      <category>多线程</category>
      
      <category>锁</category>
      
    </categories>
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列MQ</title>
    <link href="/2022/01/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97MQ/"/>
    <url>/2022/01/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97MQ/</url>
    
    <content type="html"><![CDATA[<h1 id="剖析消息队列"><a href="#剖析消息队列" class="headerlink" title="剖析消息队列"></a>剖析消息队列</h1><p>面试中有几个关于消息队列经典问题：</p><ul><li>如何保证消息不丢失？</li><li>如何处理重复消息？</li><li>如何保证消息的有序性？</li><li>如果处理消息堆积？</li></ul><span id="more"></span><p>要解决这些问题，先要简单的了解消息队列</p><h2 id="什么是消息队列？"><a href="#什么是消息队列？" class="headerlink" title="什么是消息队列？"></a>什么是消息队列？</h2><p>在计算机科学领域，消息队列和邮箱都是软件工程组件，通常用于进程间或同一进程内的线程通信。它们通过队列来传递消息-传递控制信息或内容，群组通信系统提供类似的功能。</p><p>简单来说：<strong>消息队列就是一个使用队列通信的组件</strong>。</p><p>但是我们日常所说的<strong>消息队列常常代指消息中间件</strong>，它的存在不仅仅只是为了通信这一个问题。</p><h2 id="为什么需要消息队列"><a href="#为什么需要消息队列" class="headerlink" title="为什么需要消息队列"></a>为什么需要消息队列</h2><p>从本质上来说是因为互联网的快速发展，<strong>业务不断扩张</strong>，促使技术架构需要不断的演进。</p><p>消息队列就应运而生了。它常用来实现：<strong>异步处理、服务解耦、流量控制</strong>。</p><h3 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h3><p>随着公司的发展你可能会发现你项目的<strong>请求链路越来越长</strong>，例如刚开始的电商项目，可以就是粗暴的扣库存、下单。慢慢地又加上积分服务、短信服务等。这一路同步调用下来客户可能等急了，这时候就是消息队列登场的好时机。</p><p><strong>调用链路长、响应就慢了</strong>，并且相对于扣库存和下单，积分和短信没必要这么的 “及时”。因此只需要在下单结束那个流程，扔个消息到消息队列中就可以直接返回响应了。而且积分服务和短信服务可以并行的消费这条消息。</p><p>可以看出消息队列可以<strong>减少请求的等待，还能让服务异步并发处理，提升系统总体性能</strong>。</p><p><img src="/2022/01/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97MQ/image-20220130230133161.png" alt="同步处理与异步处理"></p><h3 id="服务解耦"><a href="#服务解耦" class="headerlink" title="服务解耦"></a>服务解耦</h3><p>上面说到了积分服务，既然有积分有数据，就可能会延伸出数据分析服务。</p><p>可以发现订单下游系统在不断的扩充，为了迎合这些下游系统订单服务需要经常地修改，任何一个下游系统接口的变更可能都会影响到订单服务，那订单服务就疯了。</p><p>所以一般会选用消息队列来解决系统之间耦合的问题，订单服务把订单相关消息塞到消息队列中，下游系统谁要谁就订阅这个主题。这样订单服务就解放啦！</p><p><img src="/2022/01/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97MQ/image-20220130230524105-3555126.png" alt="服务解耦"></p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>想必大家都听过「削峰填谷」，后端服务相对而言都是比较「弱」的，因为业务较重，处理时间较长。像一些例如秒杀活动爆发式流量打过来可能就顶不住了。因此需要引入一个中间件来做缓冲，消息队列再适合不过了。</p><p>网关的请求先放入消息队列中，后端服务尽自己最大能力去消息队列中消费请求。超时的请求可以直接返回错误。</p><p>当然还有一些服务特别是某些后台任务，不需要及时地响应，并且业务处理复杂且流程长，那么过来的请求先放入消息队列中，后端服务按照自己的节奏处理。这也是很 nice 的。</p><p>上面两种情况分别对应着生产者生产过快和消费者消费过慢两种情况，消息队列都能在其中发挥很好的缓冲效果。</p><p><img src="/2022/01/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97MQ/image-20220130230648174-3555210.png" alt="image-20220130230648174"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>引入消息队列固然有以上的好处，但是多引入一个中间件系统的稳定性就下降一层，运维的难度抬高一层。因此要<strong>权衡利弊</strong>，<strong>系统是演进的</strong>。</p><h2 id="消息队列的基本概念"><a href="#消息队列的基本概念" class="headerlink" title="消息队列的基本概念"></a>消息队列的基本概念</h2><p>消息队列有两种模型：<strong>队列模型</strong> 和 <strong>发布订阅模型</strong>。</p><h3 id="队列模型"><a href="#队列模型" class="headerlink" title="队列模型"></a>队列模型</h3><p>生产者往某个队列里面发送消息，一个队列可以存储多个生产者的消息，一个队列也可以有多个消费者，但是消费者之间是竞争关系，即每条消息只能被一个消费者消费。</p><p><img src="/2022/01/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97MQ/image-20220130230854946-3555336.png" alt="队列模型"></p><h3 id="发布订阅模型"><a href="#发布订阅模型" class="headerlink" title="发布订阅模型"></a>发布订阅模型</h3><p><strong>为了解决一条消息能被多个消费者消费的问题</strong>，发布/订阅模型就来了。该模型是将消息发往一个 Topic 即主题中，所有订阅了这个 Topic 的订阅者都能消费这条消息。</p><p>就相当于加入了一个群聊，生产者发布一条消息，所有消费者都能收到这个消息。</p><p>类比之下，队列模型就像是一对一聊天，一时间只能是私聊。</p><p>但是私聊的话，生产者私聊每一个人也能实现一条消息被多个消费者消费。通过多队列全量存储相同的信息，即数据的冗余可以实现一条消息被多个消费者消费。<code>RabbitMQ</code> 就是采用队列模型，通过 <code>Exchange</code> 模块来将消息发送至多个队列，从而解决了一条消息要被多个消费者消费的问题。</p><p>这里还能看到假设群聊里除我之外只有一个人，那么此时的发布/订阅模型和队列模型其实就一样了。</p><p><img src="/2022/01/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97MQ/image-20220130231233884-3555555.png" alt="发布订阅"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>队列模型每条消息只能被一个消费者消费，而发布/订阅模型就是为让一条消息可以被多个消费者消费而生的，当然队列模型也可以通过消息全量存储至多个队列来解决一条消息被多个消费者消费问题，但是会有数据的冗余，但并不是不可行。</p><p><strong>发布/订阅模型兼容队列模型</strong>，即只有一个消费者的情况下和队列模型基本一致。</p><p>RabbitMQ 采用队列模型， RocketMQ 和 Kafka 采用发布/订阅模型。</p><p><strong>接下来的内容都基于发布/订阅模型</strong>。</p><h2 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h2><p>一般我们称发送消息方为生产者 <code>Producer</code> ，接受消费消息方为消费者 <code>Consumer</code> ，消息队列服务端为 <code>Broker</code> 。</p><p>消息从 <code>Producer</code> 发往<code> Broker</code> ，<code> Broker</code> 将消息存储至本地，然后 <code>Consumer</code> 从 <code>Broker</code> 拉取消息，或者<code> Broker</code> 推送消息至 <code>Consumer</code> ，最后消费。</p><p><img src="/2022/01/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97MQ/image-20220130231507244-3555708.png" alt="生产者消费者模型"></p><p>为了提高并发度，往往<strong>发布订阅模型</strong>还会引入<strong>队列</strong>或者<strong>分区</strong>的概念。即消息是发往一个主题下的某个队列或者某个分区中。 RocketMQ 中叫队列， Kafka 叫分区，本质一样。</p><p>例如某个主题下有 5 个队列，那么这个主题的并发度就提高为 5 ，同时可以有 5 个消费者<strong>并行消费</strong>该主题的消息。一般可以采用轮询或者 key hash 取余等策略来将同一个主题的消息分配到不同的队列中。</p><p>与之对应的消费者一般都有组的概念 Consumer Group , 即消费者都是属于某个消费组的。一条消息会发往多个订阅了这个主题的消费组。</p><p>假设现在有两个消费组分别是 Group 1 和 Group 2 ，它们都订阅了 Topic-a 。此时有一条消息发往 Topic-a ，那么这两个消费组都能接收到这条消息。</p><p>然后这条消息实际是写入 Topic 某个队列中，消费组中的某个消费者对应消费一个队列的消息。</p><p>在物理上除了副本拷贝之外，一条消息在 Broker 中只会有一份，每个消费组会有自己的 offset 即消费点位来标识消费到的位置。在消费点位之前的消息表明已经消费过了。当然这个 offset 是队列级别的。每个消费组都会维护订阅的 Topic 下的每个队列的 offset 。</p><p>来个图看看应该就很清晰了。</p><p><img src="/2022/01/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97MQ/image-20220130231745047-3555866.png" alt="并行消费"></p><p>基本上熟悉了消息队列常见的术语和一些概念之后，咱们再来看看消息队列常见的核心面试点。</p><h2 id="如何保证消息不丢失"><a href="#如何保证消息不丢失" class="headerlink" title="如何保证消息不丢失"></a>如何保证消息不丢失</h2><p>就我们市面上常见的消息队列而言，只要<strong>配置得当</strong>，我们的消息就不会丢。</p><p>先来看看这个图，</p><p><img src="/2022/01/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97MQ/image-20220130231918458-3555959.png" alt="生产消费模型"></p><p>可以看到一共有三个阶段，分别是<strong>生产消息、存储消息和消费消息</strong>。我们从这三个阶段分别入手来看看如何确保消息不会丢失。</p><h3 id="生产信息"><a href="#生产信息" class="headerlink" title="生产信息"></a>生产信息</h3><p>生产者发送消息至 <code>Broker</code> ，需要 <code>Broker</code> 的响应，不论是同步还是异步发送消息，同步和异步回调都需要做好 <code>try-catch</code>，妥善的处理响应，如果 <code>Broker</code> 返回写入失败等错误信息，需要重试发送。当多次发送失败需要作出报警，日志记录等。</p><p>这样就能保证在生产消息阶段消息不会丢失。</p><h3 id="存储信息"><a href="#存储信息" class="headerlink" title="存储信息"></a>存储信息</h3><p>存储消息阶段需要在<strong>消息刷盘之后</strong>再给生产者响应，假设消息写入缓存中就返回响应，那么机器突然断电这消息就没了，而生产者以为已经发送成功了。</p><p>如果 Broker 是集群部署，有多副本机制，即消息不仅仅要写入当前 Broker ,还需要写入副本机中。那配置成至少写入两台机子后再给生产者响应。这样基本上就能保证存储的可靠了。一台挂了还有一台还在呢（假如怕两台都挂了..那就再多些）。</p><p>那假如来个地震机房机子都挂了呢？emmmmmm…大公司基本上都有异地多活。</p><p>那要是这几个地都地震了呢？emmmmmm…这时候还是先关心关心人吧。</p><h3 id="消息信息"><a href="#消息信息" class="headerlink" title="消息信息"></a>消息信息</h3><p>这里经常会有同学犯错，当消费者拿到消息之后直接存入内存队列中就直接返回给 Broker 消费成功，这是不对的。</p><p>需要考虑拿到消息放在内存之后消费者就宕机了怎么办。所以我们应该在<strong>消费者真正执行完业务逻辑</strong>之后，再发送给Broker <strong>消费成功</strong>，这才是真正的消费了。</p><p>所以只要我们在消息业务逻辑处理完成之后再给 Broker 响应，那么消费阶段消息就不会丢失。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>可以看出，保证消息的可靠性需要<strong>三方配合</strong>。</p><p><code>Producer</code> 需要处理好 <code>Broker</code> 的响应，出错情况利用重试，报警等手段。</p><p><code>Broker</code> 需要控制响应的时机，单机情况下是消息刷盘后响应，集群多副本情况下，即发送至两个副本及以上的情况下再返回响应。</p><p><code>Customer</code> 需要在执行完真正的业务逻辑之后再返回响应给 <code>Broker</code>。</p><p>但是要注意，<strong>消息可靠性强，不可避免的造成性能的下降</strong>。等待消息刷盘，多副本同步都会影响性能，因此还是要看业务，例如有些记录丢了一两条问题也不大，完全可以牺牲掉这几条来保证更高的效率。</p><h2 id="如何处理重复消息？"><a href="#如何处理重复消息？" class="headerlink" title="如何处理重复消息？"></a>如何处理重复消息？</h2><p>假设我们发送消息，只有发送，不管 <code>Broker</code> 的响应，那么我们发往 <code>Broker</code> 是不会重复的。</p><p>但是一般情况下不允许这样，这样的话消息就完全不可靠了，基本需求是消息至少得发到 <code>Broker</code> 上，那就得等 <code>Broker</code> 的响应，那么就可能存在 <code>Broker</code> 已经写入了，当时响应由于网络原因没有收到，然后生产者又重发了一次，此时消息就重复了。</p><p>再看消费者消费时，假设我们消费者拿到消息消费了，业务逻辑都走完了，事务提交了，此时需要更新 <code>Custom offset</code> 了，然后这个时候消费者挂了，另一个消费者顶上，此时 <code>Consumer offset</code> 还没更新，于是又拿到刚才那条消息，业务又被走了一遍，于是消息又重复了。</p><p>可以看到正常业务而言<strong>消息重复时不可避免的</strong>，因此我们只能从<strong>另外一个角度</strong>来解决重复消息的问题。</p><p>关键点就是<strong>幂等</strong>。既然我们不能防治重复消息的产生，那我们只能在业务上处理重复消息所带来的影响。</p><h3 id="幂等处理重复消息"><a href="#幂等处理重复消息" class="headerlink" title="幂等处理重复消息"></a>幂等处理重复消息</h3><p>幂等时数学上的概念，在计算机中可以理解为同样的参数多次调用同一个接口和调用一次产生的结果是一致的。</p><p>例如这条 SQL </p><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs sql">update t1 <span class="hljs-keyword">set</span> money <span class="hljs-operator">=</span> <span class="hljs-number">150</span> <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> money <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <br></code></pre></td></tr></table></figure><p>执行多少遍 money 都是150，这就叫幂等。</p><p>因此需要改造业务逻辑，使得重复消息的情况下也不会影响到最终的结果。</p><p>可以通过上面那条SQL语句一样，做个<strong>前置条件判断</strong>，即 <code>money = 100</code> 的情况，并且直接修改，更通用的是做一个 <code>version</code> 即版本控制，对比消息中的版本好和数据库中的版本号。</p><p>或者通过<strong>数据库约束例如唯一键</strong>，例如:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> update <span class="hljs-keyword">on</span> duplicate key ...<br></code></pre></td></tr></table></figure><p>或者<strong>记录关键的key</strong>，比如处理订单这种，记录订单 ID，加入又重复的消息过来，先判断下这个 ID 是否已经被处理过了，如果没有处理再进行下一步。当然也可以使用全局唯一 ID。</p><p>当然<strong>具体情况还要具体看业务的细节</strong>。通用就这么几个套路。</p><h2 id="如何保证消息的有序性？"><a href="#如何保证消息的有序性？" class="headerlink" title="如何保证消息的有序性？"></a>如何保证消息的有序性？</h2><p>有序性分为：<strong>全局有序和部分有序</strong></p><h3 id="全局有序"><a href="#全局有序" class="headerlink" title="全局有序"></a>全局有序</h3><p>如果要保证消息的全局有序，首先只能由一个生产者往 <code>Topic</code> 发送消息，并且一个 <code>Topic</code> 内部只能有一个队列（分区）。消费者也必须是单线程消费这个队列，这样的消息肯定是全局有序的！</p><p>不过一般情况下不需要全局有序，即使是同步 <code>MySQL Binlog</code> 也只需要保证单表消息有序即可。</p><p><img src="/2022/01/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97MQ/image-20220131170138336-3619700.png" alt="全局有序"></p><h3 id="部分有序"><a href="#部分有序" class="headerlink" title="部分有序"></a>部分有序</h3><p>因此绝大部分的有序要求是部分有序，部分有序我们就可以将 <code>Topic</code> 内部划分成我们需要的队列数，把消息通过特定的策略发往固定的队列中，然后每个队列对应一个单线程处理的消费者。这样既完成了部分有序的需求，又可以通过队列数量的并发来提高消息处理的效率。</p><p><img src="/2022/01/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97MQ/image-20220131170329067-3619811.png" alt="部分有序"></p><p>生产者也可以是一个，只要同类消息发往指定的队列即可。</p><h2 id="如何处理消息堆积"><a href="#如何处理消息堆积" class="headerlink" title="如何处理消息堆积"></a>如何处理消息堆积</h2><p>消息的堆积往往是因为<strong>生产者的生产速度与消费速度不匹配</strong>。有可能是因为消息消费失败反复重试造成的，也有可能就是消费者消费能力弱，渐渐地消息就积压了。</p><p>首先要定位<strong>消息堆积的原因</strong>，一般就是消费满的原因。如果是 bug 就处理 bug，如果是本身消费能力弱，就优化消费逻辑，如果之前插入数据是一条一条，那现在就一批一批。</p><p>假如逻辑我们已经都优化了，但还是慢，那就得考虑水平扩容了，增加 Topic 的队列数和消费者数量，<strong>注意队列数一定要增加</strong>，不然新增加的消费者是没东西消费的。<strong>一个 Topic 中，一个队列只会分配给一个消费者</strong>。</p><p>当然你消费者内部是单线程还是多线程消费那看具体场景。不过要注意上面提高的消息丢失的问题，如果你是将接受到的消息写入<strong>内存队列</strong>之后，然后就返回响应给 Broker ，然后多线程向内存队列消费消息，假设此时消费者宕机了，内存队列里面还未消费的消息也就丢了。</p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络常见面试题-补充</title>
    <link href="/2022/01/30/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%A1%A5%E5%85%85/"/>
    <url>/2022/01/30/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h1 id="网络常见面试题-补充"><a href="#网络常见面试题-补充" class="headerlink" title="网络常见面试题-补充"></a>网络常见面试题-补充</h1><span id="more"></span><h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><h3 id="简易："><a href="#简易：" class="headerlink" title="简易："></a>简易：</h3><p><img src="/2022/01/30/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%A1%A5%E5%85%85/%E7%8A%B6%E6%80%81%E7%A0%81.png" alt="状态码"></p><h3 id="详细-HTTP-状态码："><a href="#详细-HTTP-状态码：" class="headerlink" title="详细 HTTP 状态码："></a>详细 HTTP 状态码：</h3><table><thead><tr><th align="left">状态码</th><th align="left">状态码英文名称</th><th align="left">中文描述</th></tr></thead><tbody><tr><td align="left">100</td><td align="left">Continue</td><td align="left">继续。客户端应继续其请求</td></tr><tr><td align="left">101</td><td align="left">Switching Protocols</td><td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">200</td><td align="left">OK</td><td align="left">请求成功。一般用于GET与POST请求</td></tr><tr><td align="left">201</td><td align="left">Created</td><td align="left">已创建。成功请求并创建了新的资源</td></tr><tr><td align="left">202</td><td align="left">Accepted</td><td align="left">已接受。已经接受请求，但未处理完成</td></tr><tr><td align="left">203</td><td align="left">Non-Authoritative Information</td><td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td align="left">204</td><td align="left">No Content</td><td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td align="left">205</td><td align="left">Reset Content</td><td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td align="left">206</td><td align="left">Partial Content</td><td align="left">部分内容。服务器成功处理了部分GET请求</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">300</td><td align="left">Multiple Choices</td><td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td align="left">301</td><td align="left">Moved Permanently</td><td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="left">302</td><td align="left">Found</td><td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="left">303</td><td align="left">See Other</td><td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td align="left">304</td><td align="left">Not Modified</td><td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td align="left">305</td><td align="left">Use Proxy</td><td align="left">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td align="left">306</td><td align="left">Unused</td><td align="left">已经被废弃的HTTP状态码</td></tr><tr><td align="left">307</td><td align="left">Temporary Redirect</td><td align="left">临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">400</td><td align="left">Bad Request</td><td align="left">客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="left">401</td><td align="left">Unauthorized</td><td align="left">请求要求用户的身份认证</td></tr><tr><td align="left">402</td><td align="left">Payment Required</td><td align="left">保留，将来使用</td></tr><tr><td align="left">403</td><td align="left">Forbidden</td><td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td align="left">404</td><td align="left">Not Found</td><td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td align="left">405</td><td align="left">Method Not Allowed</td><td align="left">客户端请求中的方法被禁止</td></tr><tr><td align="left">406</td><td align="left">Not Acceptable</td><td align="left">服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td align="left">407</td><td align="left">Proxy Authentication Required</td><td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td align="left">408</td><td align="left">Request Time-out</td><td align="left">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="left">409</td><td align="left">Conflict</td><td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td align="left">410</td><td align="left">Gone</td><td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td align="left">411</td><td align="left">Length Required</td><td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td align="left">412</td><td align="left">Precondition Failed</td><td align="left">客户端请求信息的先决条件错误</td></tr><tr><td align="left">413</td><td align="left">Request Entity Too Large</td><td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td align="left">414</td><td align="left">Request-URI Too Large</td><td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td align="left">415</td><td align="left">Unsupported Media Type</td><td align="left">服务器无法处理请求附带的媒体格式</td></tr><tr><td align="left">416</td><td align="left">Requested range not satisfiable</td><td align="left">客户端请求的范围无效</td></tr><tr><td align="left">417</td><td align="left">Expectation Failed</td><td align="left">服务器无法满足Expect的请求头信息</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">500</td><td align="left">Internal Server Error</td><td align="left">服务器内部错误，无法完成请求</td></tr><tr><td align="left">501</td><td align="left">Not Implemented</td><td align="left">服务器不支持请求的功能，无法完成请求</td></tr><tr><td align="left">502</td><td align="left">Bad Gateway</td><td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td align="left">503</td><td align="left">Service Unavailable</td><td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td align="left">504</td><td align="left">Gateway Time-out</td><td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td align="left">505</td><td align="left">HTTP Version not supported</td><td align="left"></td></tr></tbody></table><h2 id="各种协议与-HTTP-协议之间的关系"><a href="#各种协议与-HTTP-协议之间的关系" class="headerlink" title="各种协议与 HTTP 协议之间的关系"></a>各种协议与 HTTP 协议之间的关系</h2><p>图片来源：《图解 HTTP 》</p><p><img src="/2022/01/30/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%A1%A5%E5%85%85/%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="各种协议与HTTP协议之间的关系"></p><h2 id="HTTP-长连接，短连接"><a href="#HTTP-长连接，短连接" class="headerlink" title="HTTP 长连接，短连接"></a>HTTP 长连接，短连接</h2><p>在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JS文件、图像文件、CSS文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。</p><p>而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：</p><figure class="highlight http"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs http">Connection:keep-alive<br></code></pre></td></tr></table></figure><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永远保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p><strong>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</strong></p><h2 id="HTTP-是不保存状态的协议，如何保存用户状态"><a href="#HTTP-是不保存状态的协议，如何保存用户状态" class="headerlink" title="HTTP 是不保存状态的协议，如何保存用户状态"></a>HTTP 是不保存状态的协议，如何保存用户状态</h2><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议本身不对请求和相应之间的通信状态进行保存。那保存的用户状态呢？</p><p>Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的常见是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户进行操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标志性这个用户并且跟踪这个用户了。（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</p><p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p><p><img src="/2022/01/30/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-%E8%A1%A5%E5%85%85/HTTP%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84.png" alt="HTTP是无状态协议"></p><h3 id="问题来了，Cookie被禁用怎么办？"><a href="#问题来了，Cookie被禁用怎么办？" class="headerlink" title="问题来了，Cookie被禁用怎么办？"></a>问题来了，Cookie被禁用怎么办？</h3><p>最常见的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p><h2 id="Cookie-是啥？和-Session-有什么区别"><a href="#Cookie-是啥？和-Session-有什么区别" class="headerlink" title="Cookie 是啥？和 Session 有什么区别"></a>Cookie 是啥？和 Session 有什么区别</h2><p>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是二者的应用场景不太一样。</p><p><strong>Cookie 一般用来保存用户信息</strong>。比如：</p><ol><li>我们在 Cookie 中已经登陆过的用户信息，下载访问网站的时候可以自动帮你登陆的一些基本信息给填了；</li><li>一般网站都会有保持登陆，也就是说下次你在访问网站的时候就不需要重新登陆了，这是因为用户登录的时候我们可以存放一个 Token 在 Cookie 中，下次登陆的时候只需要根据 Token 值来查找用户即可。（为了安全起见，重新登录一般要将 Token 重写）。</li><li>登陆一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态</strong>。</li></ol><p>Cookie 数据保存在客户端（浏览器端），Session 数据保存在服务器端。</p><p>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><h2 id="HTTP-1-0-和-HTTP-1-1-的主要区别是什么？"><a href="#HTTP-1-0-和-HTTP-1-1-的主要区别是什么？" class="headerlink" title="HTTP 1.0 和 HTTP 1.1 的主要区别是什么？"></a>HTTP 1.0 和 HTTP 1.1 的主要区别是什么？</h2><p>HTTP1.0 最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页上和网络请求上，而 HTTP1.1 则在 1999 年才开始广泛应用于现在的各大浏览器网络请求中，同时 HTTP1.1 也是当前使用最为广泛的 HTTP 协议。 主要区别主要体现在：</p><ol><li><strong>长连接</strong> : <strong>在 HTTP/1.0 中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于 TCP/IP 协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1 起，默认使用长连接</strong>,默认开启 Connection： keep-alive。 <strong>HTTP/1.1 的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到 HTTP 的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li><li><strong>错误状态响应码</strong> :在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>缓存处理</strong> :在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li></ol><h2 id="URI-和-URL-的区别是什么？"><a href="#URI-和-URL-的区别是什么？" class="headerlink" title="URI 和 URL 的区别是什么？"></a>URI 和 URL 的区别是什么？</h2><ul><li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li><li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li></ul><p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><h2 id="HTTP-和-HTTPS-的区别？"><a href="#HTTP-和-HTTPS-的区别？" class="headerlink" title="HTTP 和 HTTPS 的区别？"></a>HTTP 和 HTTPS 的区别？</h2><ol><li><p><strong>端口</strong> ：HTTP 的 URL 由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</p></li><li><p>安全性和资源消耗：</p><p>HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</p><ul><li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有 DES、AES 等；</li><li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有 RSA、DSA 等。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>索引为什么能提高查询性能....</title>
    <link href="/2022/01/27/%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD/"/>
    <url>/2022/01/27/%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1 id="索引为什么能提高查询性能…"><a href="#索引为什么能提高查询性能…" class="headerlink" title="索引为什么能提高查询性能…."></a>索引为什么能提高查询性能….</h1><span id="more"></span><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>由 n（ n &gt; 0）个有限节点组成一个具有层次关系的集合，看起来就像一个倒挂的树，因此称这样的数据结构为树。</p><p>一个节点的子节点个数叫做度，通俗的讲就是树叉的个数。树中最大的度叫做树的度，也叫做阶。一个 2 阶树最多有 2 个子节点即最多有 2 叉，因此这样的树称为<strong>二叉树</strong>，二叉树是树家族中最简单的树。</p><p><img src="/2022/01/27/%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD/1.png" alt="图片"></p><p>两个叉的树就是二叉树，可这除了用来按一定结构存放数据外，跟查询性能好像也没关系，不会又是一个没用的噱头吧。</p><hr><h2 id="二分查找树"><a href="#二分查找树" class="headerlink" title="二分查找树"></a>二分查找树</h2><p>如果一组数据不会或不常变更，那么他们的位置也基本不变。可是每次查询都需要重新计算中间位置是一种浪费，而浪费可耻。</p><p>我们能不能把所有中间节点组织起来，每次使用时，直接取中间节点?</p><p>请看下图，找到所有单次二分查找的中间节点，把他们连起来，并用手提起最中间的那个节点，就是一棵二分查找树。</p><p><img src="/2022/01/27/%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD/2.png" alt="图片"></p><p><strong>优点</strong>：二分查找树就是通过数据结构的方式实现了二分查找算法，通过存储中间节点的数据，弥补了二分查找每次都要计算中间位置的缺点。</p><hr><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>如果二分查找树不断的进行修改，比如删除某些节点，经过一段时间后，最早那个中间节点的数据，可能就不在中间了。</p><p>中间位置好像一个天平的支点，如果不在中间，整个天平就会失衡，失衡的世界就会坍塌成不伦不类的瘸树，甚至是降维成一个链表或者数组。</p><p>二分查找算法的关键在于有序和中间节点，而二分查找树的关键是中间节点的维护，如果维护的节点已经不在中间了，那么它就失去了意义。</p><p>所以必须保证<strong>「二分查找树」</strong>是一个正确的树，一个根节点在中心的树，一个左右子树层级（高度）基本相等（高度相差不超过1）的树，一个平衡的树。</p><p>平衡二叉树中最常见的就是红黑树：</p><p><img src="/2022/01/27/%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD/3.png" alt="图片"></p><p>红黑树规定了一系列节点颜色规则，以及对应的左旋和右旋操作来保证颜色规则，从而达到了树的平衡性。</p><p>看到这花里胡哨的颜色以及复杂的规则，让人第一眼就望而却步，但所有的这些，也不过是为了保证二叉树的平衡性，由于维持平衡的操作太过麻烦，无法用一句话简单概括，只好用一堆人鬼难分的规则和步骤来实现，只要按着这些步骤就一定能实现二叉树的平衡。</p><p><em>平衡二叉树  =  二分查找树 + 平衡（左右高度相差不超过 1 ）</em></p><p>平衡二叉树并未提高二分查找树的性能，它只是保正树不会被二向箔（多次增删改）打击降维成链表或不对称的残缺树，永远维持平衡。</p><p>另外，不仅仅是二叉树，其他种类的树，也是需要有序和平衡，才能发挥最大的威力。</p><hr><h2 id="多叉树之B-tree"><a href="#多叉树之B-tree" class="headerlink" title="多叉树之B-tree"></a>多叉树之B-tree</h2><p>两个叉的树就能折半查询，理论可以提高一倍性能，那么多个叉是不是能提高更多倍性能？</p><p>如下图的 3 阶（叉）树（所有数据仅用于演示，非真实分布）</p><p><img src="/2022/01/27/%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD/4.png" alt="图片"></p><p>每个节点维护两个数据，并指向最多3个子节点，如图 3 个子节点的数据分别为：小于 17， 17 ~ 35 ，大于 35。</p><p>假设，从上图中查找 10 这个数，步骤如下：</p><ol><li>找到根节点，对比 10 与 17 和 35 的大小，发现 10 &lt; 17 在左子节点，也就是第 2 层节点；</li><li>从根节点的指针，找到左子节点，对比 10 与 8 和 12 的大小，发现 8 &lt; 10 &lt; 12，数据在当前节点的中间子节点，也就是第 3 层节点；</li><li>通过上步节点的指针，找到中间子节点（第 3 层节点），对比 10 与 9 和 10 的大小，发现 9 &lt; 10 == 10，因此找到当前节点的第二数即为结果。</li></ol><p>加上忽略的 12 个数据，从 26 个数据中查找一个数字 10，仅仅用了 log3(26)≈ 3 次，而如果用平衡二叉树,则需要 log2(26)≈ 5 次，事实证明，多叉树确实可以再次提高查找性能。</p><p>多叉树是在二分查找树的基础上，增加单个节点的数据存储数量，同时增加了树的子节点数，一次计算可以把查找范围缩小更多。</p><p><strong>优点</strong>：二叉平衡树的基础上，使加载一次节点，可以加载更多路径数据，同时把查询范围缩减到更小。</p><p><strong>复杂节点</strong>：至此，我们列举的数据都是孤零零的单个数字。试想，你手里已经有一个数据 10，为什么还要费力吧唧的再从一堆数据中找到这个 10，自己找自己？这不是有病吗？</p><p>单个数字只能活在演示中，现实的世界要复杂的多，我们来看一个接近真实场景的案例。</p><p>现有一个以年龄为索引的 3 阶树，存储了一批用户信息，如下图：</p><p><img src="/2022/01/27/%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD/5.png" alt="图片"></p><p>数字为用户的年龄，其它为与树排序查找无关的业务数据，像这种索引数据与树排序查找无关的业务一起维护在节点的平衡多叉（阶）树称为 B- 树（ B 树）。</p><p><strong>缺点</strong>：业务数据的大小可能远远超过了索引数据的大小，每次为了查找对比计算，需要把数据加载到内存以及 CPU 高速缓存中时，都要把索引数据和无关的业务数据全部查出来。本来一次就可以把所有索引数据加载进来，现在却要多次才能加载完。如果所对比的节点不是所查的数据，那么这些加载进内存的业务数据就毫无用处，全部抛弃。</p><hr><h2 id="多叉树之-B-Tree"><a href="#多叉树之-B-Tree" class="headerlink" title="多叉树之 B+Tree"></a>多叉树之 B+Tree</h2><p>做为数据库的索引，无论用什么样的数据结构维护，这些数据最终都会存储到磁盘中。</p><p>鉴于磁盘  I/O 的性能问题，以及每次 I/O 获取数据量上限所限，提高索引本身 I/O 的方法最好是，减少 I/O 次数和每次获取有用的数据。</p><p>B-tree 已经大大改进了树家族的性能，它把多个数据集中存储在一个节点中，本身就可能减少了 I/O 次数或者寻道次数。</p><p>但是仍然有一个致命的缺陷，那就是它的索引数据与业务绑定在一块，而业务数据的大小很有可能远远超过了索引数据，这会大大减小一次 I/O 有用数据的获取，间接的增加 I/O 次数去获取有用的索引数据。</p><p>因为业务数据才是我们查询最终的目的，但是它又是在「二分」查找中途过程无用的数据，因此，如果只把业务数据存储在最终查询到的那个节点是不是就可以了？</p><p>理想很丰满，现实很骨瘦如柴，谁知道哪个节点就是最终要查询的节点呢？</p><p>B+tree 横空出世，<strong>B+ 树就是为了拆分索引数据与业务数据的平衡多叉树</strong>。</p><p><img src="/2022/01/27/%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD/12.png" alt="图片"></p><p>B+ 树中，非叶子节点只保存索引数据，叶子节点保存索引数据与业务数据。这样即保证了叶子节点的简约干净，数据量大大减小，又保证了最终能查到对应的业务数。既提高了单次 I/O 数据的有效性，又减少了 I/O 次数，还实现了业务。</p><p>但是，在数据中索引与数据是分离的，不像示例那样的？</p><p>如图：我们只需要把真实的业务数据，换成数据所在地址就可以了，此时，业务数据所在的地址在 B+ 树中充当业务数据。</p><p><img src="/2022/01/27/%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD/13.png" alt="图片"></p>]]></content>
    
    
    <categories>
      
      <category>MySQL索引</category>
      
      <category>索引</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络常见面试题</title>
    <link href="/2022/01/26/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/01/26/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络常见面试题"><a href="#计算机网络常见面试题" class="headerlink" title="计算机网络常见面试题"></a>计算机网络常见面试题</h1><h2 id="1-OSI-与-TCP-IP-各层的结构与功能，有哪些协议？"><a href="#1-OSI-与-TCP-IP-各层的结构与功能，有哪些协议？" class="headerlink" title="1. OSI 与 TCP / IP 各层的结构与功能，有哪些协议？"></a>1. OSI 与 TCP / IP 各层的结构与功能，有哪些协议？</h2><p>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p><p><img src="/2022/01/26/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/1.png" alt="五层体系结构"></p><p>结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用</p><h3 id="1-1-应用层"><a href="#1-1-应用层" class="headerlink" title="1.1 应用层"></a>1.1 应用层</h3><p>应用层（application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信与交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。</p><p><strong>域名系统</strong></p><blockquote><p>域名系统(Domain Name System 缩写 DNS，Domain Name 被译为域名)是因特网的一项核心服务，它作为可以将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a href="http://www.ibm.com、oracle/">www.ibm.com、Oracle</a> 公司的域名是 <a href="http://www.oracle.com、cisco/">www.oracle.com、Cisco</a> 公司的域名是 <a href="http://www.cisco.com/">www.cisco.com</a> 等。</p></blockquote><p><strong>HTTP 协议</strong></p><blockquote><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p></blockquote><h3 id="1-2-运输层"><a href="#1-2-运输层" class="headerlink" title="1.2 运输层"></a>1.2 运输层</h3><p><strong>运输层（transport layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。</strong>应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p><p><strong>运输层主要使用以下两种协议:</strong></p><ol><li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li></ol><p><strong>TCP 与 UDP 的对比见问题三。</strong></p><h3 id="1-3-网络层"><a href="#1-3-网络层" class="headerlink" title="1.3 网络层"></a>1.3 网络层</h3><p><strong>在计算机网络中进行通信进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换节点，确保数据的及时传送。</strong>在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此也叫 IP 数据报，简称 数据报。</p><p>这里需要注意：<strong>不要把运输层的“用户数据报 UDP” 和网络层的“IP 数据报”弄混淆</strong>。另外，无论是哪一层的数据单元，都可以笼统的“分组”来表示。</p><p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP 层</strong>。</p><h3 id="1-4-数据链路层"><a href="#1-4-数据链路层" class="headerlink" title="1.4 数据链路层"></a>1.4 数据链路层</h3><p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p><h3 id="1-5-物理层"><a href="#1-5-物理层" class="headerlink" title="1.5 物理层"></a>1.5 物理层</h3><p>在物理层上所传送的数据单位是比特。</p><p><strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异，</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p><p>在互联网使用的各种协议中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的 TCP/IP 并不一定单指 TCP 和 IP 这两个具体的协议，而往往表示互联网所使用的整个 TCP/IP 协议族。</p><h3 id="1-6-总结"><a href="#1-6-总结" class="headerlink" title="1.6 总结"></a>1.6 总结</h3><p><img src="/2022/01/26/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/2.png" alt="七层体系结构图"></p><h2 id="2-TCP-三次握手和四次回收（异常重要）"><a href="#2-TCP-三次握手和四次回收（异常重要）" class="headerlink" title="2. TCP 三次握手和四次回收（异常重要）"></a>2. TCP 三次握手和四次回收（异常重要）</h2><p>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。</p><h3 id="2-1-TCP-三次握手图解"><a href="#2-1-TCP-三次握手图解" class="headerlink" title="2.1 TCP 三次握手图解"></a>2.1 TCP 三次握手图解</h3><p><img src="/2022/01/26/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/3.png" alt="TCP三次握手"></p><p><img src="/2022/01/26/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/4.png" alt="TCP三次握手"></p><ul><li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li><li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li><li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li></ul><p><strong>详细：</strong></p><p><img src="/2022/01/26/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/5.png" alt="1614160878-FiFlkq-image"></p><p>三次握手是 TCP 连接的建立过程。在握手之前，主动打开连接的客户端结束 CLOSE 阶段，被动打开的服务器也结束 CLOSE 阶段，并进入 LISTEN 阶段。随后进入三次握手阶段：</p><p>① 首先客户端向服务器发送一个 SYN 包，并等待服务器确认，其中：</p><p>标志位为 SYN，表示请求建立连接；<br>序号为 Seq = x（x 一般取随机数）；<br>随后客户端进入 SYN-SENT 阶段。<br>② 服务器接收到客户端发来的 SYN 包后，对该包进行确认后结束 LISTEN 阶段，并返回一段 TCP 报文，其中：</p><p>标志位为 SYN 和 ACK，表示确认客户端的报文 Seq 序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接；<br>序号为 Seq = y；<br>确认号为 Ack = x + 1，表示收到客户端的序号 Seq 并将其值加 1 作为自己确认号 Ack 的值，随后服务器端进入 SYN-RECV 阶段。<br>③ 客户端接收到发送的 SYN + ACK 包后，明确了从客户端到服务器的数据传输是正常的，从而结束 SYN-SENT 阶段。并返回最后一段报文。其中：</p><p>标志位为 ACK，表示确认收到服务器端同意连接的信号；<br>序号为 Seq = x + 1，表示收到服务器端的确认号 Ack，并将其值作为自己的序号值；<br>确认号为 Ack= y + 1，表示收到服务器端序号 seq，并将其值加 1 作为自己的确认号 Ack 的值。<br>随后客户端进入 ESTABLISHED。<br>当服务器端收到来自客户端确认收到服务器数据的报文后，得知从服务器到客户端的数据传输是正常的，从而结束 SYN-RECV 阶段，进入 ESTABLISHED 阶段，从而完成三次握手。</p><h3 id="2-2-为什么要三次握手"><a href="#2-2-为什么要三次握手" class="headerlink" title="2.2 为什么要三次握手"></a>2.2 为什么要三次握手</h3><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p><p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p><h3 id="2-3-第-2-次握手传回了-ACK，为什么还要传回-SYN？"><a href="#2-3-第-2-次握手传回了-ACK，为什么还要传回-SYN？" class="headerlink" title="2.3 第 2 次握手传回了 ACK，为什么还要传回 SYN？"></a>2.3 第 2 次握手传回了 ACK，为什么还要传回 SYN？</h3><p>接收端传回发送端所发送的 ACK 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传 SYN 则是为了建立并确认从服务端到客户端的通信。” </p><blockquote><p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p></blockquote><h3 id="2-4-为什么要四次挥手"><a href="#2-4-为什么要四次挥手" class="headerlink" title="2.4 为什么要四次挥手"></a>2.4 为什么要四次挥手</h3><p><img src="/2022/01/26/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/6.png" alt="TCP四次挥手"></p><p><strong>简易：</strong></p><ul><li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li><li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号</li><li>服务器-关闭与客户端的连接，发送一个 FIN 给客户端</li><li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1</li></ul><p><strong>详细：</strong></p><p><img src="/2022/01/26/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/7.png" alt="1612459478-ajInIu-四次挥手"></p><p>四次挥手即 TCP 连接的释放，这里假设客户端主动释放连接。在挥手之前主动释放连接的客户端结束 ESTABLISHED 阶段，随后开始四次挥手：</p><p>① 首先客户端向服务器发送一段 TCP 报文表明其想要释放 TCP 连接，其中：</p><p>标记位为 FIN，表示请求释放连接；<br>序号为 Seq = u；<br>随后客户端进入 FIN-WAIT-1 阶段，即半关闭阶段，并且停止向服务端发送通信数据。<br>② 服务器接收到客户端请求断开连接的 FIN 报文后，结束 ESTABLISHED 阶段，进入 CLOSE-WAIT 阶段并返回一段 TCP 报文，其中：</p><p>标记位为 ACK，表示接收到客户端释放连接的请求；<br>序号为 Seq = v；<br>确认号为 Ack = u + 1，表示是在收到客户端报文的基础上，将其序号值加 1 作为本段报文确认号 Ack 的值；<br>随后服务器开始准备释放服务器端到客户端方向上的连接。<br>客户端收到服务器发送过来的 TCP 报文后，确认服务器已经收到了客户端连接释放的请求，随后客户端结束 FIN-WAIT-1 阶段，进入 FIN-WAIT-2 阶段。</p><p>③ 服务器端在发出 ACK 确认报文后，服务器端会将遗留的待传数据传送给客户端，待传输完成后即经过 CLOSE-WAIT 阶段，便做好了释放服务器端到客户端的连接准备，再次向客户端发出一段 TCP 报文，其中：</p><p>标记位为 FIN 和 ACK，表示已经准备好释放连接了；<br>序号为 Seq = w；<br>确认号 Ack = u + 1，表示是在收到客户端报文的基础上，将其序号 Seq 的值加 1 作为本段报文确认号 Ack 的值。<br>随后服务器端结束 CLOSE-WAIT 阶段，进入 LAST-ACK 阶段。并且停止向客户端发送数据。</p><p>④ 客户端收到从服务器发来的 TCP 报文，确认了服务器已经做好释放连接的准备，于是结束 FIN-WAIT-2 阶段，进入 TIME-WAIT 阶段，并向服务器发送一段报文，其中：</p><p>标记位为 ACK，表示接收到服务器准备好释放连接的信号；<br>序号为 Seq= u + 1，表示是在已收到服务器报文的基础上，将其确认号 Ack 值作为本段序号的值；<br>确认号为 Ack= w + 1，表示是在收到了服务器报文的基础上，将其序号 Seq 的值作为本段报文确认号的值。<br>随后客户端开始在 TIME-WAIT 阶段等待 2 MSL。服务器端收到从客户端发出的 TCP 报文之后结束 LAST-ACK 阶段，进入 CLOSED 阶段。由此正式确认关闭服务器端到客户端方向上的连接。客户端等待完 2 MSL 之后，结束 TIME-WAIT 阶段，进入 CLOSED 阶段，由此完成「四次挥手」。</p><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p><p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p><h2 id="3-TCP，UDP-协议的区别"><a href="#3-TCP，UDP-协议的区别" class="headerlink" title="3. TCP，UDP 协议的区别"></a>3. TCP，UDP 协议的区别</h2><p><img src="/2022/01/26/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/8.png" alt="TCP、UDP协议的区别"></p><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等 </p><p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p><h2 id="4-TCP-是如何保证可靠传输的？"><a href="#4-TCP-是如何保证可靠传输的？" class="headerlink" title="4. TCP 是如何保证可靠传输的？"></a>4. TCP 是如何保证可靠传输的？</h2><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li><li><strong>ARQ 协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><h3 id="4-1-ARQ协议"><a href="#4-1-ARQ协议" class="headerlink" title="4.1 ARQ协议"></a>4.1 ARQ协议</h3><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p><h4 id="停止等待ARQ"><a href="#停止等待ARQ" class="headerlink" title="停止等待ARQ"></a>停止等待ARQ</h4><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。</p><p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p><p><strong>优缺点：</strong></p><ul><li><strong>优点：</strong> 简单</li><li><strong>缺点：</strong> 信道利用率低，等待时间长</li></ul><p><strong>1) 无差错情况:</strong></p><p>发送方发送分组, 接收方在规定时间内收到, 并且回复确认. 发送方再次发送。</p><p><strong>2) 出现差错情况（超时重传）:</strong></p><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p><p><strong>3) 确认丢失和确认迟到</strong></p><ul><li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li><li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li></ul><h4 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h4><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p><p><strong>优缺点：</strong></p><ul><li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li><li><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li></ul><h3 id="4-2-滑动窗口和流量控制"><a href="#4-2-滑动窗口和流量控制" class="headerlink" title="4.2 滑动窗口和流量控制"></a>4.2 滑动窗口和流量控制</h3><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h3 id="4-3-拥塞控制"><a href="#4-3-拥塞控制" class="headerlink" title="4.3 拥塞控制"></a>4.3 拥塞控制</h3><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。</p><p>拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送数据的速率，以便使接收端来得及接收。</p><p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><ul><li><strong>慢开始：</strong>慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的负荷情况。经验表明，较好的方式是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大窗口数值。cwnd 初始值为1，每经过一个传播轮次，cwnd 加倍。</li><li><strong>拥塞避免：</strong>拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1。</li><li><strong>快重传与快恢复：</strong>在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据报。没有 FRR，如果数据报丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失，FRR 能够最有效的工作。当有多个数据信息包在某一段很多的时间内丢失，它则不能很有效地工作。</li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ping的原理</title>
    <link href="/2022/01/23/Ping%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <url>/2022/01/23/Ping%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="ping-的原理"><a href="#ping-的原理" class="headerlink" title="ping 的原理"></a>ping 的原理</h1><h2 id="IP协议的助手-–-ICMP-协议"><a href="#IP协议的助手-–-ICMP-协议" class="headerlink" title="IP协议的助手 – ICMP 协议"></a>IP协议的助手 – ICMP 协议</h2><span id="more"></span><p>来源公众号小林coding</p><p>ping 是基于 <code>ICMP</code> 协议工作的，所以要明白 ping 的工作，首先要熟悉 <strong>ICMP 协议</strong>。</p><h3 id="什么是-ICMP-？"><a href="#什么是-ICMP-？" class="headerlink" title="什么是 ICMP ？"></a>什么是 ICMP ？</h3><p>ICMP 全称 <strong>Internet Controll Message Protocol <strong>，也就是</strong>互联网控制报文协议</strong>。</p><p>里面有个关键词 – <strong>控制</strong>，如何控制呢？</p><p>网络包在复杂的网络传输环境里，常常会遇到各种问题。当遇到问题的时候，总不能死个不明不白，没头没脑的作风不是计算机网络的风格。</p><p>所以需要传出消息，报告出现了什么问题，这样才可以调整传输策略，从此来控制整个局面。</p><hr><h3 id="ICMP-的功能都有啥？"><a href="#ICMP-的功能都有啥？" class="headerlink" title="ICMP 的功能都有啥？"></a>ICMP 的功能都有啥？</h3><p><code>ICMP</code> 主要功能包括：<strong>确认 IP 包是否成功达到目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等</strong>。</p><p>在 <code>IP</code> 通信中如果某个 <code>IP</code> 包因为某种原因未能到达目标地址，那么这个具体的原因将<strong>有 ICMP 负责通知</strong>。</p><p><img src="/2022/01/23/Ping%E7%9A%84%E5%8E%9F%E7%90%86/1.png" alt="图片"></p><p>如上图例子，主机 <code>A</code> 向主机 <code>B</code> 发送了数据包，由于某种原因，途中的路由器 <code>2</code> 未能发现主机 <code>B</code> 的存在，这时，路由器 <code>2</code> 就会向主机 <code>A</code> 发送一个 <code>ICMP</code> 目标不可达数据包，说明发往主机 <code>B</code> 的包未能成功。</p><p>ICMP 的这种通知消息会使用 <code>IP</code> 进行发送 。</p><p>收到该 ICMP 包的主机 <code>A</code> 则分解 ICMP 的首部和数据域以后得知发生的原因。</p><hr><h3 id="ICMP-包头格式"><a href="#ICMP-包头格式" class="headerlink" title="ICMP 包头格式"></a>ICMP 包头格式</h3><p>ICMP 报文是封装在 IP 包里面的，它工作在网络层，是 IP 协议的助手。</p><p><img src="/2022/01/23/Ping%E7%9A%84%E5%8E%9F%E7%90%86/2.png" alt="图片"></p><p>ICMP 包头的<strong>类型</strong>字段，大致可以分为两大类：</p><ul><li>一类用于诊断的查询信息，也就是<strong>「查询报文类型」</strong>。</li><li>另一类是通知出错原因的错误信息，也就是<strong>「差错报文类型」</strong>。</li></ul><p><img src="/2022/01/23/Ping%E7%9A%84%E5%8E%9F%E7%90%86/3.png" alt="图片"></p><hr><h2 id="查询报文类型"><a href="#查询报文类型" class="headerlink" title="查询报文类型"></a>查询报文类型</h2><h3 id="回送消息-–-类型-0-和-8"><a href="#回送消息-–-类型-0-和-8" class="headerlink" title="回送消息 – 类型 0 和 8"></a>回送消息 – 类型 0 和 8</h3><p><strong>回送消息</strong>用于进行通信的主机或服务器之间，判断所发送的数据包是否已经成功到达对端的一种消息，<code>ping</code> 命令就是利用这个消息来实现的。</p><p><img src="/2022/01/23/Ping%E7%9A%84%E5%8E%9F%E7%90%86/4.png" alt="图片"></p><p>可以向对端主机发送<strong>回送请求</strong>的消息（<code>ICMP Echo Request Message</code>，类型 <code>8</code>），也可以接收对端主机发回来的<strong>回送应答</strong>消息（<code>ICMP Echo Reply Message</code>，类型 <code>0</code>）。</p><p><img src="/2022/01/23/Ping%E7%9A%84%E5%8E%9F%E7%90%86/5.png" alt="图片"></p><p>相比原生的 ICMP，这里多了两个字段：</p><ul><li><strong>标识符</strong>：用以区分是哪个应用程序发 ICMP 包，比如用进程 <code>PID</code> 作为标识符；</li><li><strong>序号</strong>：序列号从 <code>0</code> 开始，每发送一次新的回送请求就会加 <code>1</code>， 可以用来确认网络包是否有丢失。</li></ul><p>在<strong>选项数据</strong>中，<code>ping</code> 还会存放发送请求的时间值，来计算往返时间，说明路程的长短。</p><h2 id="差错报文类型"><a href="#差错报文类型" class="headerlink" title="差错报文类型"></a>差错报文类型</h2><p>接下来，说明几个常用的 ICMP 差错报文的例子：</p><ul><li>目标不可达 – 类型为 <code>3</code></li><li>原点抑制消息 – 类型为 <code>4</code></li><li>重定向消息 – 类型为 <code>5</code></li><li>超时消息 – 类型为 <code>11</code></li></ul><h3 id="目标不可达消息（Distination-Unreachable-Message）-–-类型为-3"><a href="#目标不可达消息（Distination-Unreachable-Message）-–-类型为-3" class="headerlink" title="目标不可达消息（Distination Unreachable Message） – 类型为 3"></a>目标不可达消息（Distination Unreachable Message） – 类型为 <code>3</code></h3><p>IP 路由器无法将 IP 数据包发送给目标地址时，会给发送端主机返回一个<strong>目标不可达</strong>的 ICMP 消息，并且这个消息中显示不可达的具体原因，原因记录在 ICMP 包头的<strong>代码</strong>字段。</p><p>由此，根据 ICMP 不可达的具体消息，发送端主机也就可以了解此次发送<strong>不可达的具体原因</strong>。</p><p>举例 6 中常见的目标不可达类型的代码：</p><p><img src="/2022/01/23/Ping%E7%9A%84%E5%8E%9F%E7%90%86/6-3469915.png" alt="图片"></p><ul><li>网络不可达代码为 <code>0</code></li><li>主机不可达代码为 <code>1</code></li><li>协议不可达代码为 <code>2</code></li><li>端口不可达代码为 <code>3</code></li><li>需要进行分片但设置了不分片位代码为 <code>4</code></li></ul><p>为了给大家说清楚上面的目标不可达的原因，<strong>小林牺牲自己给大家送 5 次外卖。</strong></p><h4 id="网络不可达代码为-0"><a href="#网络不可达代码为-0" class="headerlink" title="网络不可达代码为 0"></a>网络不可达代码为 0</h4><p><em>外卖版本：</em></p><p>小林第一次送外卖时，小区里只有 A 和 B 区两栋楼，但送餐地址写的是 C 区楼，小林表示头上很多问号，压根就没这个地方。</p><p><em>正常版本：</em></p><p>IP 地址是分为网络号和主机号的，所以当路由器中的路由器表匹配不到接收方 IP 的网络号，就通过 ICMP 协议以<strong>网络不可达</strong>（<code>Network Unreachable</code>）的原因告知主机。</p><p>自从不再有网络分类以后，网络不可达也渐渐不再使用了。</p><h4 id="主机不可达代码为-1"><a href="#主机不可达代码为-1" class="headerlink" title="主机不可达代码为 1"></a>主机不可达代码为 1</h4><p><em>外卖版本：</em></p><p>小林第二次送外卖时，这次小区有 5 层楼高的 C 区楼了，找到地方了，但送餐地址写的是 C 区楼 601 号房 ，说明找不到这个房间。</p><p><em>正常版本：</em></p><p>当路由表中没有该主机的信息，或者该主机没有连接到网络，那么会通过 ICMP 协议以<strong>主机不可达</strong>（<code>Host Unreachable</code>）的原因告知主机。</p><h4 id="协议不可达代码为-2"><a href="#协议不可达代码为-2" class="headerlink" title="协议不可达代码为 2"></a>协议不可达代码为 2</h4><p><em>外卖版本：</em></p><p>小林第三次送外卖时，这次小区有 C 区楼，也有 601 号房，找到地方了，也找到房间了，但是一开门人家是外国人说的是英语，我说的是中文！语言不通，外卖送达失败~</p><p><em>正常版本：</em></p><p>当主机使用 TCP 协议访问对端主机时，能找到对端的主机了，可是对端主机的防火墙已经禁止 TCP 协议访问，那么会通过 ICMP 协议以<strong>协议不可达</strong>的原因告知主机。</p><h4 id="端口不可达代码为-3"><a href="#端口不可达代码为-3" class="headerlink" title="端口不可达代码为 3"></a>端口不可达代码为 3</h4><p><em>外卖版本：</em></p><p>小林第四次送外卖时，这次小区有 C 区楼，也有 601 号房，找到地方了，也找到房间了，房间里的人也是说中文的人了，但是人家说他要的不是外卖，而是快递。。。</p><p><em>正常版本：</em></p><p>当主机访问对端主机 8080 端口时，这次能找到对端主机了，防火墙也没有限制，可是发现对端主机没有进程监听 8080 端口，那么会通过 ICMP 协议以<strong>端口不可达</strong>的原因告知主机。</p><h4 id="需要进行分片单设置了不分片代码为-4"><a href="#需要进行分片单设置了不分片代码为-4" class="headerlink" title="需要进行分片单设置了不分片代码为 4"></a>需要进行分片单设置了不分片代码为 4</h4><p><em>外卖版本：</em></p><p>小林第五次送外卖时，这次是个吃播博主了 100 份外卖，但是吃播博主要求一次性要把全部外卖送达，小林的一台电动车装不下呀，这样就没办法送达了。</p><p><em>正常版本：</em></p><p>发送端主机发送 IP 数据报时，将 IP 首部的<strong>分片禁止标志位</strong>设置为<code>1</code>。根据这个标志位，途中的路由器遇到超过 MTU 大小的数据包时，不会进行分片，而是直接抛弃。</p><p>随后，通过一个 ICMP 的不可达消息类型，<strong>代码为 4</strong> 的报文，告知发送端主机。</p><h3 id="原点抑制消息（ICMP-Source-Quench-Message）–-类型-4"><a href="#原点抑制消息（ICMP-Source-Quench-Message）–-类型-4" class="headerlink" title="原点抑制消息（ICMP Source Quench Message）– 类型 4"></a>原点抑制消息（ICMP Source Quench Message）– 类型 4</h3><p>在使用低速广域线路的情况下，连接 WAN 的路由器可能会遇到网络拥堵的情况。</p><p><code>ICMP</code> 原点抑制消息的目的就是<strong>为了缓和这种拥堵情况</strong>。</p><p>当路由器向低速线路发送数据时，其发送队列的缓存变为零而无法发送出去时，可以向 IP 包的源地址发送一个 ICMP <strong>原点抑制消息</strong>。</p><p>收到这个消息的主机借此了解在整个线路的某一处发生了拥堵的情况，从而增大 IP 包的传输间隔，减少网络拥堵的情况。</p><p>然而，由于这种 ICMP 可能会引起不公平的网络通信，一般不被使用。</p><h3 id="重定向消息（ICMP-Redirect-Message）-–-类型-5"><a href="#重定向消息（ICMP-Redirect-Message）-–-类型-5" class="headerlink" title="重定向消息（ICMP Redirect Message） – 类型 5"></a>重定向消息（ICMP Redirect Message） – 类型 5</h3><p>如果路由器发现发送端主机使用了「不是最优」的路径发送数据，那么它会返回一个 ICMP <strong>重定向消息</strong>给这个主机。</p><p>在这个消息中包含了<strong>最合适的路由消息和源数据</strong>。这主要发生在路由器持有更好的路由通信的情况下。路由器会通过这样的 ICMP 消息告知发送端，让它下次发送给另外一个路由器。</p><p>好比，小林本可以过条马路就能到的地方，但小林不知道，所以绕了一圈才到，后面小林知道后，下次小林就不会那么<strong>傻</strong>再绕一圈了。</p><h3 id="超时消息（ICMP-Time-Exceeded-Message）–-类型-11"><a href="#超时消息（ICMP-Time-Exceeded-Message）–-类型-11" class="headerlink" title="超时消息（ICMP Time Exceeded Message）– 类型 11"></a>超时消息（ICMP Time Exceeded Message）– 类型 11</h3><p>IP 包中有一个字段叫做 <code>TTL</code>（<code>Time to Live</code>，生存周期），它的**值随着没经过一次路由器就会减 1，直到减到 0 时该 IP 包会被丢弃。</p><p>此时，IP 路由器将会发送一个 ICMP<strong>超时消息</strong>给发送端主机，并通知该包已被丢弃。</p><p>设置 IP 包生存周期的主要目的，是为了在路由控制遇到问题发生循环状态时，避免 IP包无休止地在网络上被转发。</p><p><img src="/2022/01/23/Ping%E7%9A%84%E5%8E%9F%E7%90%86/7-3469924.png" alt="图片"></p><p>此外，有时可以用 TTL 控制包的到达范围，例如设置<strong>一个较小的TTL值</strong>。</p><hr><h2 id="ping-–-查询报文类型的使用"><a href="#ping-–-查询报文类型的使用" class="headerlink" title="ping – 查询报文类型的使用"></a>ping – 查询报文类型的使用</h2><p>接下来，我们重点来看 <code>ping</code> 的发送和接收过程。</p><p>同个子网下的主机 A 和 主机 B，主机 A 执行 <code>ping</code> 主机 B 后，我们来看看其间发送了什么？</p><p><img src="/2022/01/23/Ping%E7%9A%84%E5%8E%9F%E7%90%86/8.png" alt="图片"></p><p>ping 命令执行的时候，源主机首先会构建一个 <strong>ICMP 回送请求消息</strong>数据包。</p><p>ICMP 数据包内包含多个字段，最重要的是两个：</p><ul><li>一个是<strong>类型</strong>，对于回送请求消息而言，该字段为 <code>8</code>。</li><li>另外一个是<strong>序号</strong>，主要用于区分连续 ping 的时候发出的多个数据包。</li></ul><p>每发出一个请求数据包，序号会自动加 1。为了能够计算往返时间 <code>RTT</code>，它会在报文的数据部分插入发送时间。</p><p><img src="/2022/01/23/Ping%E7%9A%84%E5%8E%9F%E7%90%86/9.png" alt="图片"></p><p>然后，由 ICMP 协议将这个数据包连同地址 192.168.1.2 一起交给 IP 层。IP 层将以 192.168.1.2 作为<strong>目的地址</strong>，本机 IP 地址作为<strong>源地址</strong>，<strong>协议</strong>字段设置为 <code>1</code> 表示是 <code>ICMP</code> 协议，在加上一些其他控制信息，构建一个 <code>IP</code> 数据包。</p><p><img src="/2022/01/23/Ping%E7%9A%84%E5%8E%9F%E7%90%86/10.png" alt="图片"></p><p>接下来，需要加入 <code>MAC</code> 头。如果在本地 ARP 映射表中查找出 IP 地址 192.168.1.2 所对应的 MAC 地址，则可以直接使用；如果没有，则需要发送 <code>ARP</code> 协议查询 MAC 地址，获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去。</p><p><img src="/2022/01/23/Ping%E7%9A%84%E5%8E%9F%E7%90%86/11.png" alt="图片"></p><p>主机 <code>B</code> 收到这个数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。</p><p>接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议。</p><p>主机 <code>B</code> 会构建一个 <strong>ICMP 回送响应消息</strong>数据包，回送响应数据包的<strong>类型</strong>字段为 <code>0</code>，<strong>序号</strong>为接收到的请求数据包中的序号，然后再发送出去给主机 A。</p><p><img src="/2022/01/23/Ping%E7%9A%84%E5%8E%9F%E7%90%86/12.png" alt="图片"></p><p>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 回送响应消息，则说明目标主机可达。</p><p>此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的时间延迟。</p><p>针对上面发生的事情，总结成了如下图：</p><p><img src="/2022/01/23/Ping%E7%9A%84%E5%8E%9F%E7%90%86/13.png" alt="图片"></p><p>当然这只是最简单的，同一个局域网里面的情况。如果跨网段的话，还会涉及网关的转发、路由器的转发等等。</p><p>但是对于 ICMP 的头来讲，是没什么影响的。会影响的是根据目标 IP 地址，选择路由的下一跳，还有每经过一个路由器到达一个新的局域网，需要换 MAC 头里面的 MAC 地址。</p><p>说了这么多，可以看出 ping 这个程序是<strong>使用了 ICMP 里面的 ECHO REQUEST（类型为 8 ） 和 ECHO REPLY （类型为 0）</strong>。</p><h2 id="traceroute-–-差错报文类型的使用"><a href="#traceroute-–-差错报文类型的使用" class="headerlink" title="traceroute – 差错报文类型的使用"></a>traceroute – 差错报文类型的使用</h2><p>又一款充分利用 ICMP <strong>差错报文类型</strong>的应用叫做 <code>traceroute</code>（在 UNIX、MACOS中是这个命令，而在 Windows 中对等的命令叫做 tracert）。</p><h3 id="1-traceroute-作用一"><a href="#1-traceroute-作用一" class="headerlink" title="1. traceroute 作用一"></a>1. traceroute 作用一</h3><p>traceroute 的第一个作用是<strong>故意设置特殊的 TTL，来追踪去往目的地时沿途经过的路由器</strong>。</p><p>traceroute 的参数指向某个<strong>目的 IP 地址</strong>：</p><p>traceroute 192.168.1.100</p><h4 id="这个作用是如何工作的呢？"><a href="#这个作用是如何工作的呢？" class="headerlink" title="这个作用是如何工作的呢？"></a>这个作用是如何工作的呢？</h4><p>它的原理就是利用 IP 包的<strong>生存期限</strong>，从 1 开始，按照顺序递增的同时发送 <strong>UDP包</strong>，强制接收 <strong>ICMP 超时信息</strong>的一种方法。</p><p>比如，将 TTL 设置为 1，则遇到第一个路由器，就牺牲了，就这返回 ICMP 差错报文网络包，类型是网络超时。</p><p>接下来将 TTL 设置为 <code>2</code>，第一个路由器过了，遇到第二个路由器也牺牲了，也同意返回了 ICMP 差错报文数据包，如此往复，直到到达目的主机。</p><p>这样的过程，traceroute 就可以拿到了所有的路由器 IP。</p><p>当然有的路由器根本就不会返回这个 ICMP，所以对于有的公网地址，是看不到中间经过的路由的。</p><hr><h5 id="发送方如何知道发出的-UDP-包是否到达了目的主机呢？"><a href="#发送方如何知道发出的-UDP-包是否到达了目的主机呢？" class="headerlink" title="发送方如何知道发出的 UDP 包是否到达了目的主机呢？"></a>发送方如何知道发出的 UDP 包是否到达了目的主机呢？</h5><p>traceroute 在发送 <code>UDP</code> 包时，会填入一个<strong>不可能的端口号</strong>值作为 UDP 目标端口号（大于 <code>3000</code>）。当目的主机，收到 UDP 包后，会返回 ICMP 差错报文信息，但这个差错报文消息的类型是<strong>「端口不可达」</strong>。</p><p>当然有的路由器根本就不会返回这个 ICMP，所以对于有的公网地址，是看不到中间经过的路由的。</p><p>所以，<strong>当差错报文类型是端口不可达时，说明发送方发出的 UDP 包到达了目的主机。</strong></p><hr><h3 id="2-traceroute-作用二"><a href="#2-traceroute-作用二" class="headerlink" title="2. traceroute 作用二"></a>2. traceroute 作用二</h3><p>traceroute 还有一个作用是<strong>故意设置不分片，从而确定路径的 MTU</strong>。</p><p>这样做的目的是为了<strong>路径MTU发现</strong>。</p><p>因为有时候，我们并不知道路由器 <code>MTU</code> 大小，以太网的数据链路上的 <code>MTU</code> 通常是 <code>1500</code> 字节，但是非以太网 的 <code>MTU</code> 就不太一样了，所以我们要知道 <code>MTU</code> 的大小，从而控制发送的包的大小。</p><p><img src="/2022/01/23/Ping%E7%9A%84%E5%8E%9F%E7%90%86/14.png" alt="图片"></p><p>它的工作原理如下：</p><p>首先在发送端主机发送 <code>IP</code> 数据报时，将 <code>IP</code> 包首部的<strong>分片禁止标志位设置为 1</strong>。根据这个标志位，途中的路由器不会对大数据包进行分片，而是将包丢弃。</p><p>随后，通过一个 ICMP 的不可达消息将<strong>数据链路上 MTU 的值</strong>一起给发送主机，不可达消息的类型为「<strong>需要进行分片但设置了不分片位</strong>」。</p><p>发送主机端每次收到 ICMP 差错报文时就<strong>减少</strong>包的大小，以此来定位一个合适的 <code>MTU</code>值，以便能到达目标主机。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
      <category>ICMP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HashMap源码分析</title>
    <link href="/2022/01/23/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2022/01/23/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap-源码分析（JDK-1-8）"><a href="#HashMap-源码分析（JDK-1-8）" class="headerlink" title="HashMap 源码分析（JDK 1.8）"></a>HashMap 源码分析（JDK 1.8）</h1><p>HashMap在Java学习中是越不过去的一道弯，HashMap虽然用着简单，但是其中的原理却很复杂。搞清楚弄明白之后，能够很大的提升个人能力。</p><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>HashMap 最早出现在 JDK 1.2中，底层基于散列算法实现。HashMap 允许 null 键和 null 值，在计算哈键的哈希值时，null 键哈希值为 0。</p><p>HashMap 并不保证键值对的顺序，这意味着在进行某些操作后，键值对的顺序可能会发生变化。另外，需要注意的是，HashMap 是非线程安全类，在多线程环境下可能会存在问题。</p><p>在本篇文章中，我将会对 HashMap 中常用方法、重要属性及相关方法进行分析。需要说明的是，HashMap 源码中可分析的点很多，本文很难一一覆盖，请见谅。</p><hr><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2. 原理"></a>2. 原理</h2><p>上一节说到 HashMap 底层是基于散列算法实现，散列算法分为散列再探测和拉链式。HashMap 则使用了拉链式的散列算法，并在 JDK 1.8 中引入了红黑树优化过长的链表。数据结构示意图如下：</p><p><img src="/2022/01/23/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png" alt="img"></p><p>对于拉链式的散列算法，其数据结构是由数组和链表（或树形结构）组成。在进行增删查等操作时，首先要定位到元素的所在桶的位置，之后再从链表中定位该元素。比如我们要查询上图结构中是否包含元素<code>35</code>，步骤如下：</p><ol><li>定位元素<code>35</code>所处桶的位置，<code>index = 35 % 16 = 3</code></li><li>在<code>3</code>号桶所指向的链表中继续查找，发现35在链表中。</li></ol><p>上面就是 HashMap 底层数据结构的原理，HashMap 基本操作就是对拉链式散列算法基本操作的一层包装。不同的地方在于 JDK 1.8 中引入了红黑树，底层数据结构由<code>数组+链表</code>变为了<code>数组+链表+红黑树</code>，不过本质并未变。好了，原理部分先讲到这，接下来说说源码实现。</p><hr><h2 id="3-源码实现"><a href="#3-源码实现" class="headerlink" title="3. 源码实现"></a>3. 源码实现</h2><p>本篇文章所分析的源码版本为 JDK 1.8。与 JDK 1.7 相比，JDK 1.8 对 HashMap 进行了一些优化。比如引入红黑树解决过长链表效率低的问题。重写 resize 方法，移除了 alternative hashing 相关方法，避免重新计算键的 hash 等。不过本篇文章并不打算对这些优化进行分析，本文仅会分析 HashMap 常用的方法及一些重要属性和相关方法。</p><h3 id="3-1-构造方法"><a href="#3-1-构造方法" class="headerlink" title="3.1 构造方法"></a>3.1 构造方法</h3><h4 id="3-1-1-构造方法分析"><a href="#3-1-1-构造方法分析" class="headerlink" title="3.1.1 构造方法分析"></a>3.1.1 构造方法分析</h4><p>HashMap 的构造方法不多，只有四个。HashMap 构造方法做的事情比较简单，一般都是初始化一些重要变量，比如 loadFactor 和 threshold。而底层的数据结构则是延迟到插入键值对时再进行初始化。HashMap 相关构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 构造方法 1 */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all other fields defaulted</span><br>&#125;<br><br><span class="hljs-comment">/** 构造方法 2 */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br><br><span class="hljs-comment">/** 构造方法 3 */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                           initialCapacity);<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                           loadFactor);<br>    <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br><br><span class="hljs-comment">/** 构造方法 4 */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>    putMapEntries(m, <span class="hljs-keyword">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面4个构造方法中，大家平时用的最多的应该是第一个了。第一个构造方法很简单，仅将 loadFactor 变量设为默认值。构造方法2调用了构造方法3，而构造方法3仍然只是设置了一些变量。构造方法4则是将另一个 Map 中的映射拷贝一份到自己的存储结构中来，这个方法不是很常用。</p><p>上面就是对构造方法简单的介绍，构造方法本身并没什么太多东西，所以就不说了。接下来说说构造方法所初始化的几个的变量。</p><h4 id="3-1-3-初始容量、负载因子、阈值"><a href="#3-1-3-初始容量、负载因子、阈值" class="headerlink" title="3.1.3 初始容量、负载因子、阈值"></a>3.1.3 初始容量、负载因子、阈值</h4><p>我们在一般情况下，都会使用无参构造方法创建 HashMap。但当我们对时间和空间复杂度有要求的时候，使用默认值有时可能达不到我们的要求，这个时候我们就需要手动调参。在 HashMap 构造方法中，可供我们调整的参数有两个，一个是初始容量 initialCapacity，另一个负载因子 loadFactor。通过这两个设定这两个参数，可以进一步影响阈值大小。但初始阈值 threshold 仅由 initialCapacity 经过移位操作计算得出。他们的作用分别如下：</p><table><thead><tr><th>名称</th><th>用途</th></tr></thead><tbody><tr><td>initialCapacity</td><td>HashMap 初始容量</td></tr><tr><td>loadFactor</td><td>负载因子</td></tr><tr><td>threshold</td><td>当前 HashMap 所能容纳键值对数量的最大值，超过这个值，则需扩容</td></tr></tbody></table><p>相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** The default initial capacity - MUST be a power of two. */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">/** The load factor used when none specified in constructor. */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;<br><br><span class="hljs-comment">/** The next size value at which to resize (capacity * load factor). */</span><br><span class="hljs-keyword">int</span> threshold;<br></code></pre></td></tr></table></figure><p>如果大家去看源码，会发现 HashMap 中没有定义 initalCapacity 这个变量。这个也不难理解，从参数名上可以看出，这个变量表示一个初始变量，只是在构造方法中用一次，没必要定一个变量保存。</p><p>但如果仔细看上面 HashMap 的构造方法，会发现存储键值对的数据结构并不是在构造方法中初始化的。这就有一个疑问了，既然叫做初始容量，但最终并没有用于初始化数据结构，那这个参数还有什么用呢？后面会说明。</p><p>默认情况下，HashMap 初始容量是16，负载因子为 0.75。这里并没有默认阈值，原因是阈值可由容量乘上负载因子计算而来（注释中有说明），即<code>threshold = capacity * loadFactor</code>。</p><p>但当你仔细看构造方法3时，会发现阈值并不是由上面公式计算而来，而是通过一个方法算出来的。这是不是可以说明 threshold 变量的注释有误呢？还是仅这里进行了特殊处理，其他地方遵循计算公式呢？关于这个疑问，这里也先不说明，后面在分析扩容方法时，再来解释这个问题。接下来，我们来看看初始化 threshold 的方法长什么样的的，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns a power of two size for the given target capacity.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码长的有点不太好看，反正我第一次看的时候不明白它想干啥。不过后来在纸上画画，知道了它的用途。</p><p>总结起来就一句话：找到大于或等于 cap 的最小2的幂。至于为啥要这样，后面再解释。我们先来看看 tableSizeFor 方法的图解：</p><p><img src="/2022/01/23/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2.png" alt="img"></p><p>上面是 tableSizeFor 方法的计算过程图，这里 cap = 536,870,913 = 2<sup>29</sup> + 1<code>，多次计算后，算出</code>n + 1 = 1,073,741,824 = 2<sup>30 </sup>。通过图解应该可以比较容易理解这个方法的用途，这里就不多说了。</p><p>说完了初始阈值的计算过程，再来说说负载因子（loadFactor）。对于 HashMap 来说，负载因子是一个很重要的参数，该参数反应了 HashMap 桶数组的使用情况（假设键值对节点均匀分布在桶数组中）。</p><p>通过调节负载因子，可使 HashMap 时间和空间复杂度上有不同的表现。当我们调低负载因子时，HashMap 所能容纳的键值对数量变少。扩容时，重新将键值对存储新的桶数组里，键与键之间产生的碰撞会下降，链表长度变短。此时，HashMap 的增删改查等操作的效率将会变高，这里是典型的拿空间换时间。</p><p>相反，如果增加负载因子（负载因子可以大于1），HashMap 所能容纳的键值对数量变多，空间利用率高，但碰撞率也高。这意味着链表长度变长，效率也随之降低，这种情况是拿时间换空间。至于负载因子怎么调节，这个看使用场景了。一般情况下，我们用默认值就可以了。</p><h3 id="3-2-查找"><a href="#3-2-查找" class="headerlink" title="3.2 查找"></a>3.2 查找</h3><p>HashMap 的查找操作比较简单，查找步骤与原理篇介绍一致，即先定位键值对所在的桶的位置，然后再对链表或红黑树进行查找。通过这两步即可完成查找，该操作相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(hash(key), key)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">getNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-keyword">int</span> n; K k;<br>    <span class="hljs-comment">// 1. 定位键值对所在桶的位置</span><br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = first.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            <span class="hljs-keyword">return</span> first;<br>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 2. 如果 first 是 TreeNode 类型，则调用黑红树查找方法</span><br>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>                <br>            <span class="hljs-comment">// 2. 对链表进行查找</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>查找的核心逻辑是封装在 getNode 方法中的，getNode 方法源码我已经写了一些注释，应该不难看懂。我们先来看看查找过程的第一步 - 确定桶位置，其实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// index = (n - 1) &amp; hash</span><br>first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]<br></code></pre></td></tr></table></figure><p>这里通过<code>(n - 1)&amp; hash</code>即可算出桶的在桶数组中的位置，可能有的朋友不太明白这里为什么这么做，这里简单解释一下。HashMap 中桶数组的大小 length 总是2的幂，此时，<code>(n - 1) &amp; hash</code> 等价于对 length 取余。但取余的计算效率没有位运算高，所以<code>(n - 1) &amp; hash</code>也是一个小的优化。举个例子说明一下吧，假设 hash = 185，n = 16。计算过程示意图如下：</p><p><img src="/2022/01/23/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/3.png" alt="img"></p><p>上面的计算并不复杂，这里就不多说了。</p><p>在上面源码中，除了查找相关逻辑，还有一个计算 hash 的方法。这个方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 计算键的 hash 值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>看这个方法的逻辑好像是通过位运算重新计算 hash，那么这里为什么要这样做呢？为什么不直接用键的 hashCode 方法产生的 hash 呢？大家先可以思考一下，我把答案写在下面。</p><p>这样做有两个好处，我来简单解释一下。我们再看一下上面求余的计算图，图中的 hash 是由键的 hashCode 产生。计算余数时，由于 n 比较小，hash 只有低4位参与了计算，高位的计算可以认为是无效的。这样导致了计算结果只与低位信息有关，高位数据没发挥作用。为了处理这个缺陷，我们可以上图中的 hash 高4位数据与低4位数据进行异或运算，即 <code>hash ^ (hash &gt;&gt;&gt; 4)</code>。通过这种方式，让高位数据与低位数据进行异或，以此加大低位信息的随机性，变相的让高位数据参与到计算中。此时的计算过程如下：</p><p><img src="/2022/01/23/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/4.png" alt="img"></p><p>在 Java 中，hashCode 方法产生的 hash 是 int 类型，32 位宽。前16位为高位，后16位为低位，所以要右移16位。</p><p>上面所说的是重新计算 hash 的一个好处，除此之外，重新计算 hash 的另一个好处是可以增加 hash 的复杂度。当我们覆写 hashCode 方法时，可能会写出分布性不佳的 hashCode 方法，进而导致 hash 的冲突率比较高。通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性。这也就是为什么 HashMap 不直接使用键对象原始 hash 的原因了。</p><h3 id="3-3-遍历"><a href="#3-3-遍历" class="headerlink" title="3.3 遍历"></a>3.3 遍历</h3><p>和查找查找一样，遍历操作也是大家使用频率比较高的一个操作。对于 遍历 HashMap，我们一般都会用下面的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(Object key : map.keySet()) &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(HashMap.Entry entry : map.entrySet()) &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从上面代码片段中可以看出，大家一般都是对 HashMap 的 key 集合或 Entry 集合进行遍历。上面代码片段中用 foreach 遍历 keySet 方法产生的集合，在编译时会转换成用迭代器遍历，等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Set keys = map.keySet();<br>Iterator ite = keys.iterator();<br><span class="hljs-keyword">while</span> (ite.hasNext()) &#123;<br>    Object key = ite.next();<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>大家在遍历 HashMap 的过程中会发现，多次对 HashMap 进行遍历时，遍历结果顺序都是一致的。但这个顺序和插入的顺序一般都是不一致的。产生上述行为的原因是怎样的呢？大家想一下原因。我先把遍历相关的代码贴出来，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;K&gt; <span class="hljs-title">keySet</span><span class="hljs-params">()</span> </span>&#123;<br>    Set&lt;K&gt; ks = keySet;<br>    <span class="hljs-keyword">if</span> (ks == <span class="hljs-keyword">null</span>) &#123;<br>        ks = <span class="hljs-keyword">new</span> KeySet();<br>        keySet = ks;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ks;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 键集合</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">K</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span>                 </span>&#123; <span class="hljs-keyword">return</span> size; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span>               </span>&#123; HashMap.<span class="hljs-keyword">this</span>.clear(); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Iterator&lt;K&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span>     </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> KeyIterator(); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123; <span class="hljs-keyword">return</span> containsKey(o); &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>) != <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 省略部分代码</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 键迭代器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeyIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HashIterator</span> </span><br><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">K</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> nextNode().key; &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashIterator</span> </span>&#123;<br>    Node&lt;K,V&gt; next;        <span class="hljs-comment">// next entry to return</span><br>    Node&lt;K,V&gt; current;     <span class="hljs-comment">// current entry</span><br>    <span class="hljs-keyword">int</span> expectedModCount;  <span class="hljs-comment">// for fast-fail</span><br>    <span class="hljs-keyword">int</span> index;             <span class="hljs-comment">// current slot</span><br><br>    HashIterator() &#123;<br>        expectedModCount = modCount;<br>        Node&lt;K,V&gt;[] t = table;<br>        current = next = <span class="hljs-keyword">null</span>;<br>        index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; size &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// advance to first entry </span><br>            <span class="hljs-comment">// 寻找第一个包含链表节点引用的桶</span><br>            <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> next != <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">nextNode</span><span class="hljs-params">()</span> </span>&#123;<br>        Node&lt;K,V&gt;[] t;<br>        Node&lt;K,V&gt; e = next;<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>        <span class="hljs-keyword">if</span> ((next = (current = e).next) == <span class="hljs-keyword">null</span> &amp;&amp; (t = table) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 寻找下一个包含链表节点引用的桶</span><br>            <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="hljs-keyword">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br>    <span class="hljs-comment">//省略部分代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如上面的源码，遍历所有的键时，首先要获取键集合<code>KeySet</code>对象，然后再通过 KeySet 的迭代器<code>KeyIterator</code>进行遍历。</p><p>KeyIterator 类继承自<code>HashIterator</code>类，核心逻辑也封装在 HashIterator 类中。HashIterator 的逻辑并不复杂，在初始化时，HashIterator 先从桶数组中找到包含链表节点引用的桶。然后对这个桶指向的链表进行遍历。</p><p>遍历完成后，再继续寻找下一个包含链表节点引用的桶，找到继续遍历。找不到，则结束遍历。举个例子，假设我们遍历下图的结构：</p><p><img src="/2022/01/23/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/5.png" alt="img"></p><p>HashIterator 在初始化时，会先遍历桶数组，找到包含链表节点引用的桶，对应图中就是3号桶。随后由 nextNode 方法遍历该桶所指向的链表。遍历完3号桶后，nextNode 方法继续寻找下一个不为空的桶，对应图中的7号桶。之后流程和上面类似，直至遍历完最后一个桶。以上就是 HashIterator 的核心逻辑的流程，对应下图：</p><p><img src="/2022/01/23/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/6.png" alt="img"></p><p>遍历上图的最终结果是 <code>19 -&gt; 3 -&gt; 35 -&gt; 7 -&gt; 11 -&gt; 43 -&gt; 59</code>，已经验证为正确。</p><h3 id="3-4-插入"><a href="#3-4-插入" class="headerlink" title="3.4 插入"></a>3.4 插入</h3><h4 id="3-4-1-插入逻辑分析"><a href="#3-4-1-插入逻辑分析" class="headerlink" title="3.4.1 插入逻辑分析"></a>3.4.1 插入逻辑分析</h4><p>通过前两节的分析，已经 HashMap 底层的数据结构应该了然于心了。对于插入的逻辑已经呼之欲出了。</p><p>首先要定位要插入的键值对属于那个桶，定位到桶后，再判断桶是否为空。如果为空则将键值对存入即可，如果不为空，则需要将键值对接在链表最后一个位置，或者更新键值对。</p><p>这就是简易的插入逻辑。</p><p>真正的插入流程要复杂不少。首先 HashMap 是变长集合，所以需要考虑扩容的问题。其次，在 JDK 1.8 中，HashMap 引入了红黑树优化过长链表，这里还要考虑多长的链表需要进行优化，优化过程又是怎样的问题。</p><p>接下来，先来看一下插入操作的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, i;<br>    <span class="hljs-comment">// 初始化桶数组 table，table 被延迟到插入新数据时再进行初始化</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)<br>        n = (tab = resize()).length;<br>    <span class="hljs-comment">// 如果桶中不包含键值对节点引用，则将新键值对节点的引用存入桶中即可</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)<br>        tab[i] = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">// 如果键的值以及节点 hash 等于链表中的第一个键值对节点时，则将 e 指向该键值对</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            e = p;<br>            <br>        <span class="hljs-comment">// 如果桶中的引用类型为 TreeNode，则调用红黑树的插入方法</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)  <br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, key, value);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 对链表进行遍历，并统计链表长度</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 链表中不包含要插入的键值对节点时，则将该节点接在链表的最后</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;<br>                    p.next = newNode(hash, key, value, <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">// 如果链表长度大于或等于树化阈值，则进行树化操作</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(tab, hash);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <br>                <span class="hljs-comment">// 条件为 true，表示当前链表包含要插入的键值对，终止遍历</span><br>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>                    <span class="hljs-keyword">break</span>;<br>                p = e;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 判断要插入的键值对是否存在 HashMap 中</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span><br>            V oldValue = e.value;<br>            <span class="hljs-comment">// onlyIfAbsent 表示是否仅在 oldValue 为 null 的情况下更新键值对的值</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)<br>                e.value = value;<br>            afterNodeAccess(e);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    ++modCount;<br>    <span class="hljs-comment">// 键值对数量超过阈值时，则进行扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        resize();<br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入操作的入口方法是 <code>put(K,V)</code>，但核心逻辑在<code>V putVal(int, K, V, boolean, boolean)</code> 方法中。putVal 方法主要做了这么几件事情：</p><ol><li>当桶数组 table 为空时，通过扩容的方式初始化 table</li><li>查找要插入的键值对是否已经存在，存在的话根据条件判断是否用新值替换旧值</li><li>如果不存在，则将键值对链入链表中，并根据链表长度决定是否将链表转为红黑树</li><li>判断键值对数量是否大于阈值，大于的话则进行扩容操作</li></ol><p>以上就是 HashMap 插入的逻辑，并不是很复杂，这里就不多说了。接下来来分析一下扩容机制。</p><h4 id="3-4-2-扩容机制"><a href="#3-4-2-扩容机制" class="headerlink" title="3.4.2 扩容机制"></a>3.4.2 扩容机制</h4><p>在 Java 中，数组的长度是固定的，这意味着数组只能存储固定量的数据。但在开发的过程中，很多时候我们无法知道该建多大的数组合适。建小了不够用，建大了用不完，造成浪费。如果我们能实现一种变长的数组，并按需分配空间就好了。好在，我们不用自己实现变长数组，Java 集合框架已经实现了变长的数据结构。比如 ArrayList 和 HashMap。对于这类基于数组的变长数据结构，扩容是一个非常重要的操作。下面就来聊聊 HashMap 的扩容机制。</p><p>在详细分析之前，先来说一下扩容相关的背景知识：</p><p>在 HashMap 中，桶数组的长度均是2的幂，阈值大小为桶数组长度与负载因子的乘积。当 HashMap 中的键值对数量超过阈值时，进行扩容。</p><p>HashMap 的扩容机制与其他变长集合的套路不太一样，HashMap 按当前桶数组长度的2倍进行扩容，阈值也变为原来的2倍（如果计算过程中，阈值溢出归零，则按阈值公式重新计算）。扩容之后，要重新计算键值对的位置，并把它们移动到合适的位置上去。以上就是 HashMap 的扩容大致过程，接下来我们来看看具体的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    <span class="hljs-keyword">int</span> oldCap = (oldTab == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-keyword">int</span> oldThr = threshold;<br>    <span class="hljs-keyword">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 如果 table 不为空，表明已经初始化过了</span><br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 当 table 容量超过容量最大值，则不再扩容</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125; <br>        <span class="hljs-comment">// 按旧容量和阈值的2倍计算新容量和阈值的大小</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 初始化时，将 threshold 的值赋值给 newCap，</span><br><span class="hljs-comment">         * HashMap 使用 threshold 变量暂时保存 initialCapacity 参数的值</span><br><span class="hljs-comment">         */</span> <br>        newCap = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 调用无参构造方法时，桶数组容量为默认容量，</span><br><span class="hljs-comment">         * 阈值为默认容量与默认负载因子乘积</span><br><span class="hljs-comment">         */</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <br>    <span class="hljs-comment">// newThr 为 0 时，按阈值计算公式进行计算</span><br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">float</span> ft = (<span class="hljs-keyword">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-keyword">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <span class="hljs-comment">// 创建新的桶数组，桶数组的初始化也是在这里完成的</span><br>    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> Node[newCap];<br>    table = newTab;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 如果旧的桶数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-keyword">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-keyword">null</span>)<br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode)<br>                    <span class="hljs-comment">// 重新映射时，需要对红黑树进行拆分</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-keyword">this</span>, newTab, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                    Node&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-comment">// 遍历链表，并将链表节点按原顺序进行分组</span><br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-keyword">null</span>);<br>                    <span class="hljs-comment">// 将分组后的链表映射到新桶中</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>                        loTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-keyword">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的源码有点长，希望大家耐心看懂它的逻辑。上面的源码总共做了3件事，分别是：</p><ol><li>计算新桶数组的容量 newCap 和新阈值 newThr</li><li>根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的</li><li>将键值对节点重新映射到新的桶数组里。如果节点是 TreeNode 类型，则需要拆分红黑树。如果是普通节点，则节点按原顺序进行分组。</li></ol><p>上面列的三点中，创建新的桶数组就一行代码，不用说了。接下来，来说说第一点和第三点，先说说 newCap 和 newThr 计算过程。该计算过程对应 resize 源码的第一和第二个条件分支，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 第一个条件分支</span><br><span class="hljs-keyword">if</span> ( oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 嵌套条件分支</span><br>    <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;...&#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) &#123;...&#125;<br>&#125; <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) &#123;...&#125;<br><span class="hljs-keyword">else</span> &#123;...&#125;<br><br><span class="hljs-comment">// 第二个条件分支</span><br><span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;...&#125;<br></code></pre></td></tr></table></figure><p>通过这两个条件分支对不同情况进行判断，进而算出不同的容量值和阈值。它们所覆盖的情况如下：</p><p>分支一：</p><table><thead><tr><th>条件</th><th>覆盖情况</th><th>备注</th></tr></thead><tbody><tr><td>oldCap &gt; 0</td><td>桶数组 table 已经被初始化</td><td></td></tr><tr><td>oldThr &gt; 0</td><td>threshold &gt; 0，且桶数组未被初始化</td><td>调用 HashMap(int) 和 HashMap(int, float) 构造方法时会产生这种情况，此种情况下 newCap = oldThr，newThr 在第二个条件分支中算出</td></tr><tr><td>oldCap == 0 &amp;&amp; oldThr == 0</td><td>桶数组未被初始化，且 threshold 为 0</td><td>调用 HashMap() 构造方法会产生这种情况。</td></tr></tbody></table><p>这里把<code>oldThr &gt; 0</code>情况单独拿出来说一下。在这种情况下，会将 oldThr 赋值给 newCap，等价于<code>newCap = threshold = tableSizeFor(initialCapacity)</code>。我们在初始化时传入的 initialCapacity 参数经过 threshold 中转最终赋值给了 newCap。这也就解答了前面提的一个疑问：initialCapacity 参数没有被保存下来，那么它怎么参与桶数组的初始化过程的呢？</p><p>嵌套分支：</p><table><thead><tr><th>条件</th><th>覆盖情况</th><th>备注</th></tr></thead><tbody><tr><td>oldCap &gt;= 230</td><td>桶数组容量大于或等于最大桶容量 230</td><td>这种情况下不再扩容</td></tr><tr><td>newCap &lt; 230 &amp;&amp; oldCap &gt; 16</td><td>新桶数组容量小于最大值，且旧桶数组容量大于 16</td><td>该种情况下新阈值 newThr = oldThr &lt;&lt; 1，移位可能会导致溢出</td></tr></tbody></table><p>这里简单说明一下移位导致的溢出情况，当 loadFactor小数位为 0，整数位可被2整除且大于等于8时，在某次计算中就可能会导致 newThr 溢出归零。见下图：</p><p><img src="/2022/01/23/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/7.png" alt="img"></p><p>分支二：</p><table><thead><tr><th>条件</th><th>覆盖情况</th><th>备注</th></tr></thead><tbody><tr><td>newThr == 0</td><td>第一个条件分支未计算 newThr 或嵌套分支在计算过程中导致 newThr 溢出归零</td><td></td></tr></tbody></table><p>说完 newCap 和 newThr 的计算过程，接下来再来分析一下键值对节点重新映射的过程。</p><p>在 JDK 1.8 中，重新映射节点需要考虑节点类型。对于树形节点，需先拆分红黑树再映射。对于链表类型节点，则需先对链表进行分组，然后再映射。需要的注意的是，分组后，组内节点相对位置保持不变。关于红黑树拆分的逻辑将会放在下一小节说明，先来看看链表是怎样进行分组映射的。</p><p>我们都知道往底层数据结构中插入节点时，一般都是先通过模运算计算桶位置，接着把节点放入桶中即可。事实上，我们可以把重新映射看做插入操作。在 JDK 1.7 中，也确实是这样做的。但在 JDK 1.8 中，则对这个过程进行了一定的优化，逻辑上要稍微复杂一些。在详细分析前，我们先来回顾一下 hash 求余的过程：</p><p><img src="/2022/01/23/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/8.png" alt="img"></p><p>上图中，桶数组大小 n = 16，hash1 与 hash2 不相等。但因为只有后4位参与求余，所以结果相等。当桶数组扩容后，n 由16变成了32，对上面的 hash 值重新进行映射：</p><p><img src="/2022/01/23/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/9.png" alt="img"></p><p>扩容后，参与模运算的位数由4位变为了5位。由于两个 hash 第5位的值是不一样，所以两个 hash 算出的结果也不一样。上面的计算过程并不难理解，继续往下分析。</p><p><img src="/2022/01/23/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/10.png" alt="img"></p><p>假设我们上图的桶数组进行扩容，扩容后容量 n = 16，重新映射过程如下:</p><p>依次遍历链表，并计算节点 <code>hash &amp; oldCap</code> 的值。如下图所示</p><p><img src="/2022/01/23/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/11.png" alt="img"></p><p>如果值为0，将 loHead 和 loTail 指向这个节点。如果后面还有节点 hash &amp; oldCap 为0的话，则将节点链入 loHead 指向的链表中，并将 loTail 指向该节点。如果值为非0的话，则让 hiHead 和 hiTail 指向该节点。完成遍历后，可能会得到两条链表，此时就完成了链表分组：</p><p><img src="/2022/01/23/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/12.png" alt="img"></p><p>最后再将这两条链接存放到相应的桶中，完成扩容。如下图：</p><p><img src="/2022/01/23/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/13.png" alt="img"></p><p>从上图可以发现，重新映射后，两条链表中的节点顺序并未发生变化，还是保持了扩容前的顺序。以上就是 JDK 1.8 中 HashMap 扩容的代码讲解。</p><p>另外再补充一下，JDK 1.8 版本下 HashMap 扩容效率要高于之前版本。如果大家看过 JDK 1.7 的源码会发现，JDK 1.7 为了防止因 hash 碰撞引发的拒绝服务攻击，在计算 hash 过程中引入随机种子。以增强 hash 的随机性，使得键值对均匀分布在桶数组中。在扩容过程中，相关方法会根据容量判断是否需要生成新的随机种子，并重新计算所有节点的 hash。而在 JDK 1.8 中，则通过引入红黑树替代了该种方式。从而避免了多次计算 hash 的操作，提高了扩容效率。</p><p>本小节的内容讲就先讲到这，接下来，来讲讲链表与红黑树相互转换的过程。</p><h4 id="3-4-3-链表树化，红黑树链化与拆分"><a href="#3-4-3-链表树化，红黑树链化与拆分" class="headerlink" title="3.4.3 链表树化，红黑树链化与拆分"></a>3.4.3 链表树化，红黑树链化与拆分</h4><p>JDK 1.8 对 HashMap 实现进行了改进。最大的改进莫过于在引入了红黑树处理频繁的碰撞，代码复杂度也随之上升。</p><p>比如，以前只需实现一套针对链表操作的方法即可。而引入红黑树后，需要另外实现红黑树相关的操作。红黑树是一种自平衡的二叉查找树，本身就比较复杂。</p><p>在展开说明之前，先把树化的相关代码贴出来，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当桶数组容量小于该值时，优先进行扩容，而不是树化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    TreeNode&lt;K,V&gt; parent;  <span class="hljs-comment">// red-black tree links</span><br>    TreeNode&lt;K,V&gt; left;<br>    TreeNode&lt;K,V&gt; right;<br>    TreeNode&lt;K,V&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>    <span class="hljs-keyword">boolean</span> red;<br>    TreeNode(<span class="hljs-keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;<br>        <span class="hljs-keyword">super</span>(hash, key, val, next);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将普通节点链表转换成树形节点链表</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> hash)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n, index; Node&lt;K,V&gt; e;<br>    <span class="hljs-comment">// 桶数组容量小于 MIN_TREEIFY_CAPACITY，优先进行扩容而不是树化</span><br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        resize();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// hd 为头节点（head），tl 为尾节点（tail）</span><br>        TreeNode&lt;K,V&gt; hd = <span class="hljs-keyword">null</span>, tl = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 将普通节点替换成树形节点</span><br>            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">if</span> (tl == <span class="hljs-keyword">null</span>)<br>                hd = p;<br>            <span class="hljs-keyword">else</span> &#123;<br>                p.prev = tl;<br>                tl.next = p;<br>            &#125;<br>            tl = p;<br>        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);  <span class="hljs-comment">// 将普通链表转成由树形节点链表</span><br>        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-comment">// 将树形链表转换成红黑树</span><br>            hd.treeify(tab);<br>    &#125;<br>&#125;<br><br><span class="hljs-function">TreeNode&lt;K,V&gt; <span class="hljs-title">replacementTreeNode</span><span class="hljs-params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode&lt;&gt;(p.hash, p.key, p.value, next);<br>&#125;<br></code></pre></td></tr></table></figure><p>在扩容过程中，树化要满足两个条件：</p><ol><li>链表长度大于等于 TREEIFY_THRESHOLD</li><li>桶数组容量大于等于 MIN_TREEIFY_CAPACITY</li></ol><p>第一个条件比较好理解，这里就不说了。这里来说说加入第二个条件的原因，个人觉得原因如下：</p><p>当桶数组容量比较小时，键值对节点 hash 的碰撞率可能会比较高，进而导致链表长度较长。这个时候应该优先扩容，而不是立马树化。毕竟高碰撞率是因为桶数组容量较小引起的，这个是主因。容量小时，优先扩容可以避免一些列的不必要的树化过程。同时，桶容量较小时，扩容会比较频繁，扩容时需要拆分红黑树并重新映射。所以在桶容量比较小的情况下，将长链表转成红黑树是一件吃力不讨好的事。</p><p>回到上面的源码中，我们继续看一下 treeifyBin 方法。该方法主要的作用是将普通链表转成为由 TreeNode 型节点组成的链表，并在最后调用 treeify 是将该链表转为红黑树。TreeNode 继承自 Node 类，所以 TreeNode 仍然包含 next 引用，原链表的节点顺序最终通过 next 引用被保存下来。我们假设树化前，链表结构如下：</p><p><img src="/2022/01/23/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/14.png" alt="img"></p><p>HashMap 在设计之初，并没有考虑到以后会引入红黑树进行优化。所以并没有像 TreeMap 那样，要求键类实现 comparable 接口或提供相应的比较器。但由于树化过程需要比较两个键对象的大小，在键类没有实现 comparable 接口的情况下，怎么比较键与键之间的大小了就成了一个棘手的问题。为了解决这个问题，HashMap 是做了三步处理，确保可以比较出两个键的大小，如下：</p><ol><li>比较键与键之间 hash 的大小，如果 hash 相同，继续往下比较</li><li>检测键类是否实现了 Comparable 接口，如果实现调用 compareTo 方法进行比较</li><li>如果仍未比较出大小，就需要进行仲裁了，仲裁方法为 tieBreakOrder（大家自己看源码吧）</li></ol><p>tie break 是网球术语，可以理解为加时赛的意思，起这个名字还是挺有意思的。</p><p>通过上面三次比较，最终就可以比较出孰大孰小。比较出大小后就可以构造红黑树了，最终构造出的红黑树如下：</p><p><img src="/2022/01/23/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/15.png" alt="img"></p><p>橙色的箭头表示 TreeNode 的 next 引用。由于空间有限，prev 引用未画出。可以看出，链表转成红黑树后，原链表的顺序仍然会被引用仍被保留了（红黑树的根节点会被移动到链表的第一位），我们仍然可以按遍历链表的方式去遍历上面的红黑树。这样的结构为后面红黑树的切分以及红黑树转成链表做好了铺垫，我们继续往下分析。</p><h4 id="红黑树拆分"><a href="#红黑树拆分" class="headerlink" title="红黑树拆分"></a>红黑树拆分</h4><p>扩容后，普通节点需要重新映射，红黑树节点也不例外。按照一般的思路，我们可以先把红黑树转成链表，之后再重新映射链表即可。这种处理方式是大家比较容易想到的，但这样做会损失一定的效率。</p><p>不同于上面的处理方式，HashMap 实现的思路则是上好佳（上好佳请把广告费打给我）。如上节所说，在将普通链表转成红黑树时，HashMap 通过两个额外的引用 next 和 prev 保留了原链表的节点顺序。这样再对红黑树进行重新映射时，完全可以按照映射链表的方式进行。这样就避免了将红黑树转成链表后再进行映射，无形中提高了效率。</p><p>以上就是红黑树拆分的逻辑，下面看一下具体实现吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 红黑树转链表阈值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">split</span><span class="hljs-params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="hljs-keyword">int</span> index, <span class="hljs-keyword">int</span> bit)</span> </span>&#123;<br>    TreeNode&lt;K,V&gt; b = <span class="hljs-keyword">this</span>;<br>    <span class="hljs-comment">// Relink into lo and hi lists, preserving order</span><br>    TreeNode&lt;K,V&gt; loHead = <span class="hljs-keyword">null</span>, loTail = <span class="hljs-keyword">null</span>;<br>    TreeNode&lt;K,V&gt; hiHead = <span class="hljs-keyword">null</span>, hiTail = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> lc = <span class="hljs-number">0</span>, hc = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">     * 红黑树节点仍然保留了 next 引用，故仍可以按链表方式遍历红黑树。</span><br><span class="hljs-comment">     * 下面的循环是对红黑树节点进行分组，与上面类似</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="hljs-keyword">null</span>; e = next) &#123;<br>        next = (TreeNode&lt;K,V&gt;)e.next;<br>        e.next = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> ((e.hash &amp; bit) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((e.prev = loTail) == <span class="hljs-keyword">null</span>)<br>                loHead = e;<br>            <span class="hljs-keyword">else</span><br>                loTail.next = e;<br>            loTail = e;<br>            ++lc;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> ((e.prev = hiTail) == <span class="hljs-keyword">null</span>)<br>                hiHead = e;<br>            <span class="hljs-keyword">else</span><br>                hiTail.next = e;<br>            hiTail = e;<br>            ++hc;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (loHead != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 如果 loHead 不为空，且链表长度小于等于 6，则将红黑树转成链表</span><br>        <span class="hljs-keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)<br>            tab[index] = loHead.untreeify(map);<br>        <span class="hljs-keyword">else</span> &#123;<br>            tab[index] = loHead;<br>            <span class="hljs-comment">/* </span><br><span class="hljs-comment">             * hiHead == null 时，表明扩容后，</span><br><span class="hljs-comment">             * 所有节点仍在原位置，树结构不变，无需重新树化</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-keyword">null</span>) <br>                loHead.treeify(tab);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 与上面类似</span><br>    <span class="hljs-keyword">if</span> (hiHead != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)<br>            tab[index + bit] = hiHead.untreeify(map);<br>        <span class="hljs-keyword">else</span> &#123;<br>            tab[index + bit] = hiHead;<br>            <span class="hljs-keyword">if</span> (loHead != <span class="hljs-keyword">null</span>)<br>                hiHead.treeify(tab);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从源码上可以看得出，重新映射红黑树的逻辑和重新映射链表的逻辑基本一致。不同的地方在于，重新映射后，会将红黑树拆分成两条由 TreeNode 组成的链表。如果链表长度小于 UNTREEIFY_THRESHOLD，则将链表转换成普通链表。否则根据条件重新将 TreeNode 链表树化。举个例子说明一下，假设扩容后，重新映射上图的红黑树，映射结果如下：</p><p><img src="/2022/01/23/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/16.png" alt="img"></p><h4 id="红黑树链化"><a href="#红黑树链化" class="headerlink" title="红黑树链化"></a>红黑树链化</h4><p>前面说过，红黑树中仍然保留了原链表节点顺序。有了这个前提，再将红黑树转成链表就简单多了，仅需将 TreeNode 链表转成 Node 类型的链表即可。相关代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">untreeify</span><span class="hljs-params">(HashMap&lt;K,V&gt; map)</span> </span>&#123;<br>    Node&lt;K,V&gt; hd = <span class="hljs-keyword">null</span>, tl = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 遍历 TreeNode 链表，并用 Node 替换</span><br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; q = <span class="hljs-keyword">this</span>; q != <span class="hljs-keyword">null</span>; q = q.next) &#123;<br>        <span class="hljs-comment">// 替换节点类型</span><br>        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">if</span> (tl == <span class="hljs-keyword">null</span>)<br>            hd = p;<br>        <span class="hljs-keyword">else</span><br>            tl.next = p;<br>        tl = p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> hd;<br>&#125;<br><br><span class="hljs-function">Node&lt;K,V&gt; <span class="hljs-title">replacementNode</span><span class="hljs-params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node&lt;&gt;(p.hash, p.key, p.value, next);<br>&#125;<br></code></pre></td></tr></table></figure><p>并不复杂，不再赘述</p><h3 id="3-5-删除"><a href="#3-5-删除" class="headerlink" title="3.5 删除"></a>3.5 删除</h3><p>如果大家坚持看完了前面的内容，到本节就可以轻松一下。当然，前提是不去看红黑树的删除操作。不过红黑树并非本文讲解重点，本节中也不会介绍红黑树相关内容，所以大家不用担心。</p><p>HashMap 的删除操作并不复杂，仅需三个步骤即可完成。第一步是定位桶位置，第二步遍历链表并找到键值相等的节点，第三步删除节点。相关源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = removeNode(hash(key), key, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) == <span class="hljs-keyword">null</span> ?<br>        <span class="hljs-keyword">null</span> : e.value;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">final</span> Node&lt;K,V&gt; <span class="hljs-title">removeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, Object key, Object value,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-keyword">boolean</span> matchValue, <span class="hljs-keyword">boolean</span> movable)</span> </span>&#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-keyword">int</span> n, index;<br>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        <span class="hljs-comment">// 1. 定位桶位置</span><br>        (p = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;<br>        Node&lt;K,V&gt; node = <span class="hljs-keyword">null</span>, e; K k; V v;<br>        <span class="hljs-comment">// 如果键的值与链表第一个节点相等，则将 node 指向该节点</span><br>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k))))<br>            node = p;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = p.next) != <span class="hljs-keyword">null</span>) &#123;  <br>            <span class="hljs-comment">// 如果是 TreeNode 类型，调用红黑树的查找逻辑定位待删除节点</span><br>            <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)<br>                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 2. 遍历链表，找到待删除节点</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>                        ((k = e.key) == key ||<br>                         (key != <span class="hljs-keyword">null</span> &amp;&amp; key.equals(k)))) &#123;<br>                        node = e;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    p = e;<br>                &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 3. 删除节点，并修复链表或红黑树</span><br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||<br>                             (value != <span class="hljs-keyword">null</span> &amp;&amp; value.equals(v)))) &#123;<br>            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> TreeNode)<br>                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="hljs-keyword">this</span>, tab, movable);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node == p)<br>                tab[index] = node.next;<br>            <span class="hljs-keyword">else</span><br>                p.next = node.next;<br>            ++modCount;<br>            --size;<br>            afterNodeRemoval(node);<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除操作本身并不复杂，有了前面的基础，理解起来也就不难了，这里就不多说了。</p><h3 id="3-6-其他细节"><a href="#3-6-其他细节" class="headerlink" title="3.6 其他细节"></a>3.6 其他细节</h3><p>前面的内容分析了 HashMap 的常用操作及相关的源码，本节内容再补充一点其他方面的东西。</p><h4 id="被-transient-所修饰-table-变量"><a href="#被-transient-所修饰-table-变量" class="headerlink" title="被 transient 所修饰 table 变量"></a>被 transient 所修饰 table 变量</h4><p>如果大家细心阅读 HashMap 的源码，会发现桶数组 table 被申明为 transient。transient 表示易变的意思，在 Java 中，被该关键字修饰的变量不会被默认的序列化机制序列化。我们再回到源码中，考虑一个问题：桶数组 table 是 HashMap 底层重要的数据结构，不序列化的话，别人还怎么还原呢？</p><p>这里简单说明一下吧，HashMap 并没有使用默认的序列化机制，而是通过实现<code>readObject/writeObject</code>两个方法自定义了序列化的内容。这样做是有原因的，试问一句，HashMap 中存储的内容是什么？不用说，大家也知道是<code>键值对</code>。所以只要我们把键值对序列化了，我们就可以根据键值对数据重建 HashMap。有的朋友可能会想，序列化 table 不是可以一步到位，后面直接还原不就行了吗？这样一想，倒也是合理。但序列化 talbe 存在着两个问题：</p><ol><li>table 多数情况下是无法被存满的，序列化未使用的部分，浪费空间</li><li>同一个键值对在不同 JVM 下，所处的桶位置可能是不同的，在不同的 JVM 下反序列化 table 可能会发生错误。</li></ol><p>以上两个问题中，第一个问题比较好理解，第二个问题解释一下。HashMap 的<code>get/put/remove</code>等方法第一步就是根据 hash 找到键所在的桶位置，但如果键没有覆写 hashCode 方法，计算 hash 时最终调用 Object 中的 hashCode 方法。但 Object 中的 hashCode 方法是 native 型的，不同的 JVM 下，可能会有不同的实现，产生的 hash 可能也是不一样的。也就是说同一个键在不同平台下可能会产生不同的 hash，此时再对在同一个 table 继续操作，就会出现问题。</p><p>综上所述，大家应该能明白 HashMap 不序列化 table 的原因了。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java容器</tag>
      
      <tag>HashMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树</title>
    <link href="/2022/01/20/%E6%A0%91/"/>
    <url>/2022/01/20/%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。</p><p>一棵树具有以下特点：</p><span id="more"></span><ol><li>一棵树中的任意两个结点有且仅有唯一的一条路径连通。</li><li>一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。</li><li>一棵树不包含回路。</li></ol><p>下图就是一颗树，并且是一颗二叉树。</p><p><img src="/2022/01/20/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91-2.png" alt="二叉树"></p><p>如上图所示，通过上面这张图说明一下树中的常用概念：</p><ul><li><strong>节点</strong> ：树中的每个元素都可以统称为节点。</li><li><strong>根节点</strong> ：顶层节点或者说没有父节点的节点。上图中 A 节点就是根节点。</li><li><strong>父节点</strong> ：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的 B 节点是 D 节点、E 节点的父节点。</li><li><strong>子节点</strong> ：一个节点含有的子树的根节点称为该节点的子节点。上图中 D 节点、E 节点是 B 节点的子节点。</li><li><strong>兄弟节点</strong> ：具有相同父节点的节点互称为兄弟节点。上图中 D 节点、E 节点的共同父节点是 B 节点，故 D 和 E 为兄弟节点。</li><li><strong>叶子节点</strong> ：没有子节点的节点。上图中的 D、F、H、I 都是叶子节点。</li><li><strong>节点的高度</strong> ：该节点到叶子节点的最长路径所包含的边数。</li><li><strong>节点的深度</strong> ：根节点到该节点的路径所包含的边数</li><li><strong>节点的层数</strong> ：节点的深度+1。</li><li><strong>树的高度</strong> ：根节点的高度。</li></ul><blockquote><p>来源<a href="https://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height">What is the difference between tree depth and height? </a>。</p></blockquote><h2 id="二叉树的分类"><a href="#二叉树的分类" class="headerlink" title="二叉树的分类"></a>二叉树的分类</h2><p><strong>二叉树</strong>（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。</p><p><strong>二叉树</strong> 的分支通常被称作“<strong>左子树</strong>”或“<strong>右子树</strong>”。并且，<strong>二叉树</strong> 的分支具有左右次序，不能随意颠倒。</p><p><strong>二叉树</strong> 的第 i 层至多拥有 <code>2^(i-1)</code> 个节点，深度为 k 的二叉树至多总共有 <code>2^(k+1)-1</code> 个节点（满二叉树的情况），至少有 2^(k) 个节点。</p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 <strong>满二叉树</strong>。也就是说，如果一个二叉树的层数为 K，且结点总数是(2^k) -1 ，则它就是 <strong>满二叉树</strong>。如下图所示：</p><p><img src="/2022/01/20/%E6%A0%91/E2A444CE-F925-4A45-BC54-1E23FB1AD545.png" alt="满二叉树"></p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则这个二叉树就是 <strong>完全二叉树</strong> 。</p><p>大家可以想象为一棵树从根结点开始扩展，扩展完左子节点才能开始扩展右子节点，每扩展完一层，才能继续扩展下一层。如下图所示：</p><p><img src="/2022/01/20/%E6%A0%91/696031E0-B630-4741-A703-251B5C1F8763.png" alt="完全二叉树"></p><p>完全二叉树有一个很好的性质：<strong>父结点和子节点的序号有着对应关系。</strong></p><p>细心的小伙伴可能发现了，当根节点的值为 1 的情况下，若父结点的序号是 i，那么左子节点的序号就是 2i，右子节点的序号是 2i+1。这个性质使得完全二叉树利用数组存储时可以极大地节省空间，以及利用序号找到某个节点的父结点和子节点，后续二叉树的存储会详细介绍。</p><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p><strong>平衡二叉树</strong> 是一棵二叉排序树，且具有以下性质：</p><ol><li>可以是一棵空树</li><li>如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</li></ol><p>平衡二叉树的常用实现方法有 <strong>红黑树</strong>、<strong>AVL 树</strong>、<strong>替罪羊树</strong>、<strong>加权平衡树</strong>、<strong>伸展树</strong> 等。</p><p>在给大家展示平衡二叉树之前，先给大家看一棵树：</p><p><img src="/2022/01/20/%E6%A0%91/CD5DD8E3-C164-4569-A424-AD4638B8CA6E.png" alt="img"></p><p>这玩意也叫树，叫 <strong>斜树</strong>。</p><p><strong>如果这样，那我为啥不直接用链表呢?</strong></p><p>二叉树相比于链表，由于父子节点以及兄弟节点之间往往具有某种特殊的关系，这种关系使得我们在树中对数据进行<strong>搜索</strong>和<strong>修改</strong>时，相对于链表更加快捷便利。</p><p>但是，如果二叉树退化为一个链表了，那么那么树所具有的优秀性质就难以表现出来，效率也会大打折，为了避免这样的情况，我们希望每个做 “家长”（父结点） 的，都 <strong>一碗水端平</strong>，分给左儿子和分给右儿子的尽可能一样多，相差最多不超过一层，如下图所示：</p><p><img src="/2022/01/20/%E6%A0%91/9C234143-BB5B-45F6-ABF5-B83A82AA2F1D.png" alt="平衡二叉树"></p><h2 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h2><h3 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h3><p>和链表类似，二叉树的链式存储依靠指针将各个节点串联起来，不需要连续的存储空间。</p><p>每个节点包括三个属性：</p><ul><li>数据 data。data 不一定是单一的数据，根据不同情况，可以是多个具有不同类型的数据。</li><li>左节点指针 left</li><li>右节点指针 right。</li></ul><p><img src="/2022/01/20/%E6%A0%91/B1541EE4-9A73-4390-861F-1FFC4F03A289.png" alt="链式存储"></p><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>顺序存储就是利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成。根结点的序号为 1，对于每个节点 Node，假设它存储在数组中下标为 i 的位置，那么它的左子节点就存储在 2 _ i 的位置，它的右子节点存储在下标为 2 _ i+1 的位置。</p><p>一棵完全二叉树的数组顺序存储如下图所示：</p><p><img src="/2022/01/20/%E6%A0%91/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.ee466e82.png" alt="顺序存储"></p><p><strong>但是如果要存储的不是完全二叉树，数组就会出现空隙，导致存储效率的降低。</strong></p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><h3 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h3><p><img src="/2022/01/20/%E6%A0%91/E6F6ED8F-E2F7-43B2-A68C-3123E3ECD57F.png" alt="先序遍历"></p><p><strong>根 -》左 -》右</strong></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>system.out.println(root.data);<br>preOrder(root.left);<br>preOrder(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p><img src="/2022/01/20/%E6%A0%91/AB246471-58B6-4138-86F0-C326B2A8D6B6.png" alt="中序遍历"></p><p><strong>左 -》根 -》右</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>inOrder(root.left);<br>system.out.println(root.data);<br>inOrder(root.right);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p><img src="/2022/01/20/%E6%A0%91/33485BE8-BF35-4556-8B26-6046A33CE335.png" alt="后序遍历"></p><p><strong>左 -》右 -》根</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postOrder</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br><span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>postOrder(root.left);<br>postOrder(root.right);<br>system.out.println(root.data);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引</title>
    <link href="/2022/01/18/MySQL%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/01/18/MySQL%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL的索引"><a href="#MySQL的索引" class="headerlink" title="MySQL的索引"></a>MySQL的索引</h1><h2 id="什么是索引？有啥用？"><a href="#什么是索引？有啥用？" class="headerlink" title="什么是索引？有啥用？"></a>什么是索引？有啥用？</h2><span id="more"></span><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。</strong></p><p>索引的作用就相当于目录的作用。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p><h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>使用索引可以大大加快数据的检索速度（大大减少索引的数据量），这也是创建索引最主要的原因。</li><li>通过创建唯一索引，可以保证数据库中每一行数据的唯一性。</li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>创建和维护索引需要耗费很多时间。当对表中数据进行增删改的时候，如果数据有索引，那么索引也要动态的修改，会降低SQL的执行效率。</li><li>索引需要使用物理文件存储，也会耗费一定空间。</li></ul><h3 id="索引一定提高查询的性能吗？"><a href="#索引一定提高查询的性能吗？" class="headerlink" title="索引一定提高查询的性能吗？"></a>索引一定提高查询的性能吗？</h3><p>大多数情况下来看，索引查询都是比全表查询来的快的。但是如果数据量不大，那么使用索引也不一定能够带来很大的提升。</p><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="主键索引（Primary-Key）"><a href="#主键索引（Primary-Key）" class="headerlink" title="主键索引（Primary Key）"></a>主键索引（Primary Key）</h3><p>数据表的主键列使用的就是主键索引。</p><p>一张数据表只能有一个主键，并且主键不能为空，不能重复。</p><p>在 MySQL 的 InnoDB 的表中，当没有显示的制定表的主键时，InnoDB 会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p><hr><h3 id="二级索引（辅助索引）"><a href="#二级索引（辅助索引）" class="headerlink" title="二级索引（辅助索引）"></a>二级索引（辅助索引）</h3><p>二级索引又称辅助索引，是因为二级索引的叶子结点存储的数据时主键。也就是说，<strong>通过二级索引，可以定位主键的位置</strong>。</p><p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p><ol><li><strong>唯一索引（Unique Key）</strong>：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但允许数据为 NULL，一张表允许创建多个唯一索引</strong>。建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li><li><strong>普通索引（Index）</strong>：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</li><li><strong>前缀索引（Prefix）</strong>：前缀索引只适用于字符串类型的数据。前缀索引时对文本的前几个字符创建索引，相比普通索引建立的数据更小，因为只取前几个字符。</li><li><strong>全文索引（Full Text）</strong>：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库适用的一种技术。MySQL 5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li></ol><p><img src="/2022/01/18/MySQL%E7%B4%A2%E5%BC%95/1.png" alt="img"></p><hr><h2 id="聚集索引于非聚集索引"><a href="#聚集索引于非聚集索引" class="headerlink" title="聚集索引于非聚集索引"></a>聚集索引于非聚集索引</h2><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><h4 id="聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。"><a href="#聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。" class="headerlink" title="聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。"></a><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></h4><p>在 MySQL 中，InnoDB 引擎的表 <code>.ibd</code> 文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引（B+树）的每个非叶子结点存储索引，叶子结点存储索引和索引对应的数据。</p><hr><h4 id="聚集索引的优点："><a href="#聚集索引的优点：" class="headerlink" title="聚集索引的优点："></a><strong>聚集索引的优点：</strong></h4><p>聚集索引的查询数据非常的快，因为整个 B+ 树本身就是一颗多叉平衡树，叶子结点也都是有序的，定位到索引的节点，就相当于定位到了数据。</p><hr><h4 id="聚集索引的缺点："><a href="#聚集索引的缺点：" class="headerlink" title="聚集索引的缺点："></a><strong>聚集索引的缺点：</strong></h4><ol><li><strong>依赖于有序的数据</strong>：因为 B+ 树本身是多叉平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据时整形还好，如果类似于字符串或者 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong>：如果对索引列的数据修改时，那么对应的索引也会被修改，而且聚集索引的叶子结点还存放着数据，修改的代价肯定时较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li></ol><hr><h3 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h3><p><strong>非聚集索引即索引结构和数据分开存放的索引</strong>。</p><p><strong>二级索引属于非聚集索引</strong>。</p><blockquote><p>MyISAM 引擎的表的 .MYI 文件包含了表的索引，该表的索引（B+树）的每个叶子与非叶子结点存储索引，叶子结点存储索引和索引对应数据的指针，指向 .MYD 文件的数据。</p><p><strong>非聚集索引的叶子结点并不一定存放数据的指针，因为二级索引的叶子结点就存放的是主键，根据主键再回表查询数据</strong>。</p></blockquote><hr><h4 id="非聚集索引的优点"><a href="#非聚集索引的优点" class="headerlink" title="非聚集索引的优点"></a>非聚集索引的优点</h4><p><strong>更新代价比聚集索引要小</strong>。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子结点时不存放数据的。</p><hr><h4 id="非聚集索引的缺点"><a href="#非聚集索引的缺点" class="headerlink" title="非聚集索引的缺点"></a>非聚集索引的缺点</h4><ol><li>跟聚集索引一样，非聚集索引也依赖于有序的数据。</li><li><strong>可能二次查询（回表）</strong>：着应该是非聚集索引最大的缺点。当查询到索引对应的指针或主键后，可能还需要根据指针或主键再回到数据文件或表中查询。</li></ol><p>这时 MySQL 的表的文件截图：</p><img src="/2022/01/18/MySQL%E7%B4%A2%E5%BC%95/2.png" alt="img" style="zoom:200%;"><p>聚集索引和非聚集索引:</p><p><img src="/2022/01/18/MySQL%E7%B4%A2%E5%BC%95/3.png" alt="img"></p><h3 id="非聚集索引一定回表查询吗（覆盖索引）？"><a href="#非聚集索引一定回表查询吗（覆盖索引）？" class="headerlink" title="非聚集索引一定回表查询吗（覆盖索引）？"></a>非聚集索引一定回表查询吗（覆盖索引）？</h3><p><strong>非聚集索引不一定回表查询</strong>。</p><blockquote><p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;guang19&#x27;</span>;<br></code></pre></td></tr></table></figure><blockquote><p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就好了，无需回表查询。</p></blockquote><p><strong>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表， 因为它的主键索引的叶子节点存放的是指针。但是如果 SQL 查的就是主键呢?</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p><p>（但这样就没意义了～～）</p><hr><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。</p><p>我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p><p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。</strong></p><blockquote><p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p><p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p></blockquote><p>覆盖索引：</p><p><img src="/2022/01/18/MySQL%E7%B4%A2%E5%BC%95/4.png" alt="img"></p><hr><h2 id="创建索引的注意事项"><a href="#创建索引的注意事项" class="headerlink" title="创建索引的注意事项"></a>创建索引的注意事项</h2><h3 id="1-选择合适的字段创建索引："><a href="#1-选择合适的字段创建索引：" class="headerlink" title="1. 选择合适的字段创建索引："></a>1. 选择合适的字段创建索引：</h3><ul><li><strong>不为 NULL 的字段</strong>：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0，1，true，false 这样语义较为清晰的短值或短字符作为代替。</li><li><strong>被频繁查询的字段</strong>：我们创建索引的字段应该是被查询操作非常频繁的字段。</li><li><strong>作为条件查询的字段</strong>：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li><li><strong>频繁需要排序的字段</strong>：索引已被排序，这样查询可以利用索引的排序，加快排序查询时间。</li><li><strong>被经常频繁用于连接的字段</strong>：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li></ul><h3 id="2-被频繁更新的字段应该慎重建立索引"><a href="#2-被频繁更新的字段应该慎重建立索引" class="headerlink" title="2. 被频繁更新的字段应该慎重建立索引"></a>2. 被频繁更新的字段应该慎重建立索引</h3><p>虽然索引能带来查询上的效率，但是维护索引的成本也是不晓得。如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p><h3 id="3-尽可能的考虑建立联合索引而不是单列索引"><a href="#3-尽可能的考虑建立联合索引而不是单列索引" class="headerlink" title="3. 尽可能的考虑建立联合索引而不是单列索引"></a>3. 尽可能的考虑建立联合索引而不是单列索引</h3><p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+ 树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。</p><p>如果是联合索引，多个字段在一个索引上，那么将会节约很大的磁盘空间，且修改数据的操作效率也会提升。</p><h3 id="4-避免冗余索引"><a href="#4-避免冗余索引" class="headerlink" title="4. 避免冗余索引"></a>4. 避免冗余索引</h3><p>冗余索引指的是索引的功能相同，能够命中索引（a, b）就肯定能命中（a），那么索引（a）就是冗余索引。</p><p>如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p><h3 id="5-考虑在字符串类型的字段上使用前缀索引代替普通索引"><a href="#5-考虑在字符串类型的字段上使用前缀索引代替普通索引" class="headerlink" title="5. 考虑在字符串类型的字段上使用前缀索引代替普通索引"></a>5. 考虑在字符串类型的字段上使用前缀索引代替普通索引</h3><p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p><hr><h2 id="使用索引的一些建议"><a href="#使用索引的一些建议" class="headerlink" title="使用索引的一些建议"></a>使用索引的一些建议</h2><ul><li>对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引</li><li>避免 where 子句中对字段施加函数，这会造成无法命中索引。</li><li>在使用 InnoDB 时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li><li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用</li><li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</li></ul><hr><h2 id="MySQL-如何为表添加索引？"><a href="#MySQL-如何为表添加索引？" class="headerlink" title="MySQL 如何为表添加索引？"></a>MySQL 如何为表添加索引？</h2><p>1.添加 PRIMARY KEY（主键索引）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `table_name` <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY ( `<span class="hljs-keyword">column</span>` )<span class="hljs-keyword">Copy</span> <span class="hljs-keyword">to</span> clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>2.添加 UNIQUE(唯一索引)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqlite">ALTER TABLE `table_name` ADD UNIQUE ( `column` )Copy to clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>3.添加 INDEX(普通索引)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `table_name` <span class="hljs-keyword">ADD</span> INDEX index_name ( `<span class="hljs-keyword">column</span>` )<span class="hljs-keyword">Copy</span> <span class="hljs-keyword">to</span> clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>4.添加 FULLTEXT(全文索引)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `table_name` <span class="hljs-keyword">ADD</span> FULLTEXT ( `<span class="hljs-keyword">column</span>`)<span class="hljs-keyword">Copy</span> <span class="hljs-keyword">to</span> clipboardErrorCopied<br></code></pre></td></tr></table></figure><p>5.添加多列索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `table_name` <span class="hljs-keyword">ADD</span> INDEX index_name ( `column1`, `column2`, `column3` )<span class="hljs-keyword">Copy</span> <span class="hljs-keyword">to</span> clipboardErrorCopied<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL索引</category>
      
      <category>索引</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM垃圾回收详解</title>
    <link href="/2022/01/18/Gc/"/>
    <url>/2022/01/18/Gc/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM-垃圾回收详解"><a href="#JVM-垃圾回收详解" class="headerlink" title="JVM 垃圾回收详解"></a>JVM 垃圾回收详解</h1><h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><ul><li>如果判断对象是否死亡（两种方法）</li><li>简单的介绍一下强引用、软引用、软引用、虚引用（虚引用与软引用和弱引用的区别，使用软引用能带来的好处）。</li><li>如何判断一个常量是废弃常量？</li><li>如果判断一个类是无用类？</li><li>垃圾收集有哪些算法，各自的特点。</li><li>HotSpot 为什么要分为新生代和老年代？</li><li>常见的垃圾回收器有哪些？</li><li>介绍一下 CMS、G1 收集器。</li><li>Minor Gc 和 Full Gc 有什么不同？</li></ul><span id="more"></span><p><img src="/2022/01/18/Gc/1.png" alt="img"></p><p>当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p><h2 id="1-揭开-JVM-内存分配与回收的神秘面纱"><a href="#1-揭开-JVM-内存分配与回收的神秘面纱" class="headerlink" title="1. 揭开 JVM 内存分配与回收的神秘面纱"></a>1. 揭开 JVM 内存分配与回收的神秘面纱</h2><p>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p><p>Java 堆事垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p><strong>堆空间的基本结构：</strong></p><p><img src="/2022/01/18/Gc/2.png" alt="img"></p><p>上图所示的 Eden 区、From Survivor0(“From”) 区、To Survivor1(“To”) 区都属于新生代，Old Memory 区属于老年代。</p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为大于 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置默认值，这个值会在虚拟机运行过程中进行调整，可以通过<code>-XX:+PrintTenuringDistribution</code>来打印出当次 GC 后的 Threshold。</p><p>“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p><p><strong>动态年龄计算的代码如下</strong></p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs C"><span class="hljs-function">uint <span class="hljs-title">ageTable::compute_tenuring_threshold</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> survivor_capacity)</span> </span>&#123;<br> <span class="hljs-comment">//survivor_capacity是survivor空间的大小</span><br> <span class="hljs-keyword">size_t</span> desired_survivor_size = (<span class="hljs-keyword">size_t</span>)((((<span class="hljs-keyword">double</span>)survivor_capacity)*TargetSurvivorRatio)/<span class="hljs-number">100</span>);<br> <span class="hljs-keyword">size_t</span> total = <span class="hljs-number">0</span>;<br> uint age = <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">while</span> (age &lt; table_size) &#123;<br>     <span class="hljs-comment">//sizes数组是每个年龄段对象大小</span><br>     total += sizes[age];<br>     <span class="hljs-keyword">if</span> (total &gt; desired_survivor_size) &#123;<br>         <span class="hljs-keyword">break</span>;<br>     &#125;<br>     age++;<br> &#125;<br> uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;<br> ...<br>&#125;<br></code></pre></td></tr></table></figure><p>经过这次 GC 后，Eden 区和”From”区已经被清空。这个时候，”From”和”To”会交换他们的角色，也就是新的”To”就是上次 GC 前的“From”，新的”From”就是上次 GC 前的”To”。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，在这个过程中，有可能当次 Minor GC 后，Survivor 的”From”区域空间不够用，有一些还达不到进入老年代条件的实例放不下，则放不下的部分会提前进入老年代。 </p><p>接下来我们提供一个调试脚本来测试这个过程。</p><p><strong>调试代码参数如下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xm">-verbose:gc<br>-Xmx200M<br>-Xms200M<br>-Xmn50M<br>-XX:+PrintGCDetails<br>-XX:TargetSurvivorRatio=60<br>-XX:+PrintTenuringDistribution<br>-XX:+PrintGCDetails<br>-XX:+PrintGCDateStamps<br>-XX:MaxTenuringThreshold=3<br>-XX:+UseConcMarkSweepGC<br>-XX:+UseParNewGC<br></code></pre></td></tr></table></figure><p><strong>示例代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 本实例用于java GC以后，新生代survivor区域的变化，以及晋升到老年代的时间和方式的测试代码。需要自行分步注释不需要的代码进行反复测试对比</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* 由于java的main函数以及其他基础服务也会占用一些eden空间，所以要提前空跑一次main函数，来看看这部分占用。</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* 自定义的代码中，我们使用堆内分配数组和栈内分配数组的方式来分别模拟不可被GC的和可被GC的资源。</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">*</span><br><span class="hljs-comment">* */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaGcTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//空跑一次main函数来查看java服务本身占用的空间大小，我这里是占用了3M。所以40-3=37，下面分配三个1M的数组和一个34M的垃圾数组。</span><br><br><br>        <span class="hljs-comment">// 为了达到TargetSurvivorRatio（期望占用的Survivor区域的大小）这个比例指定的值, 即5M*60%=3M(Desired survivor size)，</span><br>        <span class="hljs-comment">// 这里用1M的数组的分配来达到Desired survivor size</span><br>        <span class="hljs-comment">//说明: 5M为S区的From或To的大小，60%为TargetSurvivorRatio参数指定,可以更改参数获取不同的效果。</span><br>        <span class="hljs-keyword">byte</span>[] byte1m_1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">byte</span>[] byte1m_2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">byte</span>[] byte1m_3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br><br>        <span class="hljs-comment">//使用函数方式来申请空间，函数运行完毕以后，就会变成垃圾等待回收。此时应保证eden的区域占用达到100%。可以通过调整传入值来达到效果。</span><br>        makeGarbage(<span class="hljs-number">34</span>);<br><br>        <span class="hljs-comment">//再次申请一个数组，因为eden已经满了，所以这里会触发Minor GC</span><br>        <span class="hljs-keyword">byte</span>[] byteArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">// 这次Minor Gc时, 三个1M的数组因为尚有引用，所以进入From区域（因为是第一次GC）age为1</span><br>        <span class="hljs-comment">// 且由于From区已经占用达到了60%(-XX:TargetSurvivorRatio=60), 所以会重新计算对象晋升的age。</span><br>        <span class="hljs-comment">// 计算方法见上文，计算出age：min(age, MaxTenuringThreshold) = 1，输出中会有Desired survivor size 3145728 bytes, new threshold 1 (max 3)字样</span><br>        <span class="hljs-comment">//新的数组byteArr进入eden区域。</span><br><br><br>        <span class="hljs-comment">//再次触发垃圾回收，证明三个1M的数组会因为其第二次回收后age为2，大于上一次计算出的new threshold 1，所以进入老年代。</span><br>        <span class="hljs-comment">//而byteArr因为超过survivor的单个区域，直接进入了老年代。</span><br>        makeGarbage(<span class="hljs-number">34</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeGarbage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span></span>&#123;<br>        <span class="hljs-keyword">byte</span>[] byteArrTemp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[size * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>];<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意:如下输出结果中老年代的信息为 <code>concurrent mark-sweep generation</code> 和以前版本略有不同。另外，还列出了某次 GC 后是否重新生成了 threshold，以及各个年龄占用空间的大小。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">2022-01-27T21:35:22.116+0800: [GC (Allocation Failure) 2022-01-27T21:35:22.116+0800: [ParNew<br>Desired survivor size 3145728 bytes, new threshold 1 (max 3)<br>- age   1:    3531352 bytes,    3531352 total<br>: 40351K-&gt;3490K(46080K), 0.0014085 secs] 40351K-&gt;3490K(199680K), 0.0014581 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] <br>2022-01-27T21:35:22.118+0800: [GC (Allocation Failure) 2022-01-27T21:35:22.118+0800: [ParNew<br>Desired survivor size 3145728 bytes, new threshold 3 (max 3)<br>: 13730K-&gt;0K(46080K), 0.0208955 secs] 13730K-&gt;13703K(199680K), 0.0209167 secs] [Times: user=0.05 sys=0.00, real=0.02 secs] <br>Heap<br> par new generation   total 46080K, used 35225K [0x00000007b3800000, 0x00000007b6a00000, 0x00000007b6a00000)<br>  eden space 40960K,  86% used [0x00000007b3800000, 0x00000007b5a667e8, 0x00000007b6000000)<br>  from space 5120K,   0% used [0x00000007b6000000, 0x00000007b6000000, 0x00000007b6500000)<br>  to   space 5120K,   0% used [0x00000007b6500000, 0x00000007b6500000, 0x00000007b6a00000)<br> concurrent mark-sweep generation total 153600K, used 13703K [0x00000007b6a00000, 0x00000007c0000000, 0x00000007c0000000)<br> Metaspace       used 3169K, capacity 4496K, committed 4864K, reserved 1056768K<br>  class space    used 346K, capacity 388K, committed 512K, reserved 1048576K<br></code></pre></td></tr></table></figure><img src="/2022/01/18/Gc/3.png" alt="堆内存常见分配策略 " style="zoom:200%;"><h3 id="1-1-对象优先在-eden-区分配"><a href="#1-1-对象优先在-eden-区分配" class="headerlink" title="1.1 对象优先在 eden 区分配"></a>1.1 对象优先在 eden 区分配</h3><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老生代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.下面我们来进行实际测试以下。</p><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaGcTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] allocation1, allocation2;<br>        allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">61000</span>*<span class="hljs-number">1024</span>];<br>        <span class="hljs-comment">// allocation2 = new byte[900*1024];</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">Heap<br> PSYoungGen      total 76288K, used 65536K [0x000000076ab00000, 0x0000000770000000, 0x00000007c0000000)<br>  eden space 65536K, 100% used [0x000000076ab00000,0x000000076eb00000,0x000000076eb00000)<br>  from space 10752K, 0% used [0x000000076f580000,0x000000076f580000,0x0000000770000000)<br>  to   space 10752K, 0% used [0x000000076eb00000,0x000000076eb00000,0x000000076f580000)<br> ParOldGen       total 175104K, used 0K [0x00000006c0000000, 0x00000006cab00000, 0x000000076ab00000)<br>  object space 175104K, 0% used [0x00000006c0000000,0x00000006c0000000,0x00000006cab00000)<br> Metaspace       used 3165K, capacity 4496K, committed 4864K, reserved 1056768K<br>  class space    used 345K, capacity 388K, committed 512K, reserved 1048576K<br></code></pre></td></tr></table></figure><p>从上图我们可以看出 eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。假如我们再为 allocation2 分配内存会出现什么情况呢？</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh">Heap<br> PSYoungGen      total 76288K, used 2771K [0x000000076ab00000, 0x0000000774000000, 0x00000007c0000000)<br>  eden space 65536K, 3% used [0x000000076ab00000,0x000000076ad28c80,0x000000076eb00000)<br>  from space 10752K, 5% used [0x000000076eb00000,0x000000076eb8c010,0x000000076f580000)<br>  to   space 10752K, 0% used [0x0000000773580000,0x0000000773580000,0x0000000774000000)<br> ParOldGen       total 175104K, used 61008K [0x00000006c0000000, 0x00000006cab00000, 0x000000076ab00000)<br>  object space 175104K, 34% used [0x00000006c0000000,0x00000006c3b94010,0x00000006cab00000)<br> Metaspace       used 3171K, capacity 4496K, committed 4864K, reserved 1056768K<br>  class space    used 346K, capacity 388K, committed 512K, reserved 1048576K<br></code></pre></td></tr></table></figure><p><strong>简单解释一下为什么会出现这种情况：</strong> 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。</p><h3 id="1-2-大对象直接进入老年代"><a href="#1-2-大对象直接进入老年代" class="headerlink" title="1.2 大对象直接进入老年代"></a>1.2 大对象直接进入老年代</h3><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）</p><p><strong>为什么要这样呢？</strong></p><p>为了避免为大对象分配内存时由于 <strong>分配担保机制</strong> 带来的复制而降低效率。</p><h3 id="1-3-长期存活的对象将进入老年代"><a href="#1-3-长期存活的对象将进入老年代" class="headerlink" title="1.3 长期存活的对象将进入老年代"></a>1.3 长期存活的对象将进入老年代</h3><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h3 id="1-4-动态对象年龄判定"><a href="#1-4-动态对象年龄判定" class="headerlink" title="1.4 动态对象年龄判定"></a>1.4 动态对象年龄判定</h3><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><p>“Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 <code>-XX:TargetSurvivorRatio=percent</code> 来设置，参见 <a href="https://github.com/Snailclimb/JavaGuide/issues/1199">issue1199(opens new window)</a> ），取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) &#123;<br><span class="hljs-comment">//survivor_capacity是survivor空间的大小</span><br>size_t desired_survivor_size = (size_t)((((<span class="hljs-keyword">double</span>)survivor_capacity)*TargetSurvivorRatio)/<span class="hljs-number">100</span>);<br>size_t total = <span class="hljs-number">0</span>;<br>uint age = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (age &lt; table_size) &#123;<br>  <span class="hljs-comment">//sizes数组是每个年龄段对象大小</span><br>  total += sizes[age];<br>  <span class="hljs-keyword">if</span> (total &gt; desired_survivor_size) &#123;<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>  age++;<br>&#125;<br>uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>关于默认的晋升年龄是 15，这个说法的来源大部分都是《深入理解 Java 虚拟机》这本书。</strong> 如果你去 Oracle 的官网阅读<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html">相关的虚拟机参数 (opens new window)</a>，你会发现<code>-XX:MaxTenuringThreshold=threshold</code>这里有个说明</p><p><strong>Sets the maximum tenuring threshold for use in adaptive GC sizing. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.默认晋升年龄并不都是 15，这个是要区分垃圾收集器的，CMS 就是 6.</strong></p></blockquote><h3 id="1-5-主要进行-gc-的区域"><a href="#1-5-主要进行-gc-的区域" class="headerlink" title="1.5 主要进行 gc 的区域"></a>1.5 主要进行 gc 的区域</h3><p>周志明先生在《深入理解 Java 虚拟机》第二版中 P92 如是写道：</p><blockquote><p><em>“老年代 GC（Major GC/Full GC），指发生在老年代的 GC……”</em></p></blockquote><p>上面的说法已经在《深入理解 Java 虚拟机》第三版中被改正过来了。感谢 R 大的回答：</p><p><img src="/2022/01/18/Gc/4.png" alt="img"></p><p><strong>总结：</strong></p><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h3 id="1-6-空间分配担保"><a href="#1-6-空间分配担保" class="headerlink" title="1.6 空间分配担保"></a>1.6 空间分配担保</h3><p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p><p>《深入理解 Java 虚拟机》第三章对于空间分配担保的描述如下：</p><blockquote><p>JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次 Full GC。</p><p>JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p></blockquote><h2 id="2-判断对象死亡"><a href="#2-判断对象死亡" class="headerlink" title="2. 判断对象死亡"></a>2. 判断对象死亡</h2><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p><p><img src="/2022/01/18/Gc/5.png" alt="img"></p><h3 id="2-1-引用计数法"><a href="#2-1-引用计数法" class="headerlink" title="2.1 引用计数法"></a>2.1 引用计数法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReferenceCountingGc</span> </span>&#123;<br>    Object instance = <span class="hljs-keyword">null</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>ReferenceCountingGc objA = <span class="hljs-keyword">new</span> ReferenceCountingGc();<br>ReferenceCountingGc objB = <span class="hljs-keyword">new</span> ReferenceCountingGc();<br>objA.instance = objB;<br>objB.instance = objA;<br>objA = <span class="hljs-keyword">null</span>;<br>objB = <span class="hljs-keyword">null</span>;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-可达性分析算法"><a href="#2-2-可达性分析算法" class="headerlink" title="2.2 可达性分析算法"></a>2.2 可达性分析算法</h3><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p><img src="/2022/01/18/Gc/6.png" alt="可达性分析算法 " style="zoom: 150%;"><p>可作为 GC Roots 的对象包括下面几种:</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li></ul><h3 id="2-3-再谈引用"><a href="#2-3-再谈引用" class="headerlink" title="2.3 再谈引用"></a>2.3 再谈引用</h3><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p><strong>1. 强引用（Strong Reference）</strong></p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p><strong>2. 软引用（Soft Reference）</strong></p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p><strong>3. 弱引用（Weak Reference）</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="2-4-不可达对象并非-“非死不可”"><a href="#2-4-不可达对象并非-“非死不可”" class="headerlink" title="2.4 不可达对象并非 “非死不可”"></a>2.4 不可达对象并非 “非死不可”</h3><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。 </p><p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p><blockquote><p><code>Object</code> 类中的 <code>finalize</code> 方法一直被认为是一个糟糕的设计，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。JDK9 版本及后续版本中各个类中的 <code>finalize</code> 方法会被逐渐弃用移除。忘掉它的存在吧！</p></blockquote><h3 id="2-5-如何判断一个常量是废弃常量"><a href="#2-5-如何判断一个常量是废弃常量" class="headerlink" title="2.5 如何判断一个常量是废弃常量"></a>2.5 如何判断一个常量是废弃常量</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><p><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></p><p><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</p><p><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></p><p>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><h3 id="2-6-如何判断一个类是无用的类"><a href="#2-6-如何判断一个类是无用的类" class="headerlink" title="2.6 如何判断一个类是无用的类"></a>2.6 如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3. 垃圾收集算法"></a>3. 垃圾收集算法</h2><p><img src="/2022/01/18/Gc/7.png" alt="垃圾收集算法分类"></p><h3 id="3-1-标记-清除算法"><a href="#3-1-标记-清除算法" class="headerlink" title="3.1 标记-清除算法"></a>3.1 标记-清除算法</h3><p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong></li><li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li></ol><p><img src="/2022/01/18/Gc/8.png" alt="img"></p><h3 id="3-2-标记-复制算法"><a href="#3-2-标记-复制算法" class="headerlink" title="3.2 标记-复制算法"></a>3.2 标记-复制算法</h3><p>为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="/2022/01/18/Gc/9.png" alt="复制算法"></p><h3 id="3-3-标记整理算法"><a href="#3-3-标记整理算法" class="headerlink" title="3.3 标记整理算法"></a>3.3 标记整理算法</h3><p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="/2022/01/18/Gc/10.png" alt="标记-整理算法 "></p><h3 id="3-4-分代收集算法"><a href="#3-4-分代收集算法" class="headerlink" title="3.4 分代收集算法"></a>3.4 分代收集算法</h3><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p><p><strong>延伸面试问题：</strong> HotSpot 为什么要分为新生代和老年代？</p><p>根据上面的对分代收集算法的介绍回答。</p><h2 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4. 垃圾收集器"></a>4. 垃圾收集器</h2><p><img src="/2022/01/18/Gc/11.png" alt="垃圾收集器分类"></p><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。</p><h3 id="4-1-Serial-收集器"><a href="#4-1-Serial-收集器" class="headerlink" title="4.1 Serial 收集器"></a>4.1 Serial 收集器</h3><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="/2022/01/18/Gc/12.png" alt=" Serial 收集器 "></p><p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p><h3 id="4-2-ParNew-收集器"><a href="#4-2-ParNew-收集器" class="headerlink" title="4.2 ParNew 收集器"></a>4.2 ParNew 收集器</h3><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="/2022/01/18/Gc/13.png" alt="ParNew 收集器 "></p><p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><p><strong>并行和并发概念补充：</strong></p><ul><li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li></ul><h3 id="4-3-Parallel-Scavenge-收集器"><a href="#4-3-Parallel-Scavenge-收集器" class="headerlink" title="4.3 Parallel Scavenge 收集器"></a>4.3 Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器也是使用标记-复制算法的多线程收集器，它看上去几乎和 ParNew 都一样。 <strong>那么它有什么特别之处呢？</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">-XX:+UseParallelGC<br><br>    使用 Parallel 收集器+ 老年代串行<br><br>-XX:+UseParallelOldGC<br><br>    使用 Parallel 收集器+ 老年代并行<br></code></pre></td></tr></table></figure><p><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="/2022/01/18/Gc/14.png" alt="Parallel Scavenge 收集器 "></p><p><strong>这是 JDK1.8 默认收集器</strong></p><p>使用 java -XX:+PrintCommandLineFlags -version 命令查看</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">-XX:InitialHeapSize=262921408 -XX:MaxHeapSize=4206742528 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC<br>java version <span class="hljs-string">&quot;1.8.0_211&quot;</span><br>Java(TM) SE Runtime Environment (build 1.8.0_211-b12)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)<br></code></pre></td></tr></table></figure><p>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能</p><h3 id="4-4-Serial-Old-收集器"><a href="#4-4-Serial-Old-收集器" class="headerlink" title="4.4.Serial Old 收集器"></a>4.4.Serial Old 收集器</h3><p><strong>Serial 收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p><h3 id="4-5-Parallel-Old-收集器"><a href="#4-5-Parallel-Old-收集器" class="headerlink" title="4.5 Parallel Old 收集器"></a>4.5 Parallel Old 收集器</h3><p><strong>Parallel Scavenge 收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p><h3 id="4-6-CMS-收集器"><a href="#4-6-CMS-收集器" class="headerlink" title="4.6 CMS 收集器"></a>4.6 CMS 收集器</h3><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p><img src="/2022/01/18/Gc/15.png" alt="CMS 垃圾收集器 "></p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><h3 id="4-7-G1-收集器"><a href="#4-7-G1-收集器" class="headerlink" title="4.7 G1 收集器"></a>4.7 G1 收集器</h3><p><strong>G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><h3 id="4-8-ZGC-收集器"><a href="#4-8-ZGC-收集器" class="headerlink" title="4.8 ZGC 收集器"></a>4.8 ZGC 收集器</h3><p>与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。</p><p>在 ZGC 中出现 Stop The World 的情况会更少！</p><p>详情可以看 ： <a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">《新一代垃圾回收器 ZGC 的探索与实践》(opens new window)</a></p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>垃圾回收</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hashcode与equals</title>
    <link href="/2022/01/17/hashcode%E4%B8%8Eequals/hashcode%20%E4%B8%8E%20equals/"/>
    <url>/2022/01/17/hashcode%E4%B8%8Eequals/hashcode%20%E4%B8%8E%20equals/</url>
    
    <content type="html"><![CDATA[<h2 id="hashcode与equals"><a href="#hashcode与equals" class="headerlink" title="hashcode与equals"></a>hashcode与equals</h2><p>这是一个很基础的问题，但是需要答道点子上。</p><p>答案来源<a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-hashcode">Java Guide</a></p><span id="more"></span><h3 id="hashcode有什么用"><a href="#hashcode有什么用" class="headerlink" title="hashcode有什么用"></a>hashcode有什么用</h3><p><code>hashcode()</code> 的作用是获取哈希码（<code>int</code>），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><p><code>hashcode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是：<code>Object</code> 的 <code>hashCode()</code>  方法是本地方法，也就是用 C/C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs jaav">public native int hashCode();<br></code></pre></td></tr></table></figure><p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p><h3 id="为什么要有hashcode"><a href="#为什么要有hashcode" class="headerlink" title="为什么要有hashcode"></a>为什么要有hashcode</h3><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p><p>hashcode 和 equals 都是为了比较两个对象是否相等。</p><h3 id="为什么-JDK-要同时使用这两个方法呢？"><a href="#为什么-JDK-要同时使用这两个方法呢？" class="headerlink" title="为什么 JDK 要同时使用这两个方法呢？"></a>为什么 JDK 要同时使用这两个方法呢？</h3><p>这是因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashcode()</code> 之后，判断元素是否在对应容器中的效率会更高。</p><p>我们在前面也提到了添加元素进<code>HastSet</code>的过程，如果 <code>HashSet</code> 在对比的时候，同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</p><h3 id="为什么不只提供hashcode呢？"><a href="#为什么不只提供hashcode呢？" class="headerlink" title="为什么不只提供hashcode呢？"></a>为什么不只提供hashcode呢？</h3><p>因为两个对象的 <code>hashcode</code> 值相同，也不代表这两个对象相等。</p><p>再好的 <code>hashcode</code> 算法都会造成哈希冲突，越糟糕的 hash 算法越容易发生碰撞，但这也与数据域的分布特性有关。</p><p>总结下来就是：</p><ul><li>如果两个对象的 <code>hashcode</code> 值相等，那么这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的 <code>hashcode</code> 值相同并且 <code>equals()</code> 方法也是 true，那么就可以认为这两个对象是相等的。</li><li>如果两个对象的 <code>hashcode</code> 值不相等，我们就可以认为这两个对象不相等。</li></ul><h3 id="为什么要重写-equals-方法时必须重写-hashcode-方法？"><a href="#为什么要重写-equals-方法时必须重写-hashcode-方法？" class="headerlink" title="为什么要重写 equals() 方法时必须重写 hashcode() 方法？"></a>为什么要重写 equals() 方法时必须重写 hashcode() 方法？</h3><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Object类方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/2022/01/17/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/01/17/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="代理模式-1"><a href="#代理模式-1" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理模式是一种比较好理解的设计模式。简单来说就是<strong>我们使用代理对象来代替对真实对象的访问，这样就可以在不修改原目标的前提下，提供额外的功能操作，扩展对象的功能</strong>。</p><span id="more"></span><p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作</strong>。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p><strong>静态代理中，我们对目标目标对象的每个方法的增强都是手动完成的</strong>。非常不灵活，如果接口一旦新增加方法，目标对象和代理对象都要进行修改，而且需要对每个目标类都单独写一个代理类，十分麻烦。所以在日常开发中几乎看不到使用静态代理的情况。</p><p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， <strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p><p>静态代理实现步骤:</p><ol><li>定义一个接口及其实现类；</li><li>创建一个代理类同样实现这个接口</li><li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li></ol><p>例子：</p><ol><li>定义发送短信的接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SmsService</span> </span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">send</span><span class="hljs-params">(String message)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>实现发送短信的接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SmsService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">send</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;send message:&quot;</span> + message);<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>创建代理类并同样实现发送短信的接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SmsService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SmsService smsService;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmsProxy</span><span class="hljs-params">(SmsService smsService)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.smsService = smsService;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">send</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-comment">//调用方法之前，我们可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;before method send()&quot;</span>);<br>        smsService.send(message);<br>        <span class="hljs-comment">//调用方法之后，我们同样可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;after method send()&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>实际使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SmsService smsService = <span class="hljs-keyword">new</span> SmsServiceImpl();<br>        SmsProxy smsProxy = <span class="hljs-keyword">new</span> SmsProxy(smsService);<br>        smsProxy.send(<span class="hljs-string">&quot;java&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以说，真的挺麻烦的。就是硬把实现方法夹在中间而已。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>相比较于静态代理而言，动态代理就好太多了，不需要为了每个目标类都单独创建一个代理类，而且也不需要必须实现接口，可以直接代理实现类。</p><p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong></p><p>说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。</p><p><strong>动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p><p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p><h4 id="3-1-JDK-动态代理机制"><a href="#3-1-JDK-动态代理机制" class="headerlink" title="3.1 JDK 动态代理机制"></a>3.1 JDK 动态代理机制</h4><h5 id="3-1-1-介绍"><a href="#3-1-1-介绍" class="headerlink" title="3.1.1 介绍"></a>3.1.1 介绍</h5><p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p><p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">newProxyInstance</span><span class="hljs-params">(ClassLoader loader,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="hljs-params"><span class="hljs-function">                                      InvocationHandler h)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">throws</span> IllegalArgumentException</span><br><span class="hljs-function"></span>&#123;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法一共有 3 个参数：</p><ol><li><strong>loader</strong> :类加载器，用于加载代理对象。</li><li><strong>interfaces</strong> : 被代理类实现的一些接口；</li><li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li></ol><p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当你使用代理对象调用方法的时候实际会调用到这个方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> Throwable</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>invoke()</code> 方法有下面三个参数：</p><ol><li><strong>proxy</strong> :动态生成的代理类</li><li><strong>method</strong> : 与代理类对象调用的方法相对应</li><li><strong>args</strong> : 当前 method 方法的参数</li></ol><p>也就是说：<strong>你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p><h5 id="3-1-2-JDK-动态代理类使用步骤"><a href="#3-1-2-JDK-动态代理类使用步骤" class="headerlink" title="3.1.2 JDK 动态代理类使用步骤"></a>3.1.2 JDK 动态代理类使用步骤</h5><ol><li>定义一个接口及其实现类；</li><li>自定义 <code>InvocationHandler</code> 并重写 <code>invoke</code> 方法，在 <code>invoke</code> 方法中会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li><li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li></ol><h5 id="3-1-3-代码示例"><a href="#3-1-3-代码示例" class="headerlink" title="3.1.3 代码示例"></a>3.1.3 代码示例</h5><ol><li>定义发送短信接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SmsService</span> </span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">send</span><span class="hljs-params">(String message)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>实现发送短信的接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SmsService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">send</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;send message:&quot;</span> + message);<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>定义一个 JDK 动态代理类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代理类中的真实对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DebugInvocationHandler</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.target = target;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;<br>        <span class="hljs-comment">//调用方法之前，我们可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;before method &quot;</span> + method.getName());<br>        Object result = method.invoke(target, args);<br>        <span class="hljs-comment">//调用方法之后，我们同样可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;after method &quot;</span> + method.getName());<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>invoke()</code> 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 <code>invoke()</code> 方法，然后 <code>invoke()</code> 方法代替我们去调用了被代理对象的原生方法。</p><ol start="4"><li>获取代理对象的工厂类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdkProxyFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<br>                target.getClass().getClassLoader(), <span class="hljs-comment">// 目标类的类加载</span><br>                target.getClass().getInterfaces(),  <span class="hljs-comment">// 代理需要实现的接口，可指定多个</span><br>                <span class="hljs-keyword">new</span> DebugInvocationHandler(target)   <span class="hljs-comment">// 代理对象对应的自定义 InvocationHandler</span><br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>getProxy()</code> ：主要通过<code>Proxy.newProxyInstance（）</code>方法获取某个类的代理对象</p><ol start="5"><li>实际使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">SmsService smsService = (SmsService) JdkProxyFactory.getProxy(<span class="hljs-keyword">new</span> SmsServiceImpl());<br>smsService.send(<span class="hljs-string">&quot;java&quot;</span>);<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">before method send<br>send message:java<br>after method send<br></code></pre></td></tr></table></figure><h4 id="3-2-CGLIB-动态代理机制"><a href="#3-2-CGLIB-动态代理机制" class="headerlink" title="3.2 CGLIB 动态代理机制"></a>3.2 CGLIB 动态代理机制</h4><h5 id="3-2-1-介绍"><a href="#3-2-1-介绍" class="headerlink" title="3.2.1 介绍"></a>3.2.1 介绍</h5><p><strong>JDK 动态代理有一个致命的问题就是其只能代理实现了接口的类</strong>。</p><p><strong>为了解决这个问题，可以使用 CGLIB 动态代理机制来避免。</strong></p><p><a href="https://github.com/cglib/cglib">CGLIB</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm">ASM</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了<a href="https://github.com/cglib/cglib">CGLIB</a>， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p><p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</strong></p><p>你需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MethodInterceptor</span></span><br><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">Callback</span></span>&#123;<br>    <span class="hljs-comment">// 拦截被代理类中的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object obj, java.lang.reflect.Method method, Object[] args,</span></span><br><span class="hljs-params"><span class="hljs-function">                               MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><strong>obj</strong> :被代理的对象（需要增强的对象）</li><li><strong>method</strong> :被拦截的方法（需要增强的方法）</li><li><strong>args</strong> :方法入参</li><li><strong>proxy</strong> :用于调用原始方法</li></ol><p>你可以通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p><h5 id="3-2-2-CGLIB-动态代理类使用步骤"><a href="#3-2-2-CGLIB-动态代理类使用步骤" class="headerlink" title="3.2.2 CGLIB 动态代理类使用步骤"></a>3.2.2 CGLIB 动态代理类使用步骤</h5><ol><li>定义一个类</li><li>自定义 <code>MethodInteceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理的 <code>invoke</code> 方法相似。</li><li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li></ol><h5 id="3-2-3-代码示例"><a href="#3-2-3-代码示例" class="headerlink" title="3.2.3 代码示例"></a>3.2.3 代码示例</h5><p>不同于 JDK 动态代理不需要额外的依赖。<a href="https://github.com/cglib/cglib">CGLIB</a>(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>实现一个使用发送短信的类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> github.javaguide.dynamicProxy.cglibDynamicProxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AliSmsService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">send</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;send message:&quot;</span> + message);<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>自定义 <code>MethodInterceptor</code> 拦截器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> net.sf.cglib.proxy.MethodProxy;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义MethodInterceptor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> o           代理对象（增强的对象）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method      被拦截的方法（需要增强的方法）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args        方法入参</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> methodProxy 用于调用原始方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-comment">//调用方法之前，我们可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;before method &quot;</span> + method.getName());<br>        Object object = methodProxy.invokeSuper(o, args);<br>        <span class="hljs-comment">//调用方法之后，我们同样可以添加自己的操作</span><br>        System.out.println(<span class="hljs-string">&quot;after method &quot;</span> + method.getName());<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>获取代理类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> net.sf.cglib.proxy.Enhancer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibProxyFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建动态代理增强类</span><br>        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>        <span class="hljs-comment">// 设置类加载器</span><br>        enhancer.setClassLoader(clazz.getClassLoader());<br>        <span class="hljs-comment">// 设置被代理类</span><br>        enhancer.setSuperclass(clazz);<br>        <span class="hljs-comment">// 设置方法拦截器</span><br>        enhancer.setCallback(<span class="hljs-keyword">new</span> DebugMethodInterceptor());<br>        <span class="hljs-comment">// 创建代理类</span><br>        <span class="hljs-keyword">return</span> enhancer.create();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>实际使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">AliSmsService aliSmsService = (AliSmsService) CglibProxyFactory.getProxy(AliSmsService.class);<br>aliSmsService.send(<span class="hljs-string">&quot;java&quot;</span>);<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">before method send<br>send message:java<br>after method send<br></code></pre></td></tr></table></figure><h4 id="3-3-JDK动态代理于-CGLIB-动态代理对比"><a href="#3-3-JDK动态代理于-CGLIB-动态代理对比" class="headerlink" title="3.3 JDK动态代理于 CGLIB 动态代理对比"></a>3.3 JDK动态代理于 CGLIB 动态代理对比</h4><ol><li><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</li><li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li></ol><h3 id="静态代理和动态代理的对比"><a href="#静态代理和动态代理的对比" class="headerlink" title="静态代理和动态代理的对比"></a>静态代理和动态代理的对比</h3><ol><li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li><li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>代理模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代理模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合框架基础知识</title>
    <link href="/2022/01/07/%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/01/07/%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Java集合框架基础知识-amp-面试题总结"><a href="#Java集合框架基础知识-amp-面试题总结" class="headerlink" title="Java集合框架基础知识&amp;面试题总结"></a>Java集合框架基础知识&amp;面试题总结</h1><h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><h3 id="Java-集合概览"><a href="#Java-集合概览" class="headerlink" title="Java 集合概览"></a>Java 集合概览</h3><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p><span id="more"></span><p>Java 集合框架如下图所示：</p><p><img src="/2022/01/07/%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/1.png" alt="1"></p><p>注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了<code>AbstractList</code>, <code>NavigableSet</code>等抽象类以及其他的一些辅助类，如想深入了解，可自行查看源码。</p><h3 id="List，Set，Queue，Map-四者区别"><a href="#List，Set，Queue，Map-四者区别" class="headerlink" title="List，Set，Queue，Map 四者区别"></a>List，Set，Queue，Map 四者区别</h3><ul><li><code>List</code>(对付顺序的好帮手): 存储的元素是有序的、可重复的。</li><li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li><li><code>Queue</code>(实现排队功能的叫号机): 按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。</li><li><code>Map</code>(用 key 来搜索的专家): 使用键值对（key-value）存储，类似于数学上的函数 y=f(x)，”x” 代表 key，”y” 代表 value，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li></ul><h3 id="集合框架底层数据结构"><a href="#集合框架底层数据结构" class="headerlink" title="集合框架底层数据结构"></a>集合框架底层数据结构</h3><p>先来看一下 <code>Collection</code> 接口下面的集合。</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul><li><code>Arraylist</code>： <code>Object[]</code> 数组</li><li><code>Vector</code>：<code>Object[]</code> 数组</li><li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li></ul><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li><li><code>TreeSet</code>(有序，唯一): 红黑树(自平衡的排序二叉树)</li></ul><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li><li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li></ul><p>再来看看 <code>Map</code> 接口下面的集合。</p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul><li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li><li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>Hashtable</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li><li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li></ul><h3 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合"></a>如何选用集合</h3><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</p><p>当我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</p><h3 id="为什么要选用集合"><a href="#为什么要选用集合" class="headerlink" title="为什么要选用集合"></a>为什么要选用集合</h3><p>当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端， 因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。</p><p>数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。 但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。</p><h2 id="Collection-子接口之-List"><a href="#Collection-子接口之-List" class="headerlink" title="Collection 子接口之 List"></a>Collection 子接口之 List</h2><h3 id="ArrayList-和-Vector-的区别"><a href="#ArrayList-和-Vector-的区别" class="headerlink" title="ArrayList 和 Vector 的区别"></a>ArrayList 和 Vector 的区别</h3><ul><li><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[ ]</code>存储，适用于频繁的查找工作，线程不安全 ；</li><li><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[ ]</code> 存储，线程安全的。</li></ul><h3 id="ArrayList-和-LinkedList-的区别"><a href="#ArrayList-和-LinkedList-的区别" class="headerlink" title="ArrayList 和 LinkedList 的区别"></a>ArrayList 和 LinkedList 的区别</h3><ol><li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li><li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li>插入和删除是否受元素位置的影响：<ul><li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li><li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），近似 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。</li></ul></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li><li><strong>内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ol><h3 id="补充：RandomAccess-接口"><a href="#补充：RandomAccess-接口" class="headerlink" title="补充：RandomAccess 接口"></a>补充：RandomAccess 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RandomAccess</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看源码我们发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以，在我看来 <code>RandomAccess</code> 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p><p>在 <code>binarySearch（)</code> 方法中，它要判断传入的 list 是否 <code>RamdomAccess</code> 的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(List&lt;? extends Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (list <span class="hljs-keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)<br>        <span class="hljs-keyword">return</span> Collections.indexedBinarySearch(list, key);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> Collections.iteratorBinarySearch(list, key);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。为什么呢？我觉得还是和底层数据结构有关！<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。，<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！</p><h3 id="ArrayList-的扩容机制"><a href="#ArrayList-的扩容机制" class="headerlink" title="ArrayList 的扩容机制"></a>ArrayList 的扩容机制</h3><p>下一篇</p><h2 id="Collection-子接口之-Set"><a href="#Collection-子接口之-Set" class="headerlink" title="Collection 子接口之 Set"></a>Collection 子接口之 Set</h2><h3 id="comparable-和-Comparator-的区别"><a href="#comparable-和-Comparator-的区别" class="headerlink" title="comparable 和 Comparator 的区别"></a>comparable 和 Comparator 的区别</h3><ul><li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code>.</p><h4 id="Comparator-定制排序"><a href="#Comparator-定制排序" class="headerlink" title="Comparator 定制排序"></a>Comparator 定制排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>arrayList.add(-<span class="hljs-number">1</span>);<br>arrayList.add(<span class="hljs-number">3</span>);<br>arrayList.add(<span class="hljs-number">3</span>);<br>arrayList.add(-<span class="hljs-number">5</span>);<br>arrayList.add(<span class="hljs-number">7</span>);<br>arrayList.add(<span class="hljs-number">4</span>);<br>arrayList.add(-<span class="hljs-number">9</span>);<br>arrayList.add(-<span class="hljs-number">7</span>);<br>System.out.println(<span class="hljs-string">&quot;原始数组:&quot;</span>);<br>System.out.println(arrayList);<br><span class="hljs-comment">// void reverse(List list)：反转</span><br>Collections.reverse(arrayList);<br>System.out.println(<span class="hljs-string">&quot;Collections.reverse(arrayList):&quot;</span>);<br>System.out.println(arrayList);<br><br><span class="hljs-comment">// void sort(List list),按自然排序的升序排序</span><br>Collections.sort(arrayList);<br>System.out.println(<span class="hljs-string">&quot;Collections.sort(arrayList):&quot;</span>);<br>System.out.println(arrayList);<br><span class="hljs-comment">// 定制排序的用法</span><br>Collections.sort(arrayList, <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> o2.compareTo(o1);<br>    &#125;<br>&#125;);<br>System.out.println(<span class="hljs-string">&quot;定制排序后：&quot;</span>);<br>System.out.println(arrayList);<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">原始数组:<br>[-<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">9</span>, -<span class="hljs-number">7</span>]<br>Collections.reverse(arrayList):<br>[-<span class="hljs-number">7</span>, -<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">1</span>]<br>Collections.sort(arrayList):<br>[-<span class="hljs-number">9</span>, -<span class="hljs-number">7</span>, -<span class="hljs-number">5</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>]<br>定制排序后：<br>[<span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">5</span>, -<span class="hljs-number">7</span>, -<span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><h4 id="重写-compareTo-方法实现年龄来排序"><a href="#重写-compareTo-方法实现年龄来排序" class="headerlink" title="重写 compareTo 方法实现年龄来排序"></a>重写 compareTo 方法实现年龄来排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span><br><span class="hljs-comment">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span><br><span class="hljs-comment">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span><br><span class="hljs-keyword">public</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Person</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * T重写compareTo方法实现按年龄来排序</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Person o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.age &gt; o.getAge()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.age &lt; o.getAge()) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Main：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    TreeMap&lt;Person, String&gt; pdata = <span class="hljs-keyword">new</span> TreeMap&lt;Person, String&gt;();<br>    pdata.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">30</span>), <span class="hljs-string">&quot;zhangsan&quot;</span>);<br>    pdata.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">20</span>), <span class="hljs-string">&quot;lisi&quot;</span>);<br>    pdata.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">10</span>), <span class="hljs-string">&quot;wangwu&quot;</span>);<br>    pdata.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;小红&quot;</span>, <span class="hljs-number">5</span>), <span class="hljs-string">&quot;xiaohong&quot;</span>);<br>    <span class="hljs-comment">// 得到key的值的同时得到key所对应的值</span><br>    Set&lt;Person&gt; keys = pdata.keySet();<br>    <span class="hljs-keyword">for</span> (Person key : keys) &#123;<br>        System.out.println(key.getAge() + <span class="hljs-string">&quot;-&quot;</span> + key.getName());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">5</span>-小红<br><span class="hljs-number">10</span>-王五<br><span class="hljs-number">20</span>-李四<br><span class="hljs-number">30</span>-张三<br></code></pre></td></tr></table></figure><h3 id="无序性和不可重复性的含义是什么？"><a href="#无序性和不可重复性的含义是什么？" class="headerlink" title="无序性和不可重复性的含义是什么？"></a>无序性和不可重复性的含义是什么？</h3><p>1、什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p><p>2、什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p><h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的。</li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li></ul><h2 id="Collection-子接口之-Queue"><a href="#Collection-子接口之-Queue" class="headerlink" title="Collection 子接口之 Queue"></a>Collection 子接口之 Queue</h2><p><code>Queue</code> 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 <strong>先进先出（FIFO）</strong> 规则。</p><p><code>Queue</code> 扩展了 <code>Collection</code> 的接口，根据 <strong>因为容量问题而导致操作失败后处理方式的不同</strong>可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。</p><table><thead><tr><th><code>Queue</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队尾</td><td>add(E e)</td><td>offer(E e)</td></tr><tr><td>删除队首</td><td>remove()</td><td>poll()</td></tr><tr><td>查询队首元素</td><td>element()</td><td>peek()</td></tr></tbody></table><p><code>Deque</code> 是双端队列，在队列的两端均可以插入或删除元素。</p><p><code>Deque</code> 扩展了 <code>Queue</code> 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：</p><table><thead><tr><th><code>Deque</code> 接口</th><th>抛出异常</th><th>返回特殊值</th></tr></thead><tbody><tr><td>插入队首</td><td>addFirst(E e)</td><td>offerFirst(E e)</td></tr><tr><td>插入队尾</td><td>addLast(E e)</td><td>offerLast(E e)</td></tr><tr><td>删除队首</td><td>removeFirst()</td><td>pollFirst()</td></tr><tr><td>删除队尾</td><td>removeLast()</td><td>pollLast()</td></tr><tr><td>查询队首元素</td><td>getFirst()</td><td>peekFirst()</td></tr><tr><td>查询队尾元素</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>事实上，<code>Deque</code> 还提供有 <code>push()</code> 和 <code>pop()</code> 等其他方法，可用于模拟栈。</p><h3 id="ArrayDeque-和-LinkedList-的区别"><a href="#ArrayDeque-和-LinkedList-的区别" class="headerlink" title="ArrayDeque 和 LinkedList 的区别"></a>ArrayDeque 和 LinkedList 的区别</h3><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能，但两者有什么区别呢？</p><ul><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 是在 JDK1.6 才被引入的，而<code>LinkedList</code> 早在 JDK1.2 时就已经存在。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li></ul><p>从性能的角度上，选用 <code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 更好。此外，<code>ArrayDeque</code> 也可以用于实现栈。</p><h3 id="说-PriorityQueue"><a href="#说-PriorityQueue" class="headerlink" title="说 PriorityQueue"></a>说 PriorityQueue</h3><p><code>PriorityQueue</code> 是在 JDK1.5 中被引入的, 其与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p><p>这里列举其相关的一些要点：</p><ul><li><code>PriorityQueue</code> 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据</li><li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li><li><code>PriorityQueue</code> 是非线程安全的，且不支持存储 <code>NULL</code> 和 <code>non-comparable</code> 的对象。</li><li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li></ul><p><code>PriorityQueue</code> 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。</p><h2 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h2><h3 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h3><ol><li><strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。另外，<code>Hashtable</code> 基本被淘汰，不要在代码中使用它；</li><li><strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 <code>NullPointerException</code>。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，<code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 <code>HashMap</code> 会将其扩充为 2 的幂次方大小（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><p><strong><code>HashMap</code> 中带有初始容量的构造函数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +<br>                                           initialCapacity);<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +<br>                                           loadFactor);<br>    <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面这个方法保证了 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns a power of two size for the given target capacity.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="HashMap-和-HashSet-的区别"><a href="#HashMap-和-HashSet-的区别" class="headerlink" title="HashMap 和 HashSet 的区别"></a>HashMap 和 HashSet 的区别</h3><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：<code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。（<code>HashSet</code> 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 <code>HashSet</code> 自己不得不实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p><table><thead><tr><th><code>HashMap</code></th><th><code>HashSet</code></th></tr></thead><tbody><tr><td>实现了 <code>Map</code> 接口</td><td>实现 <code>Set</code> 接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用 <code>put()</code>向 map 中添加元素</td><td>调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td></tr><tr><td><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td><td><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td></tr></tbody></table><h3 id="HashMap-和-TreeMap-的区别"><a href="#HashMap-和-TreeMap-的区别" class="headerlink" title="HashMap 和 TreeMap 的区别"></a>HashMap 和 TreeMap 的区别</h3><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p><p><img src="/2022/01/07/%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/2.png" alt="2"></p><p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p><p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        TreeMap&lt;Person, String&gt; treeMap = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;(<span class="hljs-keyword">new</span> Comparator&lt;Person&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person person1, Person person2)</span> </span>&#123;<br>                <span class="hljs-keyword">int</span> num = person1.getAge() - person2.getAge();<br>                <span class="hljs-keyword">return</span> Integer.compare(num, <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;);<br>        treeMap.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">3</span>), <span class="hljs-string">&quot;person1&quot;</span>);<br>        treeMap.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">18</span>), <span class="hljs-string">&quot;person2&quot;</span>);<br>        treeMap.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">35</span>), <span class="hljs-string">&quot;person3&quot;</span>);<br>        treeMap.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">16</span>), <span class="hljs-string">&quot;person4&quot;</span>);<br>        treeMap.entrySet().stream().forEach(personStringEntry -&gt; &#123;<br>            System.out.println(personStringEntry.getValue());<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">person1<br>person4<br>person2<br>person3<br></code></pre></td></tr></table></figure><p>可以看出，<code>TreeMap</code> 中的元素已经是按照 <code>Person</code> 的 age 字段的升序来排列了。</p><p>上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 Lambda 表达式实现的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">TreeMap&lt;Person, String&gt; treeMap = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;((person1, person2) -&gt; &#123;<br>  <span class="hljs-keyword">int</span> num = person1.getAge() - person2.getAge();<br>  <span class="hljs-keyword">return</span> Integer.compare(num, <span class="hljs-number">0</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>综上，相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p><h3 id="HashSet-如何检查重复"><a href="#HashSet-如何检查重复" class="headerlink" title="HashSet 如何检查重复"></a>HashSet 如何检查重复</h3><p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p><p>在openjdk8中，<code>HashSet</code>的<code>add()</code>方法只是简单的调用了<code>HashMap</code>的<code>put()</code>方法，并且判断了一下返回值以确保是否有重复元素。直接看一下<code>HashSet</code>中的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Returns: true if this set did not already contain the specified element</span><br><span class="hljs-comment">// 返回值：当set中没有包含add的元素时返回真</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> map.put(e, PRESENT)==<span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>而在<code>HashMap</code>的<code>putVal()</code>方法中也能看到如下说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Returns : previous value, or null if none</span><br><span class="hljs-comment">// 返回值：如果插入位置没有元素返回null，否则返回上一个元素</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> V <span class="hljs-title">putVal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent,</span></span><br><span class="hljs-params"><span class="hljs-function">                   <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，在openjdk8中，实际上无论<code>HashSet</code>中是否已经存在了某元素，<code>HashSet</code>都会直接插入，只是会在<code>add()</code>方法的返回值处告诉我们插入前是否存在相同元素。</p><p><strong><code>hashCode()</code>与 <code>equals()</code> 的相关规定：</strong></p><ol><li>如果两个对象相等，则 <code>hashcode</code> 一定也是相同的</li><li>两个对象相等,对两个 <code>equals()</code> 方法返回 true</li><li>两个对象有相同的 <code>hashcode</code> 值，它们也不一定是相等的</li><li>综上，<code>equals()</code> 方法被覆盖过，则 <code>hashCode()</code> 方法也必须被覆盖</li><li><code>hashCode()</code>的默认行为是对堆上的对象产生独特值。如果没有重写 <code>hashCode()</code>，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><p><strong>==与 equals 的区别</strong></p><p>对于基本类型来说，== 比较的是值是否相等；</p><p>对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；</p><p>对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。</p><h3 id="HashMap-的底层实现"><a href="#HashMap-的底层实现" class="headerlink" title="HashMap 的底层实现"></a>HashMap 的底层实现</h3><h4 id="JDK-1-8-之前"><a href="#JDK-1-8-之前" class="headerlink" title="JDK 1.8 之前"></a>JDK 1.8 之前</h4><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p><p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-comment">// key.hashCode()：返回散列值也就是hashcode</span><br>    <span class="hljs-comment">// ^ ：按位异或</span><br>    <span class="hljs-comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h)</span> </span>&#123;<br>    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span><br>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span><br>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span><br><br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src="/2022/01/07/%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/3.png" alt="3"></p><h4 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h4><p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="/2022/01/07/%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/4.png" alt="4"></p><blockquote><p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p></blockquote><h3 id="HashMap-的长度为什么取-2-的幂次方"><a href="#HashMap-的长度为什么取-2-的幂次方" class="headerlink" title="HashMap 的长度为什么取 2 的幂次方"></a>HashMap 的长度为什么取 2 的幂次方</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p><p><strong>这个算法应该如何设计呢？</strong></p><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</strong></p><h3 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h3><p>主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p><p>具体后期说</p><h3 id="HashMap-有哪几种常见遍历方法"><a href="#HashMap-有哪几种常见遍历方法" class="headerlink" title="HashMap 有哪几种常见遍历方法"></a>HashMap 有哪几种常见遍历方法</h3><p>具体后期分析源码说</p><h3 id="CurrentHashMap-和-HashTable-的区别"><a href="#CurrentHashMap-和-HashTable-的区别" class="headerlink" title="CurrentHashMap 和 HashTable 的区别"></a>CurrentHashMap 和 HashTable 的区别</h3><p><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 <code>HashMap1.8</code> 的结构一样，<strong>数组+链表/红黑二叉树</strong>。<code>Hashtable</code> 和 JDK1.8 之前的 <code>HashMap</code> 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，<code>ConcurrentHashMap</code>（分段锁）</strong> 对整个桶数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。（JDK1.6 以后 对 <code>synchronized</code> 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 <code>HashMap</code>，虽然在 JDK1.8 中还能看到 <code>Segment</code> 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ul><p><strong>两者的对比图：</strong></p><p><strong>Hashtable:</strong></p><p><img src="/2022/01/07/%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/5.png" alt="5"></p><p><strong>JDK1.7 的 ConcurrentHashMap：</strong></p><p><img src="/2022/01/07/%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/6.png" alt="6"></p><p><strong>JDK1.8 的 ConcurrentHashMap：</strong></p><p><img src="/2022/01/07/%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0/7.png" alt="7"></p><p>JDK1.8 的 <code>ConcurrentHashMap</code> 不再是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 **<code>TreeNode</code>**。当冲突链表达到一定长度时，链表会转换成红黑树。</p><h3 id="ConcurrentHashMap-线程安全的具体实现方式-底层具体实现"><a href="#ConcurrentHashMap-线程安全的具体实现方式-底层具体实现" class="headerlink" title="ConcurrentHashMap 线程安全的具体实现方式 / 底层具体实现"></a>ConcurrentHashMap 线程安全的具体实现方式 / 底层具体实现</h3><h4 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h4><p>首先将数据分为一段一段的存储，然后给每一顿数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其访问。</p><p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p><p>Segment 实现了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种可重入锁，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Segment</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组。<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code>是一个链表结构的元素，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。</p><h4 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h4><p><code>ConcurrentHashMap</code> 取消了 <code>Segment</code> 分段锁，采用 CAS 和 <code>synchronized</code> 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）</p><p><code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2><p>collections 工具类常用方法：</p><ol><li>排序</li><li>查找,替换操作</li><li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li></ol><h3 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(List list)</span><span class="hljs-comment">//反转</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shuffle</span><span class="hljs-params">(List list)</span><span class="hljs-comment">//随机排序</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(List list)</span><span class="hljs-comment">//按自然排序的升序排序</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(List list, Comparator c)</span><span class="hljs-comment">//定制排序，由Comparator控制排序逻辑</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(List list, <span class="hljs-keyword">int</span> i , <span class="hljs-keyword">int</span> j)</span><span class="hljs-comment">//交换两个索引位置的元素</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(List list, <span class="hljs-keyword">int</span> distance)</span><span class="hljs-comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span></span><br></code></pre></td></tr></table></figure><h3 id="查找，替换操作"><a href="#查找，替换操作" class="headerlink" title="查找，替换操作"></a>查找，替换操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(List list, Object key)</span><span class="hljs-comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(Collection coll)</span><span class="hljs-comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(Collection coll, Comparator c)</span><span class="hljs-comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fill</span><span class="hljs-params">(List list, Object obj)</span><span class="hljs-comment">//用指定的元素代替指定list中的所有元素</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">frequency</span><span class="hljs-params">(Collection c, Object o)</span><span class="hljs-comment">//统计元素出现次数</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">indexOfSubList</span><span class="hljs-params">(List list, List target)</span><span class="hljs-comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)</span></span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">replaceAll</span><span class="hljs-params">(List list, Object oldVal, Object newVal)</span><span class="hljs-comment">//用新元素替换旧元素</span></span><br></code></pre></td></tr></table></figure><h3 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h3><p><code>Collections</code> 提供了多个<code>synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p><p>我们知道 <code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>,<code>LinkedList</code>,<code>HashMap</code>,<code>TreeMap</code> 都是线程不安全的。<code>Collections</code> 提供了多个静态方法可以把他们包装成线程同步的集合。</p><p><strong>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。</strong></p><p>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">synchronizedCollection(Collection&lt;T&gt;  c) <span class="hljs-comment">//返回指定 collection 支持的同步（线程安全的）collection。</span><br>synchronizedList(List&lt;T&gt; list)<span class="hljs-comment">//返回指定列表支持的同步（线程安全的）List。</span><br>synchronizedMap(Map&lt;K,V&gt; m) <span class="hljs-comment">//返回由指定映射支持的同步（线程安全的）Map。</span><br>synchronizedSet(Set&lt;T&gt; s) <span class="hljs-comment">//返回指定 set 支持的同步（线程安全的）set。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java容器</tag>
      
      <tag>概述</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据包在网络中的心路历程</title>
    <link href="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/"/>
    <url>/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="数据包在网络中的心路历程"><a href="#数据包在网络中的心路历程" class="headerlink" title="数据包在网络中的心路历程"></a>数据包在网络中的心路历程</h1><hr><p>解决<strong>「当键入网址后，到网页显示，期间发生了什么？」</strong>问题！</p><span id="more"></span><p>来源公众号（小林coding）</p><p>以下图较简单的网络拓扑模型作为例子，探究探究其间发生了什么？</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/1.png" alt="图片"></p><h2 id="01-孤单小弟-–-HTTP"><a href="#01-孤单小弟-–-HTTP" class="headerlink" title="01 孤单小弟 – HTTP"></a>01 孤单小弟 – HTTP</h2><h3 id="浏览器做的第一步工作是解析URL"><a href="#浏览器做的第一步工作是解析URL" class="headerlink" title="浏览器做的第一步工作是解析URL"></a>浏览器做的第一步工作是解析<code>URL</code></h3><p>首先浏览器做的第一步工作就是要对<code>URL</code>进行解析，从而生发送给<code>WEB</code>服务器的请求信息。</p><p>让我们看看一条长长的 URL 里的各个元素的代表什么，见下图：</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/2.png" alt="图片"></p><p>所以图中的长长的URL实际上是请求服务器里的文件资源。</p><h3 id="如果蓝色的URL省略，请问的文件是什么？"><a href="#如果蓝色的URL省略，请问的文件是什么？" class="headerlink" title="如果蓝色的URL省略，请问的文件是什么？"></a>如果蓝色的<code>URL</code>省略，请问的文件是什么？</h3><p>当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是<code>/index.html</code>或者<code>/default.html</code>这些文件，这样就不会发生混乱了。</p><h3 id="生产HTTP请求信息"><a href="#生产HTTP请求信息" class="headerlink" title="生产HTTP请求信息"></a>生产<code>HTTP</code>请求信息</h3><p>对<code>URL</code>进行解析之后，浏览器确定了<code>WEB</code>服务器和文件名，接下来就是根据这些信息来生成<code>HTTP</code>请求消息了。</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/3.png" alt="图片"></p><blockquote><p>一个孤单 HTTP 数据包表示：“我这么一个小小的数据包，没亲没友，直接发到浩瀚的网络，谁会知道我呢？谁能载我一层呢？谁能保护我呢？我的目的地在哪呢？”。充满各种疑问的它，没有停滞不前，依然踏上了征途！</p></blockquote><hr><h2 id="02-真实的地址查询-–-DNS"><a href="#02-真实的地址查询-–-DNS" class="headerlink" title="02 真实的地址查询 – DNS"></a>02 真实的地址查询 – DNS</h2><p>通过浏览器解析<code>URL</code>并生成<code>HTTP</code>消息后，需要委托操作系统将消息发送给<code>WEB</code>服务器。</p><p>但在发送之前，还有一项工作需要完成，那就是<strong>查询服务器域名对于的<code>IP</code>地址</strong>，因为委托操作系统发送消息时，必需提供通信对象的<code>IP</code>地址。</p><p>比如我们打电话的时候，必须要知道对方的电话号码，但由于电话号码难以记忆，所以通常我们会将对方电话号 + 姓名保存在通讯录里。</p><p>所以，有一种服务器就专门保存了 <code>Web</code> 服务器域名与 <code>IP</code> 的对应关系，它就是 <code>DNS</code>服务器。</p><h3 id="域名的层级关系"><a href="#域名的层级关系" class="headerlink" title="域名的层级关系"></a>域名的层级关系</h3><p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。</p><p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p><p>毕竟域名是外国人发明，所以思维和中国人相反，比如说一个城市地点的时候，外国喜欢从小到大的方式顺序说起（如 XX 街道 XX 区 XX 市 XX 省），而中国则喜欢从大到小的顺序（如 XX 省 XX 市 XX 区 XX 街道）。</p><p>根域是在最顶层，它的下一层就是 com 顶级域，再下面是 server.com。</p><p>所以域名的层级关系类似一个树状结构：</p><ul><li>根<code>DNS</code>服务器</li><li>顶级域<code>DNS</code>服务器（com）</li><li>权威<code>DNS</code>服务器（server.com）</li></ul><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/4.png" alt="图片"></p><p>根域的<code>DNS</code>服务器保存在互联网中所有的<code>DNS</code>服务器中。</p><p>这样以来，任何<code>DNS</code>服务器都可以找到并访问根域<code>DNS</code>服务器了。</p><p>因此，客户端只要能够找到任意一台 <code>DNS</code> 服务器，就可以通过它找到根域 <code>DNS</code> 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 <code>DNS</code> 服务器。</p><h3 id="域名解析的工作流程"><a href="#域名解析的工作流程" class="headerlink" title="域名解析的工作流程"></a>域名解析的工作流程</h3><ol><li>客户端首先会发出一个DNS请求，问<code>www.server.com</code>的<code>IP</code>是啥，并发给本地<code>DNS</code>服务器（也就是客户端的<code>TCP/IP</code>设置中填写的<code>DNS</code>服务器地址）。</li><li>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到<code>www.server.com</code>，则它直接返回IP地址，如果没有，本地<code>DNS</code>回去问它的根域名服务器：“老大， 能告诉我<code> www.server.com</code> 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li><li>根<code>DNS</code>收到来自本地的<code>DNS</code>的请求后，发现后置是<code>.com</code>，说：“<code>www.server.com</code> 这个域名归<code> .com</code> 区域管理”，我给你<code> .com</code> 顶级域名服务器地址给你，你去问问它吧。”</li><li>本地<code>DNS</code>收到顶级域名服务器的地址后，发起请求问：“老二， 你能告诉我<code>www.server.com</code> 的 IP 地址吗？”</li><li>顶级域名服务器说：“我给你负责<code> www.server.com</code> 区域的权威 <code>DNS</code> 服务器的地址，你去问它应该能问到”。</li><li>本地<code>DNS</code>于是转向问权威<code>DNS</code>服务器：“老三，<code>www.server.com</code>对应的IP是啥呀？”<code>server.com</code>的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li><li>权威<code>DNS</code>服务器查询后将对应的<code>IP</code>地址<code>X.X.X.X</code>告诉本地<code>DNS</code></li><li>本地<code>DNS</code>再将<code>IP</code>地址返回给客户端，客户端和目标建立连接</li></ol><p>至此，完成了<code>DNS</code>的解析过程。</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/5.png" alt="图片"></p><p>DNS 域名解析的过程蛮有意思的，整个过程就和我们日常生活中找人问路的过程类似，<strong>只指路不带路</strong>。</p><blockquote><p>数据包表示：“DNS 老大哥厉害呀，找到了目的地了！我还是很迷茫呀，我要发出去，接下来我需要谁的帮助呢?”</p></blockquote><hr><h2 id="03-指南好帮手-–-协议栈"><a href="#03-指南好帮手-–-协议栈" class="headerlink" title="03 指南好帮手 – 协议栈"></a>03 指南好帮手 – 协议栈</h2><p>通过<code>DNS</code>获取到<code>IP</code>后，就可以把<code>HTTP</code>的传输工作交给操作系统中的<strong>协议栈</strong>。</p><p>协议栈的内部分为几个部分，分别承担着不同的工作，上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/6.png" alt="图片"></p><p>应用程序（浏览器）通过调用<code>Socket</code>库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的<code>TCP</code>和<code>UDP</code>协议，它们两会接受应用层的委托执行收发数据的操作。</p><p>协议栈的下面一半是用<code>IP</code>协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块一块的网络包，而将网络包发送给对方的操作就是由<code>IP</code>负责的。</p><p>此外<code>IP</code>中还包含<code>ICMP</code>协议和<code>ARP</code>协议。</p><ul><li>**<code>ICMP</code>**用于告知网络包传送过程中产生的错误以及各种控制信息。</li><li>**<code>ARP</code>**用户根据<code>IP</code>地址查询相应的以太网<code>MAC</code>地址。</li></ul><p><code>IP</code>下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中信号执行发送和接收操作。</p><blockquote><p>数据包看了这份指南表示：“原来我需要那么多大佬的协助啊，那我先去找找 TCP 大佬！”</p></blockquote><hr><h2 id="04-可靠的传输-–-TCP"><a href="#04-可靠的传输-–-TCP" class="headerlink" title="04 可靠的传输 – TCP"></a>04 可靠的传输 – TCP</h2><p><code>HTTP</code>是基于<code>TCP</code>协议传输的，所以先了解一下<code>TCP</code>协议</p><h3 id="TCP包头格式"><a href="#TCP包头格式" class="headerlink" title="TCP包头格式"></a>TCP包头格式</h3><p>我们先看看 TCP 报文头部的格式：</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/7.png" alt="图片"></p><p>首先，<strong>源端口号</strong>和<strong>目标端口号</strong>是必不可少的，如果没这两个端口号，数据就不知道应该发给哪个应用。</p><p>接下来有包的<strong>序号</strong>，这个是为了解决包乱序的问题。</p><p>接下来是<strong>确认号</strong>，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决丢包的问题。</p><p>接下来还有一些<strong>状态位</strong>。例如**<code>SYN</code><strong>发起一个连接，</strong><code>ACK</code><strong>是回复，</strong><code>RST</code><strong>是重新连接，</strong><code>FIN</code>**是结束连接等。<code>TCP</code>是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</p><p>还有一个重要的是<strong>窗口大小</strong>。<code>TCP</code>要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，被发送太快也不要太慢。</p><p>除了做流量控制以为，<code>TCP</code>还会做<strong>拥塞控制</strong>，对于真正的通路堵不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。</p><h3 id="TCP传输数据之前，要先做三次握手建立连接"><a href="#TCP传输数据之前，要先做三次握手建立连接" class="headerlink" title="TCP传输数据之前，要先做三次握手建立连接"></a>TCP传输数据之前，要先做三次握手建立连接</h3><p>在<code>HTTP</code>传输数据之前，首先需要<code>TCP</code>建立连接，<code>TCP</code>连接的建立，通常被称为<strong>三次握手</strong>。</p><p>这个所谓的<strong>「连接」</strong>，只是双方计算机里维护的一个状态机，在连接建立的过程中，双方的状态变化顺序图就像这样。</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/8.png" alt="图片"></p><ul><li>一开始，客户端和服务端都处于**<code>CLOSE</code><strong>状态。先是服务端主动监听某个端口，处于</strong><code>LISTEN</code>**状态。</li><li>然后客户端主动发起**<code>SYN</code><strong>，之后出去</strong><code>SYN-SENT</code>**状态。</li><li>服务端收到发起的连接，返回**<code>SYN</code><strong>，并且</strong><code>ACK</code><strong>客户端的</strong><code>SYN</code><strong>，之后处于</strong><code>SYN-RCVD</code>**状态。</li><li>客户端收到服务端的**<code>SYN</code><strong>和</strong><code>ACK</code><strong>后，发送</strong><code>ACK</code><strong>的</strong><code>ACK</code><strong>，之后处于</strong><code>ESTABLISHED</code>**状态，因为它一发一收成功了。</li><li>服务端收到**<code>ACK</code><strong>的</strong><code>ACK</code><strong>后，处于</strong><code>ESTABLISHED</code>**状态，因为它也一发一放成功了。</li></ul><p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p><h3 id="如何查看TCP的连接状态"><a href="#如何查看TCP的连接状态" class="headerlink" title="如何查看TCP的连接状态"></a>如何查看TCP的连接状态</h3><p><code>TCP</code>连接状态查看，在<strong>Linux</strong>可以通过<code>netstat -napt</code>命令查看。</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/9.png" alt="图片"></p><h3 id="TCP分割数据"><a href="#TCP分割数据" class="headerlink" title="TCP分割数据"></a>TCP分割数据</h3><p>如果 HTTP 请求消息比较长，超过了 <code>MSS</code> 的长度，这时 TCP 就需要把 HTTP 的数据拆解一块块的数据发送，而不是一次性发送所有数据。</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/10.png" alt="图片"></p><ul><li><strong><code>MTU</code><strong>：一个网络包的最大长度，以太网中一般为</strong><code>1500</code>字节</strong>。</li><li>**<code>MSS</code>**：出去<code>IP</code>和<code>TCP</code>头部之后，一个网络包所能容纳的<code>TCP</code>数据的最大长度</li></ul><p>数据会被以<code>MSS</code>的长度为单位进行拆分，拆分出来的每一块数据都会被放进党读的网络包中。也就是在每个被拆分的数据加上<code>TCP</code>的头部信息，然后交给<code>IP</code>模块来发送数据。</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/11.png" alt="图片"></p><h3 id="TCP报文生成"><a href="#TCP报文生成" class="headerlink" title="TCP报文生成"></a>TCP报文生成</h3><p><code>TCP</code>协议里会有两个端口，一个是浏览器监听的都端口（通常是随机生成的），一个是<code>Web</code>服务器坚挺的端口（<code>HTTP</code>默认端口是80，<code>HTTPS</code>默认端口是443）</p><p>在双方建立了连接后，<code>TCP</code>报文中的数据部分就是存放<code>HTTP</code>头部 + 数据，组装好<code>TCP</code>报文之后，就需要交给下面的网络层处理。</p><p>至此，网络包的报文如下图。</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/12.png" alt="图片"></p><blockquote><p>此时，遇上了 TCP 的  数据包激动表示：“太好了，碰到了可靠传输的 TCP 传输，它给我加上 TCP 头部，我不在孤单了，安全感十足啊！有大佬可以保护我的可靠送达！但我应该往哪走呢？”</p></blockquote><hr><h2 id="05-远程定位-–-IP"><a href="#05-远程定位-–-IP" class="headerlink" title="05 远程定位 – IP"></a>05 远程定位 – IP</h2><p><code>TCP</code>模块在执行连接、收发、断开灯各阶段操作时，都需要委托<code>IP</code>模块将数据封装成<strong>网络包</strong>发送给通信对象。</p><h2 id="IP包头格式"><a href="#IP包头格式" class="headerlink" title="IP包头格式"></a>IP包头格式</h2><p>我们先看看 IP 报文头部的格式：</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/13.png" alt="图片"></p><p>在<code>IP</code>协议里面需要有<strong>源地址IP</strong>和<strong>目标地址IP</strong>：</p><ul><li>源地址<code>IP</code>，即客户端输出的<code>IP</code>地址</li><li>目标地址<code>IP</code>，即通过<code>DNS</code>域名解析得到的<code>Web</code>服务器<code>IP</code></li></ul><p>因为<code>HTTP</code>时经过<code>TCP</code>传输的，所以在<code>IP</code>包头的<strong>协议号</strong>，要填写为 <code>06</code>（十六进制），表示协议为 TCP。</p><h3 id="假设客户端有多个网卡，就会有多个-IP-地址，那-IP-头部的源地址应该选择哪个-IP-呢？"><a href="#假设客户端有多个网卡，就会有多个-IP-地址，那-IP-头部的源地址应该选择哪个-IP-呢？" class="headerlink" title="假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？"></a>假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？</h3><p>当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。</p><p>这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。</p><p>这个时候就需要根据<strong>路由表</strong>规则，来判断哪一个网卡作为源地址<code>IP</code>。</p><p>在<strong>Linux</strong>操作系统，我们可以使用<code>route -n</code>命令来查看当前系统的路由表。</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/14.png" alt="图片"></p><p>举个例子，根据上面的路由表，我们假设<code>Web</code>服务器的目标地址是<code>192.168.10.200</code>。</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/15.png" alt="图片"></p><ol><li>首先先和第一条条目的子网掩码(<code>Genmask</code>)进行<strong>与运算</strong>，得到结果为<code>192.168.10.0</code>，但是第一个条目的<code>Destination</code>是<code>192.168.3.0</code>，两者不一致所以匹配失败。</li><li>再与第二条目的子网掩码进行 <strong>与运算</strong>，得到的结果为 <code>192.168.10.0</code>，与第二条目的 <code>Destination 192.168.10.0</code> 匹配成功，所以将使用 <code>eth1</code> 网卡的 IP 地址作为 IP 包头的源地址。</li></ol><p>那么假设 Web 服务器的目标地址是 <code>10.100.20.100</code>，那么依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。</p><p>第三条目比较特殊，它目标地址和子网掩码都是 <code>0.0.0.0</code>，这表示<strong>默认网关</strong>，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，<code>Gateway</code> 即是路由器的 IP 地址。</p><h3 id="IP报文生成"><a href="#IP报文生成" class="headerlink" title="IP报文生成"></a>IP报文生成</h3><p>至此，网络包的报文如下图。</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/16.png" alt="图片"></p><blockquote><p>此时，加上了 IP 头部的数据包表示 ：“有 IP 大佬给我指路了，感谢 IP 层给我加上了 IP 包头，让我有了远程定位的能力！不会害怕在浩瀚的互联网迷茫了！可是目的地好远啊，我下一站应该去哪呢？”</p></blockquote><hr><h2 id="06-两点传输-–-MAC"><a href="#06-两点传输-–-MAC" class="headerlink" title="06 两点传输 – MAC"></a>06 两点传输 – MAC</h2><p>生成了<code>IP</code>头部后，接下来网络包还需要在<code>IP</code>头部前面加上<strong>MAC头部</strong></p><h3 id="MAC包头格式"><a href="#MAC包头格式" class="headerlink" title="MAC包头格式"></a>MAC包头格式</h3><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/17.png" alt="图片"></p><p>在<code>MAC</code>包头中需要<strong>发送方MAC地址</strong>和<strong>接收方目标的MAC地址</strong>，用于<strong>两点之间的传输</strong>。</p><p>一般在<code>TCP/IP</code>通信里，<code>MAC</code>包头的协议类型只使用:</p><ul><li>**<code>0800</code>**：<code>IP</code>协议</li><li>**<code>0806</code>**：<code>ARP</code>协议</li></ul><h3 id="MAC发送方和接收方如何确认？"><a href="#MAC发送方和接收方如何确认？" class="headerlink" title="MAC发送方和接收方如何确认？"></a>MAC发送方和接收方如何确认？</h3><p><strong>发送方</strong>的<code>MAC</code>地址获取较为简单，<code>MAC</code>地址时在网卡生产时写到<code>ROM</code>里的，只要将这个值读取出来写到<code>MAC</code>头部就可以了。</p><p><strong>接收方</strong>的<code>MAC</code>地比较复杂，只要告诉以太网对方的<code>MAC</code>地址，以太网就会帮我们把包发过去，那么很显然这里应该填写对方的<code>MAC</code>地址</p><p>所以首先得搞清楚应该把包发给谁，这个只要查一下<strong>路由表</strong>就知道了。在路由表中找到匹配的条路，然后把包发给<strong>Gateway</strong>列中的<code>IP</code>地址就可以了。</p><h3 id="既然知道要发给谁，按如何获取对方的-MAC-地址呢？"><a href="#既然知道要发给谁，按如何获取对方的-MAC-地址呢？" class="headerlink" title="既然知道要发给谁，按如何获取对方的 MAC 地址呢？"></a>既然知道要发给谁，按如何获取对方的 MAC 地址呢？</h3><p>不知道对方 MAC 地址？不知道就喊呗。</p><p>此时就需要 <code>ARP</code> 协议帮我们找到路由器的 MAC 地址</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/18.png" alt="图片"></p><p>ARP 协议会在以太网中以<strong>广播</strong>的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。</p><p>然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。</p><p>如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。</p><h3 id="好像每次都要广播获取，这不是很麻烦吗？"><a href="#好像每次都要广播获取，这不是很麻烦吗？" class="headerlink" title="好像每次都要广播获取，这不是很麻烦吗？"></a>好像每次都要广播获取，这不是很麻烦吗？</h3><p>放心，在后续操作系统会把本次查询结果放到一块叫做 <strong>ARP 缓存</strong>的内存空间留着以后用，不过缓存的时间就几分钟。</p><p>也就是说，在发包时：</p><ul><li>先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。</li><li>而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。</li></ul><h3 id="查看ARP缓存内容"><a href="#查看ARP缓存内容" class="headerlink" title="查看ARP缓存内容"></a>查看ARP缓存内容</h3><p>在<code>linux</code>系统中，可以用<code>arp -a</code>命令来查看<code>ARP</code>缓存的内容。</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/19.png" alt="图片"></p><h3 id="MAC报文生成"><a href="#MAC报文生成" class="headerlink" title="MAC报文生成"></a>MAC报文生成</h3><p>至此，网络包的报文如下图。</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/20.png" alt="图片"></p><blockquote><p>此时，加上了 MAC 头部的数据包万分感谢，说道 ：“感谢 MAC 大佬，我知道我下一步要去了哪了！我现在有很多头部兄弟，相信我可以到达最终的目的地！”。带着众多头部兄弟的数据包，终于准备要出门了。</p></blockquote><hr><h2 id="07-出口-–-网卡"><a href="#07-出口-–-网卡" class="headerlink" title="07 出口 – 网卡"></a>07 出口 – 网卡</h2><p><code>IP</code>生成的网络包只是存放在内存中的一串二进制数据信息，没有办法直接发送给对方。因此，我们需要将<strong>数据信息转化为电信号</strong>，才能在网线上传输，也就是说，这才是真正数据发送的过程。</p><p>负责执行这一操作的是<strong>网卡</strong>，要控制网卡还需要靠网卡驱动程序。</p><p>网卡驱动从<code>IP</code>模块获取到包之后，会将其<strong>复制</strong>到网卡那的缓存区中，接着会在其<strong>开头加上报文和起始帧的分界符，在其末尾加上用于检测错误的帧校验序列</strong>。</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/21.png" alt="图片"></p><ul><li><p>起始帧分界符是一个用来表示包起始位置的标记</p></li><li><p>末尾的 <code>FCS</code>（帧校验序列）用来检查包传输过程是否有损坏</p></li></ul><p>最后网卡会将包转为电信号，通过网线发送出去。</p><blockquote><p>唉，真是不容易，发一个包，真是历经历经千辛万苦。致此，一个带有许多头部的数据终于踏上寻找目的地的征途了！</p></blockquote><hr><h2 id="08-送别者-–-交换机"><a href="#08-送别者-–-交换机" class="headerlink" title="08 送别者 – 交换机"></a>08 送别者 – 交换机</h2><p>下面来看一下包是如何通过交换机的。交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p><h3 id="交换机的包接收操作"><a href="#交换机的包接收操作" class="headerlink" title="交换机的包接收操作"></a>交换机的包接收操作</h3><p>首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。</p><p>然后通过包末尾的 <code>FCS</code> 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p><p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p><p>将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。</p><p>交换机的 MAC 地址表主要包含两个信息：</p><ul><li>一个是设备的<code>MAC</code>地址</li><li>另一个是该设备连接在交换机的哪个端口上</li></ul><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/22.png" alt="图片"></p><p>举个例子，如果收到的包的接收方<code>MAC</code>地址为<code>00-02-B3-1C-9C-F9</code>，则与图中表中的第3行匹配，根据端口列的信息，可知这个地址位于<code>3</code>号端口上，然后就可以通过交换电路将包发送到相对应的端口了。</p><p>所以，<strong>交换机根据MAC地址表查找MAC地址，然后将信号发送到相对应的端口</strong>。</p><h3 id="当-MAC-地址表找不到指定的-MAC-地址会怎么样"><a href="#当-MAC-地址表找不到指定的-MAC-地址会怎么样" class="headerlink" title="当 MAC 地址表找不到指定的 MAC 地址会怎么样"></a>当 MAC 地址表找不到指定的 MAC 地址会怎么样</h3><p>地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。</p><p>这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。</p><p>这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后<strong>只有相应的接收者才接收包，而其他设备则会忽略这个包</strong>。</p><p>有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？”</p><p>其实完全不用过于担心，因为发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 MAC 地址表，下次也就不需要把包发到所有端口了。</p><p>局域网中每秒可以传输上千个包，多出一两个包并无大碍。</p><p>此外，如果接收方 MAC 地址是一个<strong>广播地址</strong>，那么交换机会将包发送到除源端口之外的所有端口。</p><p>以下两个属于广播地址：</p><ul><li>MAC 地址中的 <code>FF:FF:FF:FF:FF:FF</code></li><li>IP 地址中的 <code>255.255.255.255</code></li></ul><blockquote><p>数据包通过交换机转发抵达了路由器，准备要离开土生土长的子网了。此时，数据包和交换机离别时说道：“感谢交换机兄弟，帮我转发到出境的大门，我要出远门啦！”</p></blockquote><hr><h2 id="09-出境大门-–-路由器"><a href="#09-出境大门-–-路由器" class="headerlink" title="09 出境大门 – 路由器"></a>09 出境大门 – 路由器</h2><p>网络包经过交换机之后，现在达到了<strong>路由器</strong>，并在此被转发到下一个路由器或目标设备。</p><p>这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。</p><p>不过在具体操作过程中，路由器和交换机是有区别的：</p><ul><li>因为<strong>路由器</strong>是基于<code>IP</code>设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有<code>MAC</code>地址和<code>IP</code>地址。</li><li><strong>交换机</strong>是基于以太网设计的，俗称<strong>二层</strong>网络设备，交换机的端口不具有<code>MAC</code>地址。</li></ul><h3 id="路由器的基本原理"><a href="#路由器的基本原理" class="headerlink" title="路由器的基本原理"></a>路由器的基本原理</h3><p>路由器的端口具有<code>MAC</code>地址，因此它就能够成为以太网的发送方和接收方；同时还具有<code>IP</code>地址，从这个意义上来说，它和计算机的网卡是一样的。</p><p>当转发包时，首先路由器端口会接收发给自己的以太网包，然后<strong>路由表</strong>查询转发目标，再由相应的端口最为发送方将以太网包发送出去。</p><h3 id="路由器的包接收操作"><a href="#路由器的包接收操作" class="headerlink" title="路由器的包接收操作"></a>路由器的包接收操作</h3><p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转化为数字信号，然后通过包末尾的<code>FCS</code>进行错误校验。</p><p>如果没问题检查<code>MAC</code>头部中的<strong>接收方MAC地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p><p>总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。</p><h3 id="查询路由表确定输出端口"><a href="#查询路由表确定输出端口" class="headerlink" title="查询路由表确定输出端口"></a>查询路由表确定输出端口</h3><p>完成包接收工作后，路由器就会<strong>去掉</strong>包开头的<code>MAC</code>头部</p><p><strong>MAC头部的作用就是将包送达路由器</strong>，其中的接收方<code>MAC</code>地址就是路由器端口的<code>MAC</code>地址。因此，当包到达路由器后，<code>MAC</code>头部的任务就完成了，于是<code>MAC</code>头部就会被<strong>丢弃</strong>。</p><p>接下来，路由器会根据<code>MAC</code>头部后方的<code>IP</code>头部中的内容进行包的转发操作。</p><p>转发操作分为几个阶段，首先是查询<strong>路由表</strong>判断转发目标。</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/23.png" alt="图片"></p><p>具体的工作流程根据上图，举个例子。</p><p>假设地址为 <code>10.10.1.101</code> 的计算机要向地址为 <code>192.168.1.100</code> 的服务器发送一个包，这个包先到达图中的路由器。</p><p>判断转发目标的第一步，就是根据包的接收方 IP 地址查询路由表中的目标地址栏，以找到相匹配的记录。</p><p>路由匹配和前面讲的一样，每个条目的子网掩码和 <code>192.168.1.100</code> IP 做 <strong>&amp; 与运算</strong>后，得到的结果与对应条目的目标地址进行匹配，如果匹配就会作为候选转发目标，如果不匹配就继续与下个条目进行路由匹配。</p><p>如第二条目的子网掩码 <code>255.255.255.0</code> 与 <code>192.168.1.100</code> IP 做 <strong>&amp; 与运算</strong>后，得到结果是 <code>192.168.1.0</code> ，这与第二条目的目标地址 <code>192.168.1.0</code> 匹配，该第二条目记录就会被作为转发目标。</p><p>实在找不到匹配路由时，就会选择<strong>默认路由</strong>，路由表中子网掩码为 <code>0.0.0.0</code> 的记录表示「默认路由」。</p><h3 id="路由器的发送操作"><a href="#路由器的发送操作" class="headerlink" title="路由器的发送操作"></a>路由器的发送操作</h3><p>接下来就会进入包的<strong>发送操作</strong>。</p><p>首先，我们需要根据<strong>路由表的网关列</strong>判断对方的地址。</p><ul><li>如果网关是一个<code>IP</code>地址，则这个<code>IP</code>地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还继续需要路由器转发。</li><li>如果网关为空，则<code>IP</code>头部中的接收方<code>IP</code>就是要转发到的目标地址，也就是终于找到<code>IP</code>包头里的目标地址了，说明<strong>已抵达终点</strong>。</li></ul><p>知道对方的<code>IP</code>地址后，接下来需要通过<code>ARP</code>协议根据<code>IP</code>地址查询<code>MAC</code>地址，并将查询的结果作为接收方的<code>MAC</code>地址。</p><p>路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。</p><p>接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 <code>0080</code> （十六进制）表示 IP 协议。</p><p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。</p><p>发送出去的网络包会通过<strong>交换机</strong>到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p><p>接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p><p>不知你发现了没有，在网络包传输的过程中，<strong>源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址</strong>，因为需要 MAC 地址在以太网内进行<strong>两个设备</strong>之间的包传输。</p><blockquote><p>数据包通过多个路由器道友的帮助，在网络世界途径了很多路程，最终抵达了目的地的城门！城门值守的路由器，发现了这个小兄弟数据包原来是找城内的人，于是它就将数据包送进了城内，再经由城内的交换机帮助下，最终转发到了目的地了。数据包感慨万千的说道：“多谢这一路上，各路大侠的相助！”</p></blockquote><h3 id="10-互相扒皮-–-服务器-与-客户端"><a href="#10-互相扒皮-–-服务器-与-客户端" class="headerlink" title="10 互相扒皮 – 服务器 与 客户端"></a>10 互相扒皮 – 服务器 与 客户端</h3><p>数据包抵达了服务器，服务器肯定高兴呀，正所谓有朋自远方来，不亦乐乎？</p><p>服务器高兴的不得了，于是开始扒数据包的皮！就好像你收到快递，能不兴奋吗？</p><p><img src="/2022/01/07/%E6%95%B0%E6%8D%AE%E5%8C%85%E5%9C%A8%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%BF%83%E8%B7%AF%E5%8E%86%E7%A8%8B/24.png" alt="图片"></p><p>数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。</p><p>接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。</p><p>于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。</p><p>于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。</p><p>服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。</p><p>HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。</p><p>穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。</p><p>最后跳到了客户端的城门把手的路由器，路由器扒开 IP 头部发现是要找城内的人，于是把包发给了城内的交换机，再由交换机转发到客户端。</p><p>客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！</p><p>于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！</p><p>最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring:IoC与AOP</title>
    <link href="/2022/01/03/Spring-IOC%E4%B8%8EAOP/"/>
    <url>/2022/01/03/Spring-IOC%E4%B8%8EAOP/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring-IoC-amp-AOP"><a href="#Spring-IoC-amp-AOP" class="headerlink" title="Spring IoC &amp; AOP"></a>Spring IoC &amp; AOP</h1><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p><strong>IOC（Inverse of Control：控制反转）</strong>是一种设计思想，而不是一个具体的技术实现，IOC的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架管理。IOC 并非 Spring 独有，它在其他语言中也有应用。</p><span id="more"></span><h3 id="为什么叫控制反转？"><a href="#为什么叫控制反转？" class="headerlink" title="为什么叫控制反转？"></a>为什么叫控制反转？</h3><ul><li><strong>控制：</strong>指的是对象创建（实例化、管理）的权力</li><li><strong>反转：</strong>控制权交给外部环境（Spring 框架，IoC容器）</li></ul><p><img src="/2022/01/03/Spring-IOC%E4%B8%8EAOP/frc-365faceb5697f04f31399937c059c162.png" alt="IoC"></p><p>将对象之间相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。</p><p>IoC 容器就像一个工厂，当我们需要创建一个对象的时候，只需要配置好配置文件 / 注解即可，完全不用考虑对象是如何被创建出来的。</p><p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p><p>在 Spring 中，IoC 容器是 Spring 用来实现 IoC 的载体，IoC 容器实际上就是个 Map（Key，Value），Map 中存放的是各种对象。</p><p>SSM 时代一般用 XML 文件来配置Bean，到了 Spring Boot 时代更流行使用注解来配置。</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p><p><img src="/2022/01/03/Spring-IOC%E4%B8%8EAOP/926dfc549b06d280a37397f9fd49bf9d.jpg" alt="SpringAOPProcess"></p><p>目前 Spring AOP 也集成了 AspectJ。</p><h3 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h3><p>Spring AOP 属于运行时增强，而 AspectJ AOP 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
      <category>IOC</category>
      
      <category>AOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM类加载</title>
    <link href="/2021/12/26/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9B%B8%E5%85%B3/"/>
    <url>/2021/12/26/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Java类加载相关"><a href="#1-Java类加载相关" class="headerlink" title="1. Java类加载相关"></a>1. Java类加载相关</h2><span id="more"></span><p>[源自 Java Guide]( 链接: <a href="https://javaguide.cn/java/jvm/class-loading-process/#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B">https://javaguide.cn/java/jvm/class-loading-process/#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B</a>)</p><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>一个类的完整生命周期如下：</p><p><img src="/2021/12/26/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9B%B8%E5%85%B3/01.png" alt="img"></p><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>类加载过程的第一步，主要完成下面三件事：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时的数据结构</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法去这些数据的访问入口。</li></ol><p>虚拟机规范上面这 3 点并不具体，因此是非常灵活的。比如：”通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 <code>ZIP</code> 包中读取（日后出现的 <code>JAR</code>、<code>EAR</code>、<code>WAR</code> 格式的基础）、其他文件生成（典型应用就是 <code>JSP</code>）等等。</p><p><strong>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 <code>loadClass()</code> 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</strong></p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><img src="/2021/12/26/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9B%B8%E5%85%B3/02.png" alt="验证阶段示意图"></p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p><strong>准备阶段时正式为变量分配内存并设置类变量初始化值的阶段</strong>，这些内存都将在方法区中分配，对于该阶段有以下几点需要注意：</p><ol><li>这时候进行内存分配的仅包括类变量（Class Variables，即静态变量，被 <code>static</code> 关键字修饰的变量，只与类相关，因此被称为类变量），而不包括实例变量。实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>从概念上来说，类变量所使用的内存都应该在<strong>方法区</strong>中进行分配。不过有一点需要注意的是：JDK7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。而在 JDK7 之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java 堆中。</li><li>这里所设置的初始值“通常情况”下是数据类型默认的零值（如0，0L，null，false等），比如我们定义了 <code>public static int value = 1</code>，那么 value 变量在准备阶段的初始值是 0 而不是 1（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 final 关键字，那么初始值就会变成 1 了。</li></ol><p><strong>基本数据类型的零值</strong> ： (图片来自《深入理解 Java 虚拟机》第 3 版 7.33 )</p><p><img src="/2021/12/26/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9B%B8%E5%85%B3/03.png" alt="基本数据类型的零值"></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接饮用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。</p><p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用时不够用的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中的所有方法。当需要调用一个类的方法时，只要知道这个方法在方法表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段时执行初始化方法 <code>&lt;clinit&gt; ()</code> 方法的过程，是类加载器的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码（字节码）。</p><blockquote><p>说明：<clinit> () 方法是编译之后就自动生成的</clinit></p></blockquote><p>对于 <code>&lt;clinit&gt; ()</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt; ()</code>方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起多个进程阻塞，并且这种阻塞很难被发现。</p><p>对于初始化阶段，虚拟机严格规范了有且只有 5 种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：</p><ol><li><p>当遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code> 这四条直接码命令时，比如 <code>new</code> 一个类，读取一个静态字段（为被 final 修饰）、或调用一个类的静态方法时。</p><ul><li>当 jvm 执行 <code>new</code> 指令会初始化类。即当程序创建一个类的实例对象。</li><li>当 jvm 执行 <code>getstatic</code> 指令时会初始化类。即程序访问类的静态变量（不是常量，常量会被加载到运行时常量池）.</li><li>当 jvm 执行 <code>putstatic</code> 执行时会初始化类。即程序给类的静态变量赋值。</li><li>当 jvm 执行 <code>invokestatic</code> 指令时会初始化类。即程序调用类的静态方法。</li></ul></li><li><p>使用 <code>java.lang.reflect</code> 包对方法进行方向调用时，如 <code>Class.forname(...)</code>。</p></li><li><p>初始化一个类，如果其父类还没有初始化，则先出发该父类的初始化。</p></li><li><p>当虚拟机启动时，用户需要定义一个要执行的主类（包括 <code>main</code> 方法的那个类），虚拟机会先初始话这个类。</p></li><li><p><code>MethodHandle</code> 和 <code>VarHandle</code> 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，就必须先试用 <code>findStaticVarHandle</code> 来初始化要调用的类。</p></li><li><p>当一个接口定义了 JDK 8 斤加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</p></li></ol><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>卸载类即该类的 Class 对象被 GC。</p><p>卸载类需要满足 3 个要求：</p><ol><li>该类的所有实例对象都已经被 GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已经被 GC</li></ol><p>所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的，但是由我们自定义的类加载器加载的类是可能被卸载的。</p><p>只要想通一点就好了，jdk 自带的 <code>BootstrapClassLoader</code>, <code>ExtClassLoader</code>, <code>AppClassLoader</code> 负责加载 jdk 提供的类，所以它们(类加载器的实例)肯定不会被回收。而我们自定义的类加载器的实例是可以被回收的，所以使用我们自定义加载器加载的类是可以被卸载掉的。</p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
      <category>类加载</category>
      
    </categories>
    
    
    <tags>
      
      <tag>类加载与类加载器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RESTful API</title>
    <link href="/2021/12/17/Restful/RESTful/"/>
    <url>/2021/12/17/Restful/RESTful/</url>
    
    <content type="html"><![CDATA[<h2 id="RESTful-API-规范"><a href="#RESTful-API-规范" class="headerlink" title="RESTful API 规范"></a>RESTful API 规范</h2><h3 id="何为RESTful-API？"><a href="#何为RESTful-API？" class="headerlink" title="何为RESTful API？"></a>何为RESTful API？</h3><p><strong>RESTful API</strong> 也经常被叫做 <strong>REST API</strong>，它是基于 REST 构建的 API。REST 是啥？</p><span id="more"></span><p>REST 的作用就是规范 API 格式，给两个 API 立刻能知道是干什么用的。这就是 REST API 的强大之处</p><figure class="highlight plaintext"><figcaption><span>API</span></figcaption><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs REST">GET    /classes：列出所有班级<br>POST   /classes：新建一个班级<br></code></pre></td></tr></table></figure><p><strong>RESTful API 可以让你看到 URL+Http Method 就知道这个 URL 是干什么的，让你看到了 HTTP 状态码（status code）就知道请求结果如何。</strong></p><p>像咱们在开发过程中设计 API 的时候也应该至少要满足 RESTful API 的最基本的要求（比如接口中尽量使用名词，使用 <code>POST</code> 请求创建资源，<code>DELETE</code> 请求删除资源等等，示例：<code>GET /notes/id</code>：获取某个指定 id 的笔记的信息）。</p><h3 id="解读-REST"><a href="#解读-REST" class="headerlink" title="解读 REST"></a>解读 REST</h3><p><strong>REST</strong> 是 <code>REpresentational State Transfer</code> 的缩写。这个词组的翻译过来就是“<strong>表现层状态转化</strong>”。</p><p>这样理解起来甚是晦涩，实际上 REST 的全称是 <strong>Resource Representational State Transfer</strong> ，直白地翻译过来就是 **“资源”在网络传输中以某种“表现形式”进行“状态转移” **。如果还是不能继续理解，请继续往下看，相信下面的讲解一定能让你理解到底啥是 REST 。</p><p>我们分别对上面涉及到的概念进行解读，以便加深理解，实际上你不需要搞懂下面这些概念，也能看懂我下一部分要介绍到的内容。不过，为了更好地能跟别人扯扯 “RESTful API”我建议你还是要好好理解一下！</p><ul><li><p><strong>资源（Resource）</strong> ：我们可以把真实的对象数据称为资源。一个资源既可以是一个集合，也可以是单个个体。比如我们的班级 classes 是代表一个集合形式的资源，而特定的 class 代表单个个体资源。每一种资源都有特定的 URI（统一资源标识符）与之对应，如果我们需要获取这个资源，访问这个 URI 就可以了，比如获取特定的班级：<code>/class/12</code>。另外，资源也可以包含子资源，比如 <code>/classes/classId/teachers</code>：列出某个指定班级的所有老师的信息</p></li><li><p><strong>表现形式（Representational）</strong>：”资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式比如 <code>json</code>，<code>xml</code>，<code>image</code>,<code>txt</code> 等等叫做它的”表现层/表现形式”。</p></li><li><p><strong>状态转移（State Transfer）</strong> ：大家第一眼看到这个词语一定会很懵逼？内心 BB：这尼玛是啥啊？ 大白话来说 REST 中的状态转移更多地描述的服务器端资源的状态，比如你通过增删改查（通过 HTTP 动词实现）引起资源状态的改变。ps:互联网通信协议 HTTP 协议，是一个无状态协议，所有的资源状态都保存在服务器端。</p></li></ul><p>综合上面的解释，我们总结一下什么是 RESTful 架构：</p><ol><li>每一个 URI 代表一种资源；</li><li>客户端和服务器之间，传递这种资源的某种表现形式比如 <code>json</code>，<code>xml</code>，<code>image</code>，<code>txt</code> 等等；</li><li>客户端通过特定的 HTTP 动词，对服务器端资源进行操作，实现”表现层状态转化”。</li></ol><h3 id="RESTful-API-规范-1"><a href="#RESTful-API-规范-1" class="headerlink" title="RESTful API 规范"></a>RESTful API 规范</h3><h4 id="动作"><a href="#动作" class="headerlink" title="动作"></a>动作</h4><ul><li><code>GET</code>：请求从服务器获取特定的资源。举个例子：<code>GET /classes</code> (获取所有班级)</li><li><code>POST</code>：在服务器上创建一个新的资源。举个例子：<code>POST /classes</code> (创建班级)</li><li><code>PUT</code>：更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：<code>PUT /classes/12</code>（更新编号为 12 的班级）</li><li><code>DELETE</code>：从服务器删除特定的资源。举个例子：<code>DELETE /classes/12</code>（删除编号为 12 的班级）</li><li><code>PATCH</code>：更新服务器上的资源（客户端提供更改的属性，可以看做是部分更新），使用的比较少。</li></ul><h4 id="路径（接口命名）"><a href="#路径（接口命名）" class="headerlink" title="路径（接口命名）"></a>路径（接口命名）</h4><p>路径又称 “终点” (endpoint)，表示 API 的具体网址。实际开发中常见的规范如下：</p><ol><li>网址中不能有动词，只能有名次，API 中的名词也应该使用复数。因为 REST 中的资源网网和数据库的表对应，而数据库中的表都是同种记录的集合。如果 API 调用并不涉及资源（如计算，翻译等操作）的话，可以用动词。比如：<code>GET /calculate?param1=11&amp;param2=33</code> 。</li><li><strong>不用大写字母，建议用中杠 - 不用下杠 _</strong> 。比如邀请码写成 <code>invitation-code</code>而不是 invitation_code 。</li><li><strong>善用版本化 API</strong>。当我们的 API 发生了重大改变而不兼容前期版本的时候，我们可以通过 URL 来实现版本化，比如 <code>http://api.example.com/v1</code>、<code>http://apiv1.example.com</code> 。版本不必非要是数字，只是数字用的最多，日期、季节都可以作为版本标识符，项目团队达成共识就可。</li><li><strong>接口尽量使用名词，避免使用动词。</strong> RESTful API 操作（HTTP Method）的是资源（名词）而不是动作（动词）。</li></ol><p>例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs REST">GET    /classes：列出所有班级<br>POST   /classes：新建一个班级<br>GET    /classes/&#123;classId&#125;：获取某个指定班级的信息<br>PUT    /classes/&#123;classId&#125;：更新某个指定班级的信息（一般倾向整体更新）<br>PATCH  /classes/&#123;classId&#125;：更新某个指定班级的信息（一般倾向部分更新）<br>DELETE /classes/&#123;classId&#125;：删除某个班级<br>GET    /classes/&#123;classId&#125;/teachers：列出某个指定班级的所有老师的信息<br>GET    /classes/&#123;classId&#125;/students：列出某个指定班级的所有学生的信息<br>DELETE /classes/&#123;classId&#125;/teachers/&#123;ID&#125;：删除某个指定班级下的指定的老师的信息<br></code></pre></td></tr></table></figure><p>反例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs REST">/getAllclasses<br>/createNewclass<br>/deleteAllActiveclasses<br></code></pre></td></tr></table></figure><p>理清资源的层次结构，比如业务针对的范围是学校，那么学校会是一级资源:<code>/schools</code>，老师: <code>/schools/teachers</code>，学生: <code>/schools/students</code> 就是二级资源。</p><h4 id="过滤信息"><a href="#过滤信息" class="headerlink" title="过滤信息"></a>过滤信息</h4><p>如果我们在查询的时候需要添加特定条件的话，建议使用 url 参数的形式。比如我们要查询 state 状态为 active 并且 name 为 guidegege 的班级：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs REST">GET    /classes?state=active&amp;name=guidegege<br></code></pre></td></tr></table></figure><p>比如我们要实现分页查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs REST">GET    /classes?page=1&amp;size=10 //指定第1页，每页10个数据<br></code></pre></td></tr></table></figure><h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p><strong>状态码范围：</strong></p><table><thead><tr><th>2xx：成功</th><th>3xx：重定向</th><th>4xx：客户端错误</th><th>5xx：服务器错误</th></tr></thead><tbody><tr><td>200 成功</td><td>301 永久重定向</td><td>400 错误请求</td><td>500 服务器错误</td></tr><tr><td>201 创建</td><td>304 资源未修改</td><td>401 未授权</td><td>502 网关错误</td></tr><tr><td></td><td></td><td>403 禁止访问</td><td>504 网关超时</td></tr><tr><td></td><td></td><td>404 未找到</td><td></td></tr><tr><td></td><td></td><td>405 请求方法不对</td><td></td></tr></tbody></table><h4 id="RESTful-的极致：HATEOAS"><a href="#RESTful-的极致：HATEOAS" class="headerlink" title="RESTful 的极致：HATEOAS"></a>RESTful 的极致：HATEOAS</h4><p><strong>RESTful 的极致是 hateoas ，但是这个基本不会在实际项目中用到。</strong></p><p>上面是 RESTful API 最基本的东西，也是我们平时开发过程中最容易实践到的。实际上，RESTful API 最好做到 Hypermedia，即返回结果中提供链接，连向其他 API 方法，使得用户不查文档，也知道下一步应该做什么。 </p><p>比如，当用户向 <code>api.example.com</code> 的根目录发出请求，会得到这样一个返回结果</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;link&quot;</span>: &#123;<br>  <span class="hljs-attr">&quot;rel&quot;</span>:   <span class="hljs-string">&quot;collection https://www.example.com/classes&quot;</span>,<br>  <span class="hljs-attr">&quot;href&quot;</span>:  <span class="hljs-string">&quot;https://api.example.com/classes&quot;</span>,<br>  <span class="hljs-attr">&quot;title&quot;</span>: <span class="hljs-string">&quot;List of classes&quot;</span>,<br>  <span class="hljs-attr">&quot;type&quot;</span>:  <span class="hljs-string">&quot;application/vnd.yourformat+json&quot;</span><br>&#125;&#125;<br></code></pre></td></tr></table></figure><p>上面代码表示，文档中有一个 <code>link</code> 属性，用户读取这个属性就知道下一步该调用什么 API 了。<code>rel</code> 表示这个 API 与当前网址的关系（collection 关系，并给出该 collection 的网址），<code>href</code> 表示 API 的路径，title 表示 API 的标题，<code>type</code> 表示返回类型 <code>Hypermedia API</code> 的设计被称为<a href="http://en.wikipedia.org/wiki/HATEOAS">HATEOAS (opens new window)</a>。</p><p>在 Spring 中有一个叫做 HATEOAS 的 API 库，通过它我们可以更轻松的创建出符合 HATEOAS 设计的 API。</p>]]></content>
    
    
    <categories>
      
      <category>RESTful</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RESTful</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL的锁</title>
    <link href="/2021/12/17/MySQL%E7%9A%84%E9%94%81/"/>
    <url>/2021/12/17/MySQL%E7%9A%84%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL的锁"><a href="#MySQL的锁" class="headerlink" title="MySQL的锁"></a>MySQL的锁</h1><span id="more"></span><p><img src="/2021/12/17/MySQL%E7%9A%84%E9%94%81/1.png" alt="图片"></p><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><h3 id="怎么用全局锁"><a href="#怎么用全局锁" class="headerlink" title="怎么用全局锁"></a>怎么用全局锁</h3><p>要使用全局锁，则要执行这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs sql">flush tables <span class="hljs-keyword">with</span> read lock<br></code></pre></td></tr></table></figure><p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p><ul><li>对数据的增删改操作，比如 insert，delete，update等语句</li><li>对表结构的更该操作，比如 alter table，drop table等语句</li></ul><p>如果要释放全局锁，则要执行这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlock tables<br></code></pre></td></tr></table></figure><p>当然，如果回话断开了，全局锁会被自动释放。</p><hr><h3 id="全局锁的应用场景是什么？"><a href="#全局锁的应用场景是什么？" class="headerlink" title="全局锁的应用场景是什么？"></a>全局锁的应用场景是什么？</h3><p>全局锁主要应用于<strong>全局逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件和数据与预期不一样。</p><p>举个例子大家就知道了。</p><p>在全库逻辑备份期间，假设不加全局锁的场景，看看会出现什么意外的情况。</p><p>如果在全库逻辑备份期间，有用户购买了一件商品，一般购买商品的业务逻辑是会涉及到多张数据库表的更细，比如在用户表更新该用户的余额，然后在商品表更新被购买的商品的库存。</p><p>那么，有可能出现这样的顺序：</p><ol><li>先备份了用户表的数据；</li><li>然后有用户发起了购买商品的操作；</li><li>接着再备份商品表的数据。</li></ol><p>也就是在备份用户表和商品表之间，有用户购买了商品。</p><p>这种情况下，备份的结果是用户表中该用户的余额并没有扣除，反而商品表中该商品的库存被减少了，如果后面用这个备份文件恢复数据库数据的话，用户钱没少，而库存少了，等于用户白嫖了一件商品。</p><p>所以，在全库逻辑备份期间，加上全局锁，就不会出现上面这种情况了。</p><hr><h3 id="加全局锁会带来什么缺点"><a href="#加全局锁会带来什么缺点" class="headerlink" title="加全局锁会带来什么缺点"></a>加全局锁会带来什么缺点</h3><p>加上全局锁，意味着整个数据库都是只读状态。</p><p>那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。</p><hr><h3 id="既然备份数据库数据的时候，使用全局锁会影响业务，那么有什么方式可以避免？"><a href="#既然备份数据库数据的时候，使用全局锁会影响业务，那么有什么方式可以避免？" class="headerlink" title="既然备份数据库数据的时候，使用全局锁会影响业务，那么有什么方式可以避免？"></a>既然备份数据库数据的时候，使用全局锁会影响业务，那么有什么方式可以避免？</h3><p>有的，如果数据库引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务齿间期间都在使用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p><p>因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。</p><p>备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</p><p>InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</p><p>但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p><hr><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><h3 id="MySQL-表级锁有哪些？具体怎么用的。"><a href="#MySQL-表级锁有哪些？具体怎么用的。" class="headerlink" title="MySQL 表级锁有哪些？具体怎么用的。"></a>MySQL 表级锁有哪些？具体怎么用的。</h3><p>MySQL 里面表级别的锁有这几种：</p><ul><li>表锁；</li><li>元数据锁（MDL）；</li><li>意向锁；</li><li>AUTO-INC 锁；</li></ul><hr><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>如果我们想对学生表（t_student）加表锁，可以使用下面的命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>表级别的共享锁，也就是读锁；<br>lock tables t_student read;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>表级别的独占锁，也就是写锁；<br>lock tables t_stuent wirte;<br></code></pre></td></tr></table></figure><p>需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p><p>也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。「独占锁」是不允许其他线程对表执行读写操作，但自己线程可以。</p><p>要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">unlock tables;<br></code></pre></td></tr></table></figure><p>另外，当会话退出后，也会释放所有表锁。</p><p>不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，<strong>InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁</strong>。</p><hr><h3 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h3><p>再来说说<strong>元数据锁（MDL）</strong>。</p><p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p><ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li><li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li></ul><p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p><p>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</p><p>反之，当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。</p><h4 id="那-MDL-什么时候释放？"><a href="#那-MDL-什么时候释放？" class="headerlink" title="那 MDL 什么时候释放？"></a>那 MDL 什么时候释放？</h4><p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p><p>那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：</p><ol><li>首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；</li><li>然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；</li><li>接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，</li></ol><p>那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</p><h4 id="为什么线程-C-因为申请不到-MDL-写锁，而导致后续的申请读锁的查询操作也会被阻塞？"><a href="#为什么线程-C-因为申请不到-MDL-写锁，而导致后续的申请读锁的查询操作也会被阻塞？" class="headerlink" title="为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？"></a>为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？</h4><p>这是因为申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p><p>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p><hr><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>接着，说说<strong>意向锁</strong>。</p><ul><li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」。</li><li>在使用 InnoDB 引擎的表里对某些记录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」。</li></ul><p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向共享锁」，然后对该记录加独占锁。</p><p>而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p><p>不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先在表上加上意向共享锁，然后对读取的记录加独占锁<br><span class="hljs-keyword">select</span> ... lock <span class="hljs-keyword">in</span> share mode;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>先表上加上意向独占锁，然后对读取的记录加独占锁<br><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> update;<br></code></pre></td></tr></table></figure><p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables … read）和独占表锁（lock tables … write）发生冲突。</strong></p><p>表锁和行锁是满足读读共享、读写互斥、写写互斥的。</p><p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p><p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p><p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p><hr><h3 id="AUTO-INC-锁"><a href="#AUTO-INC-锁" class="headerlink" title="AUTO-INC 锁"></a>AUTO-INC 锁</h3><p>最后，说说 <strong>AUTO-INC 锁</strong>。</p><p>在为某个字段声明 <strong><code>AUTO_INCREMENT</code></strong> 属性时，之后可以在插入数据时，可以不指定该字段的值，数据库会自动给该字段赋值递增的值，这主要是通过 <code>AUTO-INC</code> 锁实现的。</p><p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p><p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p><p>那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是连续递增的。</p><p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p><p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。</p><p>一样也是在插入数据的时候，会为被 <code>AUTO_INCREMENT</code> 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p><p>InnoDB 存储引擎提供了个 innodb_autoinc_lock_mode 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。</p><ul><li>当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁；</li><li>当 innodb_autoinc_lock_mode = 2，就采用轻量级锁；</li><li>当 innodb_autoinc_lock_mode = 1，这个是默认值，两种锁混着用，如果能够确定插入记录的数量就采用轻量级锁，不确定时就采用 AUTO-INC 锁。</li></ul><p>不过，当 innodb_autoinc_lock_mode = 2 是性能最高的方式，但是会带来一定的问题。因为并发插入的存在，在每次插入时，自增长的值可能不是连续的，<strong>这在有主从复制的场景中是不安全的</strong>。</p><hr><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。</p><p>行级锁的类型主要有三类：</p><ul><li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li><li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li><li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li></ul><p>前面也提到，普通的 select 语句是不会对记录加锁的，如果要在查询时对记录加行锁，可以使用下面这两个方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>对读取的记录加共享锁<br><span class="hljs-keyword">select</span> ... lock <span class="hljs-keyword">in</span> share mode;<br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>对读取的记录加独占锁<br><span class="hljs-keyword">select</span> ... <span class="hljs-keyword">for</span> update;<br></code></pre></td></tr></table></figure><p>上面这两条语句必须再一个事务中，当事务提交了，锁就会被释放，因此在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit = 0。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>锁</category>
      
      <category>概述</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL事务</title>
    <link href="/2021/11/17/MySQL%E4%BA%8B%E5%8A%A1/"/>
    <url>/2021/11/17/MySQL%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Mysql事务"><a href="#Mysql事务" class="headerlink" title="Mysql事务"></a>Mysql事务</h1><hr><p><img src="/2021/11/17/MySQL%E4%BA%8B%E5%8A%A1/1.png" alt="图片"></p><h2 id="1-关系型数据库事务的特性"><a href="#1-关系型数据库事务的特性" class="headerlink" title="1. 关系型数据库事务的特性"></a>1. 关系型数据库事务的特性</h2><p>关系型数据库的事物遵行ACID特性</p><ol><li><strong>原子性（Atomicity）</strong>：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性（Consistency）</strong>：执行事务前后，数据保持一致。例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离型（Isolation）</strong>：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间的数据库时独立的；</li><li><strong>持久性（Dur ability）</strong>：一个事物提交后，对数据库的影响应该是持久的，即便数据库发生故障也不应该对其有任何影响。</li></ol><p>MySQL的<strong>InnoDB</strong>引擎处理数据库事务的方式：</p><ol><li><strong>redo log（重做日志）</strong>处理事务的持久性</li><li><strong>undo log（回滚日志）</strong>处理事务的原子性</li><li>通过<strong>行级锁、MVVC</strong>来保证事务的隔离性，InnoDB隔离级别最高可以到<strong>REPEATABLE READ（可重复读）</strong></li><li>保证了持久性、原子性、隔离性，一致性才能得到保障。</li></ol><hr><h2 id="2-并行事务引发的问题"><a href="#2-并行事务引发的问题" class="headerlink" title="2. 并行事务引发的问题"></a>2. 并行事务引发的问题</h2><p>MySQL服务端允许多个客户端连接，所以MySQL存在事务并发执行的情况。</p><p>并发事务是必需的要求，但有可能要导致以下的问题：</p><ol><li><strong>脏读（Dirty Read）</strong>：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这是另一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另一个事务读到这个数据是“脏数据”，根据“脏数据”所做的操作可能是不正确的。</li><li><strong>丢失修改（Lost to modify）</strong>：指在一个事务读取了一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此被称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</li><li><strong>不可重复读（Unrepeatable read）</strong>：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据，那么在第一个书屋中两次读取数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不一样。这样就发生了在一个事务两次读取数据时不一样的情况，因此成为不可重复读。</li><li><strong>幻读（Phantom read）</strong>：幻读与不可重复读累死。他发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生的幻觉一样，所以被称为幻读。</li></ol><p><strong>不可重复读和幻读区别：</strong></p><p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</p><hr><p>下面举例说明，脏读，不可重复读，幻读诗如何发生的：</p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>如果一个事务<strong>「读到」</strong>了另一个<strong>「未提交事务修改过的数据」</strong>，就意味着发生了<strong>「脏读」</strong>现象。</p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取余额数据，然后再执行更新操作，<strong>如果此时事务 A 还没有提交事务，而此时正好事务 B 也从数据库中读取小林的余额数据，那么事务 B 读取到的余额数据是刚才事务 A 更新后的数据，即使没有提交事务。</strong></p><p><img src="/2021/11/17/MySQL%E4%BA%8B%E5%8A%A1/2.png" alt="图片"></p><p>因为事务A是还没有提交事务的，也就是说它随时可能进行回滚操作，如果在上面这种情况事务A触发了回滚，那么事务B刚才得到的数据就是过期的数据，这种现象就被称为脏读。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>在一个事务那多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，着就意味着发生了<strong>「不可重复读」</strong>的现象。</p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取余额数据，然后继续执行代码逻辑处理，<strong>在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读</strong></p><p><img src="/2021/11/17/MySQL%E4%BA%8B%E5%8A%A1/3.png" alt="图片"></p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>在一个事务中多次查询到某个符合查询条件的<strong>「记录数量」</strong>，如果出现前后两次查询的记录数量不一样的情况，这就意味着发生了<strong>「幻读」</strong>现象。</p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库查询账户余额大于 100 万的记录，发现共有 5 条，然后事务 B 也按相同的搜索条件也是查询出了 5 条记录。</p><p><img src="/2021/11/17/MySQL%E4%BA%8B%E5%8A%A1/4.png" alt="图片"></p><p>接下来，事务A插入了一条余额超过100万的记录，并提交了事务，此时数据库超过100万的记录个数就变成了6。</p><p>然后事务 B 再次查询账户余额大于 100 万的记录，此时查询到的记录数量有 6 条，<strong>发现和前一次读到的记录数量不一样了，就感觉发生了幻觉一样，这种现象就被称为幻读。</strong></p><hr><h2 id="事务的隔离级别有哪些？"><a href="#事务的隔离级别有哪些？" class="headerlink" title="事务的隔离级别有哪些？"></a>事务的隔离级别有哪些？</h2><p>前面我们提到，当多个事务并发执行时可能会遇到「脏读、不可重复读、幻读」的现象，这些现象会对事务的一致性产生不同程序的影响。</p><ul><li><strong>脏读</strong>：读到其他事务未提交的数据；</li><li><strong>不可重复读</strong>：前后读取的数据不一致； </li><li><strong>幻读</strong>：前后读取的记录数量不一致。</li></ul><p>这三个现象的严重性排序如下：</p><p><img src="/2021/11/17/MySQL%E4%BA%8B%E5%8A%A1/5.png" alt="图片"></p><p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别约高，性能效率就越低，这四个隔离级别如下：</p><ul><li><strong>读未提交（read uncommitted）</strong>：指一个事务还没有提交时，它做的变更就能被其他事物看到；</li><li><strong>读提交（read commited）</strong>：指一个事务被提交后，它做的变更caineng 被其他事物看到；</li><li><strong>可重复读（repeatable read）</strong>：指一个事务执行过程中看到的数据，一直和这个事务启动时看到的数据时一致的，<strong>MySQL InnoDB引擎默认的隔离界别。</strong></li><li><strong>串行化（serializable）</strong>：回记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必需等前一个事务执行完成，才能继续执行。</li></ul><p>按隔离水平高低排序如下：</p><p><img src="/2021/11/17/MySQL%E4%BA%8B%E5%8A%A1/6.png" alt="图片"></p><p>针对不同的隔离级别，并发事务可能发生的现象也会不同。</p><p><img src="/2021/11/17/MySQL%E4%BA%8B%E5%8A%A1/7.png" alt="图片"></p><p>也就是说：</p><ul><li>在<strong>「读未提交」</strong>隔离级别下，可能发生脏读、不可重复读、幻读现象；</li><li>在<strong>「读提交」</strong>隔离级别下，可能发生不可重复读与幻读现象；</li><li>在<strong>「可重复读」</strong>隔离级别下，可能发生幻读现象；</li><li>在<strong>「串行化」</strong>隔离级别下，三种情况都不会发生；</li></ul><p>所以，<strong>要解决脏读现象，就要升级到「读提交」以上的隔离级别；要解决不可重复读现象，就要升级到「可重复读」的隔离级别</strong>。</p><p>不过，要解决幻读现象不建议将隔离级别升级到<strong>「串行化」</strong>，因为这样会导致数据库在并发事务时性能很差。</p><p><strong>InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它通过next-key lock 锁（行锁和间隙锁的组合）来锁住记录之间的“间隙”和记录本身，防止其他事务在这个记录之间插入新的记录，这样就避免了幻读现象。</strong></p><p>举个具体的例子来说明这四种隔离级别，有一张账户余额表，里面有一条记录：</p><p>然后有两个并发的事务，事务 A 只负责查询余额，事务 B 则会将我的余额改成 200 万，下面是按照时间顺序执行两个事务的行为：</p><p><img src="/2021/11/17/MySQL%E4%BA%8B%E5%8A%A1/8.png" alt="图片"></p><p>在不同的隔离级别下，事务A执行过程中查询到的余额可能会不同；</p><ul><li>在<strong>「读未提交」</strong>隔离级别下，事务B修改余额后，虽然没有提交事务，但是此时余额已经能被A看见了，于是V1 = V2 = V3 =  200万</li><li>在<strong>「读提交」</strong>隔离界别下，事务B修改余额后，因为没有提交事务，所以V1 = 100万，在事务B提交后，事务A可以读取到余额发生的变化，所以V2 = V3 = 200万</li><li>在<strong>「可重复读」</strong>隔离级别下，事务A只能看到启动事务时的数据，所以V1 = V2 = 100万，在事务A提交后，V3 = 200万</li><li>在<strong>「串行化」</strong>隔离级别下，事务B在执行修改操作时，由于此前事务A执行了读操作，所以发生了读写重读，于是事务B会被锁住，直到事务A提交，事务B才会执行，所以V1 = V2 = 100万，V3 = 200万。</li></ul><p>如果实现四种隔离级别：</p><ul><li>对于<strong>「读未提交」</strong>隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li><li>对于<strong>「串行化」</strong>隔离级别的事务来说，通过加读写锁的方式避免并行访问。</li><li>对于<strong>「读提交」</strong>和<strong>「可重复读」</strong>隔离级别的事务来说，他们是通过<strong>Read View</strong>来实现的，他们的区别在于创建Read View的时机不同。<strong>Read View</strong>就像一个数据快照，定格某一刻的数据。<strong>「读提交」</strong>隔离级别是在每个读取数据之前都生成一个Read View，而<strong>「可重复读」</strong>隔离级别是在启动事务时生成一个Read View，然后整个事务都使用这个Read View；</li></ul><hr><h2 id="可重复读隔离级别是如何实现的？"><a href="#可重复读隔离级别是如何实现的？" class="headerlink" title="可重复读隔离级别是如何实现的？"></a>可重复读隔离级别是如何实现的？</h2><p><strong>「可重复读」</strong>隔离级别是启动事务时生成一个 <strong>Read View</strong>，然后整个事务期间都在用这个 Read View。</p><p>想要知道可重复读隔离级别是如何实现的，我们需要了解两个知识：</p><ul><li>Read View 中四个字段作用；</li><li>聚族索引记录中两个跟事务有关的隐藏列；</li></ul><p><img src="/2021/11/17/MySQL%E4%BA%8B%E5%8A%A1/9.png" alt="图片"></p><p>Read View 有四个重要的字段：</p><ul><li><strong>m_ids</strong>：创建Read View时当时数据库中<strong>活跃且未提交的事务的id列表</strong>。</li><li><strong>min_trx_id</strong>：创建Read View时当前数据库中<strong>活跃且未提交事务中最小事务的事务id</strong>，也就是m_ids的最小值。</li><li><strong>max_trx_id</strong>：不是最大值，而是<strong>创建Read View时当前数据库中应该给下一个事务的id值</strong>。</li><li><strong>creator_trx_id</strong>：创建该Read View的事务的id</li></ul><p>知道了 Read View 的字段，还需要了解聚族索引记录中两个隐藏列，加入在账户余额表插入一条小林余额为100万的记录，然后把这两个隐藏列也画出来，记录的示意图如下。</p><p><img src="/2021/11/17/MySQL%E4%BA%8B%E5%8A%A1/10.png" alt="图片"></p><p>对于使用<code>InnoDB</code>存储引擎的数据库表，它的聚族索引记录中都包含下面两个隐藏列：</p><ul><li><strong>trx_id</strong>：当一个事务对某条聚族索引进行改动时，就会<strong>把该事务的事务id记录在trx_id隐藏列里</strong>;</li><li><strong>roll_pointer</strong>：每次对某条聚族索引记录进行改动时，都会把旧版本的记录写入undo日志中，然后<strong>这个隐藏列是个指针，只想每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li></ul><p>了解完这两个知识点后，就可以跟大家说说可重复读隔离级别是如何实现的。</p><p>假设事务 A 和 事务 B 差不多同一时刻启动，那这两个事务创建的 Read View 如下：</p><p><img src="/2021/11/17/MySQL%E4%BA%8B%E5%8A%A1/11.png" alt="图片"></p><p>事务 A 和 事务 B 的 Read View 具体内容如下：</p><ul><li>在事务A的Read View中，它的事务id是51，由于与事务B同时启动，所以此时活跃的事务id列表是【51，52】。活跃的事务id中最小的是事务A，下一个事务id应该是53。</li><li>在事务B的Read View中，它的事务id是52，由于与事务A同时启动，所以此时活跃的事务id列表是【51，52】。活跃的事务id中最小的是事务A，下一个事务id应该是53。</li></ul><p>然后事务A去读账户余额为100万的记录，在找到记录后，它会先看这条记录的trx_id，此时发现trx_id为50，通过事务A的Read View中的m_ids的字段发现，<strong>该记录的事务id并不在活跃事务列表中，且小于事务A的事务id，这意味着这条记录的事务在事务A前就提交过了，所以这条记录对事务A可见</strong>，也就是事务A可以获取到这条记录。</p><p>接着，事务B通过update语句将这条记录修改了，将余额改成200万，这时MySQL会记录相对应的undo log，并以链表的方式串联起来，形成<strong>版本链</strong>，如下图。</p><p><img src="/2021/11/17/MySQL%E4%BA%8B%E5%8A%A1/12.png" alt="图片"></p><p>你可以在上图的「记录字段」看到，由于事务 B 修改了该记录，以前的记录就变成旧版本记录了，于是最新记录和旧版本记录通过链表的方式串起来，而且最新记录的 trx_id 是事务 B 的事务 id。</p><p>然后如果事务 A 再次读取该记录，<strong>发现这条记录的 trx_id 为 52，比自己的事务 id 还大，并且比下一个事务 id 53 小，这意味着，事务 A 读到是和自己同时启动事务的事务 B 修改的数据，这时事务 A 并不会读取这条记录，而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 等于或者小于事务 A 的事务 id 的第一条记录</strong>，所以事务 A 再一次读取到 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。</p><p><strong>「可重复读」</strong>的隔离级别就是在启动时创建了Read View，然后在事务期间读区数据的时候，在找到数据后，先会将该记录的trx_id和该事务的Read View里的字段做个比较：</p><ul><li>如果记录的 trx_id 比该事务的 Read View 中的 creator_trx_id 要小，且不在 m_ids 列表里，这意味着这条记录的事务早就在该事务前提交过了，所以该记录对该事务可见；</li><li>如果记录的 trx_id 比该事务的 Read View 中的 creator_trx_id 要大，且在 m_ids 列表里，这意味着该事务读到的是和自己同时启动的另外一个事务修改的数据，这时就不应该读取这条记录，而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 等于或者小于该事务 id 的第一条记录。</li></ul><p>就是通过这样的方式实现了，「可重复读」隔离级别下在事务期间读到的数据都是事务启动前的记录。</p><p><strong>这种通过记录的版本链来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</strong></p><hr><h2 id="读提交隔离级别是如何实现的？"><a href="#读提交隔离级别是如何实现的？" class="headerlink" title="读提交隔离级别是如何实现的？"></a>读提交隔离级别是如何实现的？</h2><p><strong>「读提交」</strong>隔离级别是在每个<code>select</code>时都会生成一个新的Read View，也意味着，事务期间的多次读区同一条数据，前后两次读取的数据可能会不一致，因为这期间另外一个事务修改了该记录并提交了。</p><p>那读提交隔离级别是怎么实现呢？我们还是以前面的例子来聊聊。</p><p>假设事务 A 和 事务 B 差不多同一时刻启动，然后事务 B 将小林的账户余额修改成了 200 万，但是事务 B 还未提交，这时事务 A 读到的数据，应该还是小林账户余额为 100 万的数据，那具体怎么做到的呢？</p><p><img src="/2021/11/17/MySQL%E4%BA%8B%E5%8A%A1/13.png" alt="图片"></p><p>事务 A 在找到小林这条记录时，会看这条记录的 trx_id，<strong>发现和事务 A 的 Read View 中的 creator_trx_id 要大，而且还在 m_ids 列表里，说明这条记录被事务 B 修改过，而且还可以知道事务 B 并没有提交事务</strong>，因为如果提交了事务，那么这条记录的 trx_id 就不会在 m_ids 列表里。因此，<strong>事务 A 不能读取该记录，而是沿着 undo log 链条往下找</strong>。</p><p>当事务 B 修改数据并提交了事务后，这时事务 A 读到的数据，就是小林账户余额为 200 万的数据，那具体怎么做到的呢？</p><p><img src="/2021/11/17/MySQL%E4%BA%8B%E5%8A%A1/14.png" alt="图片"></p><p>事务 A 在找到小林这条记录时，会看这条记录的 trx_id，<strong>发现和事务 A 的 Read View 中的 creator_trx_id 要大，而且不在 m_ids 列表里，说明该记录的 trx_id 的事务是已经提交过的了，于是事务 A 就可以读取这条记录</strong>，这也就是所谓的读已提交机制。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>事务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL行级锁</title>
    <link href="/2021/09/17/MySQL%E8%A1%8C%E7%BA%A7%E9%94%81/"/>
    <url>/2021/09/17/MySQL%E8%A1%8C%E7%BA%A7%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL的行级锁"><a href="#MySQL的行级锁" class="headerlink" title="MySQL的行级锁"></a>MySQL的行级锁</h1><p>对记录加锁时，<strong>加锁的基本单位是 next-key lock</strong>，它是由记录锁和间隙锁组合而成的，<strong>next-key lock 是前开后闭区间，而间隙锁是前开后开区间</strong>。</p><span id="more"></span><p>但是，next-key lock 会在一些场景下退化成记录锁或间隙锁。</p><p>那到底是什么场景呢？就以下面这个表来进行实验说明。</p><img src="/2021/09/17/MySQL%E8%A1%8C%E7%BA%A7%E9%94%81/1.png" alt="图片" style="zoom:200%;"><p>其中，id 是主键索引（唯一索引），b 是普通索引（非唯一索引），a 是普通的列。</p><p>注意，<strong>MySQL 的版本是 8.0.26，不同版本的加锁规则可能是不同的</strong>。</p><p><img src="/2021/09/17/MySQL%E8%A1%8C%E7%BA%A7%E9%94%81/2.png" alt="图片"></p><hr><h2 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h2><p>当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：</p><ul><li><strong>当查询的记录是存在的，在用「唯一索引进行等值查询」时，next-key lock 会退化成 「记录锁」</strong>。</li><li><strong>当查询的记录不存在时，在用「唯一索引进行等值查询」时，next-key lock会退化成「间隙锁」</strong>。</li></ul><p>接下来用两个案例来说明。</p><h3 id="记录存在"><a href="#记录存在" class="headerlink" title="记录存在"></a>记录存在</h3><p><img src="/2021/09/17/MySQL%E8%A1%8C%E7%BA%A7%E9%94%81/3.png" alt="图片"></p><p>会话1加锁变化过程如下：</p><ol><li>加锁的基本单位时 next-key lock，因此会话1的加锁范围是 (8, 16]；</li><li>但是由于是用唯一索引进行等值查询，且查询的记录存在，所以 <strong>next-key lock 退化为记录锁，因此最后加锁范围是 id = 16 这一行</strong>。</li></ol><p>所以，会话 2 在修改 id = 16 的记录时会被锁住，而会话 3 插入 id = 9 的记录可以被正常执行。</p><h3 id="记录不存在"><a href="#记录不存在" class="headerlink" title="记录不存在"></a>记录不存在</h3><p><img src="/2021/09/17/MySQL%E8%A1%8C%E7%BA%A7%E9%94%81/4.png" alt="图片"></p><p>会话锁1的加锁过程变化如下：</p><ol><li>加锁的基本单位是 next-key lock，因此主键索引 id 的加锁范围是(8, 16];</li><li>但是由于查询记录不存在，next-key lock 退化成间隙锁，因此最终加锁的范围是 (8,16)。</li></ol><p>所以，会话 2 要往这个间隙里面插入 id=9 的记录会被锁住，但是会话 3 修改 id =16 是可以正常执行的，因为 id = 16 这条记录并没有加锁。</p><hr><h2 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="headerlink" title="唯一索引范围查询"></a>唯一索引范围查询</h2><p>范围查询和等值查询的加锁规则是不同的。</p><p>举个例子，下面这两条查询语句，查询的结果虽然是一样的，但是加锁的范围是不一样的。</p><figure class="highlight sql"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_test <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">8</span> <span class="hljs-keyword">for</span> update;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> t_test <span class="hljs-keyword">where</span> id<span class="hljs-operator">&gt;=</span><span class="hljs-number">8</span> <span class="hljs-keyword">and</span> id<span class="hljs-operator">&lt;</span><span class="hljs-number">9</span> <span class="hljs-keyword">for</span> update;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>锁</category>
      
      <category>行级锁</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL日志</title>
    <link href="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/"/>
    <url>/2021/08/18/MySQL%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL三大日志"><a href="#MySQL三大日志" class="headerlink" title="MySQL三大日志"></a>MySQL三大日志</h1><span id="more"></span><p><code>MySQL</code> 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 <code>binlog</code>（归档日志）和事务日志 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）。</p><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/1.png" alt="img"></p><p>今天就来聊聊 <code>redo log</code>（重做日志）、<code>binlog</code>（归档日志）、两阶段提交、<code>undo log</code>（回滚日志）。</p><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p><code>redo log</code>（重做日志）是 InnoDB 引擎所独有的，它让 <code>MYSQL</code> 拥有了崩溃恢复的能力。</p><p>比如 <code>MySQL</code> 实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的持久性与完整性。</p><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/2.png" alt="img"></p><p>MySQL 中数据以页为单位，你查询一条数据，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，回放入到 <code>Buffer Pool</code>中。</p><p>后续的查询都是从 <code>Buffer pool</code> 中找，没有命中再去硬盘加载，减少磁盘 I/O 开销，提升性能。</p><p>更新数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存放着要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p><p>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/03.png" alt="img"></p><p>理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。</p><blockquote><p>小贴士：每条 redo 记录由“表空间号 + 数据页号 + 偏移量 + 修改数据长度 + 具体修改的数据”组成</p></blockquote><h3 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h3><p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p><ul><li><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</li><li><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li><li><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li></ul><p><code>innodb_flush_log_at_trx_commit</code> 参数默认为 1 ，也就是说当事务提交时会调用 <code>fsync</code>对 redo log 进行刷盘</p><p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/04.png" alt="img"></p><p>也就是说，一个没有提交事务的 <code>redo log</code> 记录，也可能会刷盘。</p><p>因为在事务执行过程 <code>redo log</code> 记录是会写入<code>redo log buffer</code> 中，这些 <code>redo log</code> 记录会被后台线程刷盘。</p><p>因为在事务执行过程 <code>redo log</code> 记录是会写入<code>redo log buffer</code> 中，这些 <code>redo log</code> 记录会被后台线程刷盘。</p><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/05.png" alt="img"></p><p>除了后台线程每秒<code>1</code>次的轮询操作，还有一种情况，当 <code>redo log buffer</code> 占用的空间即将达到 <code>innodb_log_buffer_size</code> 一半的时候，后台线程会主动刷盘。</p><p>下面是不同刷盘策略的流程图。</p><h4 id="innodb-flush-log-at-trx-commit-0"><a href="#innodb-flush-log-at-trx-commit-0" class="headerlink" title="innodb_flush_log_at_trx_commit=0"></a>innodb_flush_log_at_trx_commit=0</h4><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/06.png" alt="img"></p><p>为<code>0</code>时，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失。</p><h4 id="innodb-flush-log-at-trx-commit-1"><a href="#innodb-flush-log-at-trx-commit-1" class="headerlink" title="innodb_flush_log_at_trx_commit=1"></a>innodb_flush_log_at_trx_commit=1</h4><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/07.png" alt="img"></p><p>为<code>1</code>时， 只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p><p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。</p><h4 id="innodb-flush-log-at-trx-commit-2"><a href="#innodb-flush-log-at-trx-commit-2" class="headerlink" title="innodb_flush_log_at_trx_commit=2"></a>innodb_flush_log_at_trx_commit=2</h4><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/09.png" alt="img"></p><p>为<code>2</code>时， 只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存（<code>page cache</code>）。</p><p>如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，但是宕机可能会有<code>1</code>秒数据的丢失。</p><h3 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h3><p>硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。</p><p>比如可以配置为一组<code>4</code>个文件，每个文件的大小是 <code>1GB</code>，整个 <code>redo log</code> 日志文件组可以记录<code>4G</code>的内容。</p><p>它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。</p><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/10.png" alt="img"></p><p>在个<strong>日志文件组</strong>中还有两个重要的属性，分别是 <code>write pos、checkpoint</code></p><ul><li><strong>write pos</strong> 是当前记录的位置，一边写一边后移</li><li><strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移</li></ul><p>每次刷盘 <code>redo log</code> 记录到<strong>日志文件组</strong>中，<code>write pos</code> 位置就会后移更新。</p><p>每次 <code>MySQL</code> 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的 <code>redo log</code> 记录，并把 <code>checkpoint</code> 后移更新。</p><p><code>write pos</code> 和 <code>checkpoint</code> 之间的还空着的部分可以用来写入新的 <code>redo log</code> 记录。</p><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/11.png" alt="img"></p><p>如果 <code>write pos</code> 追上 <code>checkpoint</code> ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 <code>redo log</code> 记录，<code>MySQL</code> 得停下来，清空一些记录，把 <code>checkpoint</code> 推进一下。</p><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/12.png" alt="img"></p><h3 id="redo-log-小结"><a href="#redo-log-小结" class="headerlink" title="redo log 小结"></a>redo log 小结</h3><p>相信大家都知道 <code>redo log</code> 的作用和它的刷盘时机、存储形式。</p><p>现在我们来思考一个问题： <strong>只要每次把修改后的数据页直接刷盘不就好了，还有 <code>redo log</code>什么事？</strong></p><p>它们不都是刷盘么？差别在哪里？</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span> Byte = 8bit<br><span class="hljs-number">1</span> KB = <span class="hljs-number">1024</span> Byte<br><span class="hljs-number">1</span> MB = <span class="hljs-number">1024</span> KB<br><span class="hljs-number">1</span> GB = <span class="hljs-number">1024</span> MB<br><span class="hljs-number">1</span> TB = <span class="hljs-number">1024</span> GB<br></code></pre></td></tr></table></figure><p>实际上，数据页大小是<code>16KB</code>，刷盘比较耗时，可能就修改了数据页里的几 <code>Byte</code> 数据，有必要把完整的数据页刷盘吗？</p><p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p><p>如果是写 <code>redo log</code>，一行记录可能就占几十 <code>Byte</code>，只包含表空间号、数据页号、磁盘文件偏移 量、更新值，再加上是顺序写，所以刷盘速度很快。</p><p>所以用 <code>redo log</code> 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。</p><blockquote><p>其实内存的数据页在一定时机也会刷盘，我们把这称为页合并，讲 <code>Buffer Pool</code>的时候会对这块细说</p></blockquote><h2 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h2><p><code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。</p><p>而 <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p><p>不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志。</p><p>那 <code>binlog</code> 到底是用来干嘛的？</p><p>可以说<code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/13.png" alt="img"></p><p><code>binlog</code>会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p><h3 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h3><p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p><ul><li><strong>statement</strong></li><li><strong>row</strong></li><li><strong>mixed</strong></li></ul><p>指定<code>statement</code>，记录的内容是<code>SQL</code>语句原文，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下。</p><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/14.png" alt="img"></p><p>同步数据时，会执行记录的<code>SQL</code>语句，但是有个问题，<code>update_time=now()</code>这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p><p>为了解决这种问题，我们需要指定为<code>row</code>，记录的内容不再是简单的<code>SQL</code>语句了，还包含操作的具体数据，记录内容如下。</p><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/15.png" alt="img"></p><p><code>row</code>格式记录的内容看不到详细信息，要通过<code>mysqlbinlog</code>工具解析出来。</p><p><code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（<strong>假设这张表只有 3 个字段</strong>）。</p><p>这样就能保证同步数据的一致性，通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。</p><p>但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>I/O</code>资源，影响执行速度。</p><p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p><p><code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</p><h3 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h3><p><code>binlog</code> 的写入时机也非常简单，事务执行过程中，先把日志写到 <code>binlog cache</code>，事务提交的时候，再把 <code>binlog cache</code> 写到 <code>binlog</code> 文件中。</p><p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p><p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）。</p><p><code>binlog</code>日志刷盘流程如下</p><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/16.png" alt="img"></p><ul><li><strong>上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></li><li><strong>上图的 fsync，才是将数据持久化到磁盘的操作</strong></li></ul><p><code>write</code>和<code>fsync</code>的时机，可以由参数<code>sync_binlog</code>控制，默认是<code>0</code>。</p><p>为<code>0</code>的时候，表示每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。</p><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/17.png" alt="img"></p><p>虽然性能得到提升，但是机器宕机，<code>page cache</code>里面的 binglog 会丢失。</p><p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行<code>fsync</code>，就如同<strong>binlog 日志刷盘流程</strong>一样。</p><p>最后还有一种折中方式，可以设置为<code>N(N&gt;1)</code>，表示每次提交事务都<code>write</code>，但累积<code>N</code>个事务后才<code>fsync</code>。</p><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/18.png" alt="img"></p><p>在出现<code>I/O</code>瓶颈的场景里，将<code>sync_binlog</code>设置成一个比较大的值，可以提升性能。</p><p>同样的，如果机器宕机，会丢失最近<code>N</code>个事务的<code>binlog</code>日志。</p><h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。</p><p><code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性。</p><p>虽然它们都属于持久化的保证，但是侧重点不同。</p><p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/19.png" alt="img"></p><p>回到正题，<code>redo log</code>与<code>binlog</code>两份日志之间的逻辑不一致，会出现什么问题？</p><p>我们以<code>update</code>语句为例，假设<code>id=2</code>的记录，字段<code>c</code>值是<code>0</code>，把字段<code>c</code>值更新成<code>1</code>，<code>SQL</code>语句为<code>update T set c=1 where id=2</code>。</p><p>假设执行过程中写完<code>redo log</code>日志后，<code>binlog</code>日志写期间发生了异常，会出现什么情况呢？</p><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/20.png" alt="img"></p><p>由于<code>binlog</code>没写完就异常，这时候<code>binlog</code>里面没有对应的修改记录。因此，之后用<code>binlog</code>日志恢复数据时，就会少这一次更新，恢复出来的这一行<code>c</code>值是<code>0</code>，而原库因为<code>redo log</code>日志恢复，这一行<code>c</code>值是<code>1</code>，最终数据不一致。</p><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/21.png" alt="img"></p><p>为了解决两份日志之间的逻辑一致问题，<code>InnoDB</code>存储引擎使用<strong>两阶段提交</strong>方案。</p><p>原理很简单，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>，这就是<strong>两阶段提交</strong>。</p><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/22.png" alt="img"></p><p>使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚该事务。</p><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/23.png" alt="img"></p><p>再看一个场景，<code>redo log</code>设置<code>commit</code>阶段发生异常，那会不会回滚事务呢？</p><p><img src="/2021/08/18/MySQL%E6%97%A5%E5%BF%97/24.png" alt="img"></p><p>并不会回滚事务，它会执行上图框住的逻辑，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据。</p><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p><p>另外，<code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改。</p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
      <category>日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划:最经典LIS单串问题</title>
    <link href="/2021/04/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E7%BB%8F%E5%85%B8LIS%E5%8D%95%E4%B8%B2%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E7%BB%8F%E5%85%B8LIS%E5%8D%95%E4%B8%B2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="动态规划-最经典LIS单串问题"><a href="#动态规划-最经典LIS单串问题" class="headerlink" title="动态规划:最经典LIS单串问题"></a>动态规划:最经典LIS单串问题</h2><h3 id="1-最长上升子序列"><a href="#1-最长上升子序列" class="headerlink" title="1. 最长上升子序列"></a>1. 最长上升子序列</h3><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">出处:leetcode300</a></p><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><span id="more"></span><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br>Copy<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[7,7,7,7,7,7,7]</span><br>输出：<span class="hljs-number">1</span><br>Copy<br></code></pre></td></tr></table></figure><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先我们知道每个数字本身就是一个一位的上升序列，所以长度至少为一。之后我们来找枚举处一些规律，用 <code>i</code> 表示当前位(0开始), <code>dp[]</code> 为到第 <code>i</code> 位(包括)的最长上升子序列:</p><ul><li><code>i=0</code> ，显然最长为1</li><li><code>i=1</code> ，如果 <code>nums[1]&gt;nums[0]</code> ,那么为 <code>dp[1]=2</code> ，否则为仍为1</li><li><code>i=2</code> ，先看与 <code>nums[0]</code> 大小，如果小于 <code>num[0]</code> 则 <code>dp[2]=dp[0]+1</code> ，否则再看与 <code>nums[1]</code> 的大小，如果比 <code>nums[1]</code> 大，那就是 <code>dp[1]+1和dp[0]+1</code> 的最大值。</li></ul><p>我们可以推出这个结论，如果 <code>i=n，nums[i]&gt;nums[j](j&lt;i)</code> ，那么i=n时的最长子序列就是 <code>max(dp[i], dp[j]+1)</code></p><p>由此我们容易写出代码:</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br>        <span class="hljs-keyword">int</span> []dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [len];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            dp[i] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i]&gt;nums[j])&#123;<br>                    dp[i] = Math.<span class="hljs-built_in">max</span>(dp[i], dp[j]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">int</span> max = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i:dp)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;max)&#123;max = i;&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p><a href="https://www.dmxcg.xyz/img/leetcode/result.png"><img src="/2021/04/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E7%BB%8F%E5%85%B8LIS%E5%8D%95%E4%B8%B2%E9%97%AE%E9%A2%98/result.png" alt="result1"></a></p><p>下面我们看一下经典题的改版:</p><hr><h3 id="2-俄罗斯套娃信封问题"><a href="#2-俄罗斯套娃信封问题" class="headerlink" title="2. 俄罗斯套娃信封问题"></a>2. 俄罗斯套娃信封问题</h3><p><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">出处:leetcode354</a></p><p>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 <code>(w, h)</code> 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p><p>请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p><p><strong>说明:</strong><br>不允许旋转信封。</p><p><strong>示例:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: envelopes = <span class="hljs-comment">[<span class="hljs-comment">[5,4]</span>,<span class="hljs-comment">[6,4]</span>,<span class="hljs-comment">[6,7]</span>,<span class="hljs-comment">[2,3]</span>]</span><br>输出: 3 <br>解释: 最多信封的个数为 3, 组合为: <span class="hljs-comment">[2,3]</span> =&gt; <span class="hljs-comment">[5,4]</span> =&gt; <span class="hljs-comment">[6,7]</span>。<br>Copy<br></code></pre></td></tr></table></figure><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>先对二维数组中的首位进行升序排序，如果相等考虑第二位大小，同样是升序排序。之后对第二位使用第一题同样的方法即可以计算出最长上升序列</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxEnvelopes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] envelopes)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(envelopes.length&lt;<span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br>        <span class="hljs-keyword">int</span> m = envelopes.length, n = envelopes[<span class="hljs-number">0</span>].length;<br>        Arrays.sort(envelopes, <span class="hljs-keyword">new</span> Comparator&lt;<span class="hljs-keyword">int</span>[]&gt;()&#123;<span class="hljs-comment">// 就是对二维数组首位排序，如果相等就看第二位</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> []x, <span class="hljs-keyword">int</span> []y)</span></span>&#123;<br>                <span class="hljs-keyword">if</span>(x[<span class="hljs-number">0</span>]==y[<span class="hljs-number">0</span>])<span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>]-y[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>]-y[<span class="hljs-number">0</span>];<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">int</span> []dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m];<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>            dp[i] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;i;j++)&#123;<br>                <span class="hljs-keyword">if</span>(envelopes[i][<span class="hljs-number">1</span>]&gt;envelopes[j][<span class="hljs-number">1</span>]&amp;&amp;envelopes[i][<span class="hljs-number">0</span>]&gt;envelopes[j][<span class="hljs-number">0</span>])&#123;<br>                    dp[i] = Math.max(dp[i], dp[j]+<span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> Arrays.stream(dp).max().getAsInt();<span class="hljs-comment">// 得到dp数组的最大值</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/04/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E7%BB%8F%E5%85%B8LIS%E5%8D%95%E4%B8%B2%E9%97%AE%E9%A2%98/result2.png" alt="result2"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>两题都是动态规划内容中最为经典的单串题型，很适合入门动态规划。另外，两题都可以用二分法更新 <code>j</code> 的位置，可以很大的提升时间效率，在二分法专题将会有更详细的解法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法 动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口与多态（String）</title>
    <link href="/2021/03/28/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81%EF%BC%88String%E4%B8%93%E5%9C%BA%EF%BC%89/"/>
    <url>/2021/03/28/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81%EF%BC%88String%E4%B8%93%E5%9C%BA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="接口与多态-String专场"><a href="#接口与多态-String专场" class="headerlink" title="接口与多态(String专场)"></a>接口与多态(String专场)</h2><p>多态讲的差不多了，下面介绍一些常见常用需要掌握的接口。</p><span id="more"></span><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p>就是一个常见而特殊的接口，一共有几十种方法可以使用</p><p>先看一下如果初始化一个字符串</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs Java">String s1 = <span class="hljs-string">&quot;Runoob&quot;</span>;              <span class="hljs-comment">// String 直接创建</span><br>String s2 = <span class="hljs-string">&quot;Runoob&quot;</span>;              <span class="hljs-comment">// String 直接创建</span><br>String s3 = s1;                    <span class="hljs-comment">// 相同引用</span><br>String s4 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;Runoob&quot;</span>);   <span class="hljs-comment">// String 对象创建</span><br>String s5 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;Runoob&quot;</span>);   <span class="hljs-comment">// String 对象创建</span><br>Copy<br></code></pre></td></tr></table></figure><p>根据学过的知识，我们知道在 <code>JVM</code> 中，地址如下</p><p><a href="https://www.dmxcg.xyz/img/Java/Object/JVM3.jpg"><img src="/2021/03/28/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81%EF%BC%88String%E4%B8%93%E5%9C%BA%EF%BC%89/JVM3.jpg" alt="JVM"></a></p><p><a href="https://www.dmxcg.xyz/img/Java/Object/JVM3.jpg">JVM</a></p><p>我们同样可以这样来初始化 <code>String</code></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">  <span class="hljs-keyword">char</span>[] helloArray = &#123;<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>&#125; ;<br>  <span class="hljs-keyword">String</span> helloString = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(helloArray);<br>Copy<br></code></pre></td></tr></table></figure><p>下面介绍 <code>String</code> 类支持的方法</p><p>我们定义一个字符串 <code>s = &quot;Hello&quot;</code>。</p><h4 id="1-charAt"><a href="#1-charAt" class="headerlink" title="1. charAt()"></a>1. charAt()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">charAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span></span><br><span class="hljs-function">Copy</span><br></code></pre></td></tr></table></figure><p>就是返回 <code>index</code> 索引处的字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">System.out.println(s.charAt(<span class="hljs-number">0</span>));<br>Copy<br></code></pre></td></tr></table></figure><p>结果<br>H</p><h4 id="2-comparaTo-和-compareToIgnoreCase"><a href="#2-comparaTo-和-compareToIgnoreCase" class="headerlink" title="2. comparaTo() 和 compareToIgnoreCase()"></a>2. comparaTo() 和 compareToIgnoreCase()</h4><p><code>comparaTo()</code> 方法用于两个字符串的比较</p><ul><li><p>按字典顺序比较两个字符串。</p><p>int compareTo(String anotherString)</p></li></ul><p>返回值是整型，它是先比较对应字符的大小(ASCII码顺序)，如果第一个字符和参数的第一个字符不等，结束比较，返回他们之间的长度差值，如果第一个字符和参数的第一个字符相等，则以第二个字符和参数的第二个字符做比较，以此类推,直至比较的字符或被比较的字符有一方结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        String str1 = <span class="hljs-string">&quot;Strings&quot;</span>;<br>        String str2 = <span class="hljs-string">&quot;Strings&quot;</span>;<br>        String str3 = <span class="hljs-string">&quot;Strings123&quot;</span>;<br> <br>        <span class="hljs-keyword">int</span> result = str1.compareTo( str2 );<br>        System.out.println(result);<br>      <br>        result = str2.compareTo( str3 );<br>        System.out.println(result);<br>     <br>        result = str3.compareTo( str1 );<br>        System.out.println(result);<br>    &#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff">0<br><span class="hljs-deletion">-3</span><br>3<br>Copy<br></code></pre></td></tr></table></figure><p><code>comparaToIngoreCase()</code> 就是忽略大小写的 <code>comparaTo()</code>。</p><h4 id="3-concat"><a href="#3-concat" class="headerlink" title="3. concat()"></a>3. concat()</h4><p>连接两个字符串</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">    String a = &quot;Hello&quot;;<br>    String b = &quot; World!&quot;;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(a.concat(b));<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">Hello World!<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>实际上和 <code>+</code> 效果一样。</p><h4 id="4-contentEquals"><a href="#4-contentEquals" class="headerlink" title="4. contentEquals()"></a>4. contentEquals()</h4><p>用于将此字符串与指定的 <code>StringBuffer</code> 比较。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> contentEquals(StringBuffer sb)<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>如果该字符串与 <code>sb</code> 字符都相同就返回 <code>true</code> 否则 <code>false</code>。</p><h4 id="5-copyValueOf"><a href="#5-copyValueOf" class="headerlink" title="5. copyValueOf()"></a>5. copyValueOf()</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String copyValueOf(<span class="hljs-keyword">char</span>[] data)<span class="hljs-comment">// 返回指定数组中表示该字符序列的字符串。</span><br><br>或<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String copyValueOf(<span class="hljs-keyword">char</span>[] data, <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span>)<span class="hljs-comment">// 返回指定数组中表示该字符序列的 字符串。 </span><br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>即第一种就是把数组组合成字符串。第二种，就是截取，从 <code>offset</code> 开始的 <code>count</code> 位成为字符串。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">char</span>[] Str1 = &#123;<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>&#125;;<br><span class="hljs-keyword">String</span> Str2 = <span class="hljs-string">&quot;&quot;</span>;<br><br>Str2 = <span class="hljs-keyword">String</span>.<span class="hljs-built_in">copyValueOf</span>(Str1);<br>System.out.<span class="hljs-built_in">println</span>(Str2);<br><br>Str2 = <span class="hljs-keyword">String</span>.<span class="hljs-built_in">copyValueOf</span>(Str1, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>System.out.<span class="hljs-built_in">println</span>(Str2);<br>Copy<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">hello world<br>ell<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h4 id="6-endsWith-和startsWith"><a href="#6-endsWith-和startsWith" class="headerlink" title="6. endsWith()和startsWith()"></a>6. endsWith()和startsWith()</h4><p>endsWith() 方法用于测试字符串是否以指定的后缀结束。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String str1 = <span class="hljs-string">&quot;Hello World&quot;</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str1.ends<span class="hljs-constructor">With(<span class="hljs-string">&quot;rld&quot;</span>)</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str1.ends<span class="hljs-constructor">With(<span class="hljs-string">&quot;abc&quot;</span>)</span>);<br>Copy<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">true</span><br><span class="hljs-keyword">false</span><br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><code>startsWith()</code> 方法用于检测字符串是否以指定的前缀开始。参数方法就和 <code>endsWith()</code> 一样。</p><h4 id="7-equals-和equalsIgnoreCase"><a href="#7-equals-和equalsIgnoreCase" class="headerlink" title="7. equals()和equalsIgnoreCase()"></a>7. equals()和equalsIgnoreCase()</h4><p>老朋友了，<code>String</code> 的 <code>equals()</code> 是重写的，就是判断两个字符串是否相等。</p><p><code>equalsIgnoreCase()</code> 就是忽略大小写的 <code>equals()</code>。</p><h4 id="8-getChars"><a href="#8-getChars" class="headerlink" title="8. getChars()"></a>8. getChars()</h4><p>getChars() 方法将字符从字符串复制到目标字符数组。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void get<span class="hljs-constructor">Chars(<span class="hljs-params">int</span> <span class="hljs-params">srcBegin</span>, <span class="hljs-params">int</span> <span class="hljs-params">srcEnd</span>, <span class="hljs-params">char</span>[] <span class="hljs-params">dst</span>,  <span class="hljs-params">int</span> <span class="hljs-params">dstBegin</span>)</span><br>Copy<br></code></pre></td></tr></table></figure><ul><li>srcBegin – 字符串中要复制的第一个字符的索引。</li><li>srcEnd – 字符串中要复制的最后一个字符之后的索引。</li><li>dst – 目标数组。</li><li>dstBegin – 目标数组中的起始偏移量。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String str1 = <span class="hljs-string">&quot;Hello World&quot;</span>;<br><span class="hljs-built_in">char</span> <span class="hljs-literal">[]</span>str2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span><span class="hljs-literal">[<span class="hljs-number">5</span>]</span>;<br><br>str1.get<span class="hljs-constructor">Chars(0, 5, <span class="hljs-params">str2</span>, 0)</span>;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str2);<br>Copy<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">Hello<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h4 id="9-hashCode"><a href="#9-hashCode" class="headerlink" title="9. hashCode()"></a>9. hashCode()</h4><p>hashCode() 方法用于返回字符串的哈希码。</p><p>计算方法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">s</span>[<span class="hljs-number">0</span>]*<span class="hljs-number">31</span>^(n-<span class="hljs-number">1</span>) + s[<span class="hljs-number">1</span>]*<span class="hljs-number">31</span>^(n-<span class="hljs-number">2</span>) + ... + s[n-<span class="hljs-number">1</span>]<br><span class="hljs-attribute">Copy</span><br></code></pre></td></tr></table></figure><p>在之前我们也说过，<code>hashCode</code> 还是辅助 <code>equals</code> 的。 <code>equals</code> 是 <code>hashCode</code> 相等的充分条件。</p><h4 id="10-indexOf-和lastIndexOf"><a href="#10-indexOf-和lastIndexOf" class="headerlink" title="10. indexOf()和lastIndexOf()"></a>10. indexOf()和lastIndexOf()</h4><ul><li>public int indexOf(int ch): 返回指定字符(ASCII)在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</li><li>public int indexOf(int ch, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</li><li>int indexOf(String str): 返回指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</li><li>int indexOf(String str, int fromIndex): 返回从 fromIndex 位置开始查找指定字符在字符串中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-built_in">int</span> index<span class="hljs-constructor">Of(<span class="hljs-params">int</span> <span class="hljs-params">ch</span> )</span><br><br>或<br><br>public <span class="hljs-built_in">int</span> index<span class="hljs-constructor">Of(<span class="hljs-params">int</span> <span class="hljs-params">ch</span>, <span class="hljs-params">int</span> <span class="hljs-params">fromIndex</span>)</span><br><br>或<br><br><span class="hljs-built_in">int</span> index<span class="hljs-constructor">Of(String <span class="hljs-params">str</span>)</span><br><br>或<br><br><span class="hljs-built_in">int</span> index<span class="hljs-constructor">Of(String <span class="hljs-params">str</span>, <span class="hljs-params">int</span> <span class="hljs-params">fromIndex</span>)</span><br>Copy<br></code></pre></td></tr></table></figure><p><code>lastIndexOf()</code> 就是返回最后一次索引，函数与上面完全相同</p><h4 id="11-intern"><a href="#11-intern" class="headerlink" title="11. intern()"></a>11. intern()</h4><p>看似没用的一个方法，返回值就是字符串，但是它会检查内存池中是否存在该字符串啊，如果没有，添加到内存池再返回其引用，如果有就直接返回该字符串的引用。</p><p>例如</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">String</span> str<span class="hljs-number">1</span> = <span class="hljs-string">&quot;a&quot;</span>;<br><span class="hljs-attribute">String</span> str<span class="hljs-number">2</span> = <span class="hljs-string">&quot;b&quot;</span>;<br><br><span class="hljs-attribute">String</span> str<span class="hljs-number">3</span> = str<span class="hljs-number">1</span> + str<span class="hljs-number">2</span>;<br><span class="hljs-attribute">String</span> str<span class="hljs-number">4</span> = new String(<span class="hljs-string">&quot;ab&quot;</span>);<br><br><span class="hljs-attribute">System</span>.out.println(str<span class="hljs-number">3</span>==<span class="hljs-string">&quot;ab&quot;</span>);<br><span class="hljs-attribute">System</span>.out.println(str<span class="hljs-number">4</span>==<span class="hljs-string">&quot;ab&quot;</span>);<br><span class="hljs-attribute">Copy</span><br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">false</span><br><span class="hljs-keyword">false</span><br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>虽然 <code>str3</code>，<code>str4</code> 的值也是 <code>ab</code> 但是它并不在内存池中，如果使用 <code>intern()</code> 就会添加到内存池</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sas">System.<span class="hljs-meta">out</span>.print<span class="hljs-meta">ln(</span>str3.inte<span class="hljs-meta">rn(</span>)==<span class="hljs-string">&quot;ab&quot;</span>);<br>System.<span class="hljs-meta">out</span>.print<span class="hljs-meta">ln(</span>str4.inte<span class="hljs-meta">rn(</span>)==<span class="hljs-string">&quot;ab&quot;</span>);<br>Copy<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">true</span><br><span class="hljs-keyword">true</span><br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>这个方法并不是持续的，即只有在调用这一刻，它是在内存池中的。</p><h4 id="12-length"><a href="#12-length" class="headerlink" title="12. length()"></a>12. length()</h4><p>就是返回字符串的长度，差不多是最常用的。</p><h4 id="13-regionMatches"><a href="#13-regionMatches" class="headerlink" title="13. regionMatches()"></a>13. regionMatches()</h4><p><code>regionMatches()</code> 方法用于检测两个字符串在一个区域内是否相等。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">regionMatches</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> ignoreCase,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-keyword">int</span> toffset,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-keyword">String</span> other,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-keyword">int</span> ooffset,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-keyword">int</span> len)</span></span><br><span class="hljs-function">Copy</span><br></code></pre></td></tr></table></figure><ul><li><p>ignoreCase – 如果为 true，则比较字符时忽略大小写。</p></li><li><p>toffset – 此字符串中子区域的起始偏移量。</p></li><li><p>other – 字符串参数。</p></li><li><p>ooffset – 字符串参数中子区域的起始偏移量。</p></li><li><p>len – 要比较的字符数。</p><p>String s1 = “Hello World”;<br>String s2 = “World”;</p><p>System.out.println(s1.regionMatches(s1.indexOf(“W”), s2, 0, 5));</p></li></ul><p>结果</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">true</span><br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h4 id="14-replace"><a href="#14-replace" class="headerlink" title="14. replace()"></a>14. replace()</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> String replace(<span class="hljs-type">char</span> searchChar, <span class="hljs-type">char</span> newChar)  <br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>替换所有 <code>searchChar</code> 字符为 <code>newChar</code></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">String s1 = &quot;Hello World&quot;;<br><br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s1.replace(<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>));<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">HellO WOrld<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h4 id="15-subSequence"><a href="#15-subSequence" class="headerlink" title="15. subSequence()"></a>15. subSequence()</h4><p>subSequence() 方法返回一个新的字符序列，它是此序列的一个子序列。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public CharSequence sub<span class="hljs-constructor">Sequence(<span class="hljs-params">int</span> <span class="hljs-params">beginIndex</span>, <span class="hljs-params">int</span> <span class="hljs-params">endIndex</span>)</span><br>Copy<br></code></pre></td></tr></table></figure><ul><li><p>beginIndex – 起始索引（包括）。</p></li><li><p>endIndex – 结束索引（不包括）。</p><p>String s1 = “Hello World”;</p><p>System.out.println(s1.subSequence(s1.indexOf(“H”), s1.indexOf(“ “)));</p></li></ul><p>结果</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">Hello<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>返回值是一个 <code>CharSequence</code> 字符序列，是 <code>String</code> 的超类</p><h4 id="16-substring"><a href="#16-substring" class="headerlink" title="16. substring()"></a>16. substring()</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> String substring(<span class="hljs-type">int</span> beginIndex)<br><br>或<br><br><span class="hljs-built_in">public</span> String substring(<span class="hljs-type">int</span> beginIndex, <span class="hljs-type">int</span> endIndex)<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><ul><li>beginIndex – 起始索引（包括）, 索引从 0 开始。</li><li>endIndex – 结束索引（不包括）。</li></ul><p>用法和上面差不多</p><h4 id="17-toCharArray"><a href="#17-toCharArray" class="headerlink" title="17. toCharArray()"></a>17. toCharArray()</h4><p>转换为字符数组，很实用的一个类</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String s1 = <span class="hljs-string">&quot;Hello World&quot;</span>;<br><br><span class="hljs-built_in">char</span> <span class="hljs-literal">[]</span>a = s1.<span class="hljs-keyword">to</span><span class="hljs-constructor">CharArray()</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">char</span> i:a)&#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.print(i+<span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">H</span> e l l o   W o <span class="hljs-built_in">r</span> l d <br><span class="hljs-built_in">Copy</span><br></code></pre></td></tr></table></figure><p>PS: Java中，字符串是不能直接遍历进行修改的。</p><h4 id="18-toLowerCase-和toUpperCase"><a href="#18-toLowerCase-和toUpperCase" class="headerlink" title="18. toLowerCase()和toUpperCase()"></a>18. toLowerCase()和toUpperCase()</h4><p>顾名思义，就是把字符串中所有字符转换为小/大写</p><h4 id="19-trim"><a href="#19-trim" class="headerlink" title="19. trim()"></a>19. trim()</h4><p>用于删除字符串首尾的空白符</p><h4 id="20-valueOf"><a href="#20-valueOf" class="headerlink" title="20. valueOf()"></a>20. valueOf()</h4><p><code>valueOf</code> 就是让各种形式的参数变为字符串形式。</p><ul><li>valueOf(boolean b): 返回 boolean 参数的字符串表示形式。.</li><li>valueOf(char c): 返回 char 参数的字符串表示形式。</li><li>valueOf(char[] data): 返回 char 数组参数的字符串表示形式。</li><li>valueOf(char[] data, int offset, int count): 返回 char 数组参数的特定子数组的字符串表示形式。</li><li>valueOf(double d): 返回 double 参数的字符串表示形式。</li><li>valueOf(float f): 返回 float 参数的字符串表示形式。</li><li>valueOf(int i): 返回 int 参数的字符串表示形式。</li><li>valueOf(long l): 返回 long 参数的字符串表示形式。</li><li>valueOf(Object obj): 返回 Object 参数的字符串表示形式。</li></ul><h4 id="21-contains"><a href="#21-contains" class="headerlink" title="21. contains()"></a>21. contains()</h4><p>contains() 方法用于判断字符串中是否包含指定的字符或字符串。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> contains(CharSequence chars)<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h4 id="22-isEmpty"><a href="#22-isEmpty" class="headerlink" title="22. isEmpty()"></a>22. isEmpty()</h4><p>就是判读字符串是否为空。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> isEmpty()<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><h4 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h4><p>常用的字符串方法基本就这么多，还有一些关于正则表达式的部分方法我们放在正则表达式专题细嗦。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客的创建与使用</title>
    <link href="/2021/03/27/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/03/27/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo博客的创建与使用"><a href="#hexo博客的创建与使用" class="headerlink" title="hexo博客的创建与使用"></a>hexo博客的创建与使用</h1><h2 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1.安装node.js"></a><strong>1.安装node.js</strong></h2><p><a href="https://nodejs.org/en/">下载地址</a></p><p><strong>LTS</strong>为长期支持版</p><p>命令行中键入<code>node -v</code>与<code>npm -v</code>查看是否安装完成，以及是否存在与环境变量。</p><p>npm是一种包管理器</p><span id="more"></span><h2 id="2-安装cnpm"><a href="#2-安装cnpm" class="headerlink" title="2. 安装cnpm"></a><strong>2. 安装cnpm</strong></h2><p>cnpm是淘宝的国内镜像源，为了安装hexo更加快速</p><figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">npm install -g cnpm --registry=https:<span class="hljs-regexp">//</span>registry.npm.taobao.org<br>Copy<br></code></pre></td></tr></table></figure><p>命令行中键入<code>cnpm -v</code>查看是否安装完成，以及是否存在与环境变量。</p><h2 id="3-安装hexo框架"><a href="#3-安装hexo框架" class="headerlink" title="3. 安装hexo框架"></a><strong>3. 安装hexo框架</strong></h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">cnpm install -<span class="hljs-keyword">g</span> hexo-<span class="hljs-keyword">cli</span><br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>命令行中键入<code>hexo -v</code>查看是否安装完成，以及是否存在与环境变量。</p><h2 id="4-在blog文件夹中创建博客"><a href="#4-在blog文件夹中创建博客" class="headerlink" title="4. 在blog文件夹中创建博客"></a><strong>4. 在blog文件夹中创建博客</strong></h2><p>所有操作都在blog中，实在解决不了错误，就直接删掉</p><p><strong>以下一切操作在blog文件夹中的命令行执行</strong></p><p><strong>初始化hexo</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span><br>Copy<br></code></pre></td></tr></table></figure><p><strong>启动hexo</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">hexo s<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>即可以在localhost:4000本地访问博客</p><p><strong>新建blog</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">hexo <span class="hljs-keyword">new</span> TitleName<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>TitleName 为文章名</p><p>bolg用md编辑器编写, UNIX也可以直接insert形式编写</p>]]></content>
    
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异常处理</title>
    <link href="/2021/03/19/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2021/03/19/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Java-异常处理"><a href="#Java-异常处理" class="headerlink" title="Java 异常处理"></a>Java 异常处理</h2><h3 id="1-异常分类"><a href="#1-异常分类" class="headerlink" title="1. 异常分类"></a>1. 异常分类</h3><p><img src="/2021/03/19/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/chain-20220129103023767.png" alt="异常"></p><p>如果，<code>Error</code> 类层次描述了Java运行时系统的内部错误和资源耗尽错误。这种内部错误，除了通知用户并尽力妥善地终止程序外，你几乎无能为力，这种情况很少出现。</p><span id="more"></span><p>重点关注 <code>Exception</code> 层次结构。两个分支 <code>RuntimeException</code> 表示由编程错误导致的异常，如果程序没有问题，但由于像I/O错误这类问题导致的异常。</p><p><code>RuntimeException</code> 的异常包括以下问题：</p><ul><li>错误的强制类型转换。</li><li>数组访问越界。</li><li>访问null指针</li></ul><p>不是 <code>RuntimeException</code> 的异常包括:</p><ul><li>试图超越文件末尾继续读取数据。</li><li>试图打开一个不存在的文件。</li><li>试图根据给点的字符串查找Class对象，而这个字符串表示的类并不存在。</li></ul><h3 id="2-抛出异常"><a href="#2-抛出异常" class="headerlink" title="2. 抛出异常"></a>2. 抛出异常</h3><p>如果遇到了无法处理的情况，Java方法可以抛出一个一个异常。方法不仅告诉编译器要返回什么值，话要告诉编译器将要返回什么值。比如读取文件时，抛出 <code>FileNotFoundStream</code> 异常可以处理文件无法找到的情况。</p><p>抛出异常的一个简单的例子</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">divide</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;除数不能为0&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> a/b;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    divide(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    System.out.println(<span class="hljs-string">&quot;continue&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果是：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Exception</span> <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.<span class="hljs-keyword">Exception</span>: 除数不能为<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>我们发现这个并没有打印接下来的，抛出异常后就直接结束的程序，这也说明如果能自己解决的问题，如果抛出异常导致中止程序反而得不偿失。</p><p>在实际情况中，我们往往有很多属性是Java内置 <code>Exception</code> 所预料不到的，但是确实是不应该发生的，这时候我们应该自己定义异常。</p><p>举个例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// GenderException.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenderException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>&#123;<span class="hljs-comment">// 继承Expection的性别异常</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GenderException</span><span class="hljs-params">(String msg)</span></span>&#123;<br>        <span class="hljs-keyword">super</span>(msg);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// Person.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String gender;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String g, String n)</span></span>&#123;<br>        gender = g;<br>        name = n;<br>    &#125;<br>    <span class="hljs-function">String <span class="hljs-title">getGender</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> gender;<br>    &#125;<br>    <span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// WashRoom.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WashRoom</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">woman</span><span class="hljs-params">(Person p)</span> <span class="hljs-keyword">throws</span> GenderException</span>&#123;<br>        <span class="hljs-keyword">if</span>(p.getGender().equals(<span class="hljs-string">&quot;女&quot;</span>))&#123;<br>            System.out.println(<span class="hljs-string">&quot;欢迎光临&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> GenderException(<span class="hljs-string">&quot;男士止步！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// test.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> GenderException </span>&#123;<br>        Person XiaoMing = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;男&quot;</span>, <span class="hljs-string">&quot;小明&quot;</span>);<br>        WashRoom washRoom = <span class="hljs-keyword">new</span> WashRoom();<br>        washRoom.woman(XiaoMing);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> test<span class="hljs-selector-class">.wash</span><span class="hljs-selector-class">.GenderException</span>: 男士止步！<br></code></pre></td></tr></table></figure><p>就抛出了自己定义的错误。</p><h3 id="3-捕捉异常"><a href="#3-捕捉异常" class="headerlink" title="3. 捕捉异常"></a>3. 捕捉异常</h3><p>我们来看一个简单的捕捉异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        System.out.println(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>);<br>    &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>        e.printStackTrace();<span class="hljs-comment">// 打印异常信息</span><br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;finally&quot;</span>);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;continue&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java">java.lang.ArithmeticException: / by zero<br>    at test.Catch.test.main(test.java:<span class="hljs-number">7</span>)<br><span class="hljs-keyword">finally</span><br><span class="hljs-keyword">continue</span><br></code></pre></td></tr></table></figure><p>我们看到它打印了异常信息，也打印出了接下来的内容。要注意，虽然从打印的内容来看，<code>finally</code> 可有可无，实际上，<code>finally</code> 语句块是不论异常是否发生，都会执行的，也起到了释放 <code>try</code> 资源的作用。</p><p>我们也发现，捕捉异常的话，代码是可以继续运行的，所以为了线程能持续运行，在不危害数据的情况下，尽量去捕捉异常，可以让进程继续下去。</p><p>在 <code>catch</code> 语句中，用 <code>Exception</code> 可以捕捉所有的异常，也可以捕捉单个异常，包括自己写的异常，一个 <code>try</code> 语句可以匹配多个异常，也可以在catch中再抛出异常，形成异常链，终止程序(finally仍会执行)。</p><h3 id="try-with-Resources语句"><a href="#try-with-Resources语句" class="headerlink" title="try-with-Resources语句"></a>try-with-Resources语句</h3><p>带有资源的try语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">try</span>(Resource res = ...)<br>&#123;<br>    work with res<br>&#125;<br></code></pre></td></tr></table></figure><p>try结束会自动调用 <code>res.close()</code> ，不论是否触发异常。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口与多态-Map</title>
    <link href="/2021/03/08/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81-Map/"/>
    <url>/2021/03/08/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81-Map/</url>
    
    <content type="html"><![CDATA[<h2 id="接口与多态-Map"><a href="#接口与多态-Map" class="headerlink" title="接口与多态(Map)"></a>接口与多态(Map)</h2><h3 id="1-HashMap"><a href="#1-HashMap" class="headerlink" title="1. HashMap"></a>1. HashMap</h3><p>前一篇也说过，<code>HashMap</code> 是基于哈希表的一种容器，用的是数组加链表的结构，根据源码得到的结构如下:</p><span id="more"></span><p><a href="https://www.dmxcg.xyz/img/Java/Map/hash.png"><img src="/2021/03/08/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81-Map/hash.png" alt="HashMap结构"></a></p><p>数组的 <code>HashMap</code> 的主体，链表是解决哈希冲突的方式，而且由于添加查找的数组如果是有冲突用链表表示的话，时间复杂度会比直接查找高一些，所以链表越少越好，即冲突越少越好，一个适合的哈希函数就非常重要。</p><p><code>HashMap</code> 的默认大小为16，加载因子为0.75, 即到了12就会扩展数组。</p><p>常规构造器并没有将 <code>table</code> 数组构造好，在 <code>put</code> 函数时，发现没有 <code>table</code>数组，才会构建 <code>table</code> 数组。</p><p>查看一下几个关键函数的源码：</p><p><strong>put</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>        <span class="hljs-comment">//如果table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间），入参为threshold，</span><br>        <span class="hljs-comment">//此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16)</span><br>        <span class="hljs-keyword">if</span> (table == EMPTY_TABLE) &#123;<br>            inflateTable(threshold);<br>        &#125;<br>       <span class="hljs-comment">//如果key为null，存储位置为table[0]或table[0]的冲突链上</span><br>        <span class="hljs-keyword">if</span> (key == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> putForNullKey(value);<br>        <span class="hljs-keyword">int</span> hash = hash(key);<span class="hljs-comment">//对key的hashcode进一步计算，确保散列均匀</span><br>        <span class="hljs-keyword">int</span> i = indexFor(hash, table.length);<span class="hljs-comment">//获取在table中的实际位置</span><br>        <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-keyword">null</span>; e = e.next) &#123;<br>        <span class="hljs-comment">//如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value</span><br>            Object k;<br>            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;<br>                V oldValue = e.value;<br>                e.value = value;<br>                e.recordAccess(<span class="hljs-keyword">this</span>);<br>                <span class="hljs-keyword">return</span> oldValue;<br>            &#125;<br>        &#125;<br>        modCount++;<span class="hljs-comment">//保证并发访问时，若HashMap内部结构发生变化，快速响应失败</span><br>        addEntry(hash, key, value, i);<span class="hljs-comment">//新增一个entry</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>inflateTable</code> 这个方法用于为主干数组 <code>table</code> 在内存中分配存储空间，通过 <code>roundUpToPowerOf2(toSize)</code> 可以确保 <code>capacity</code> 为大于或等于 <code>toSize</code> 的最接近 <code>toSize</code> 的二次幂，比如 <code>toSize=13</code> ,则 <code>capacity=16;to_size=16,capacity=16;to_size=17,capacity=32</code> .</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inflateTable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> toSize)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> capacity = roundUpToPowerOf2(toSize);<span class="hljs-comment">//capacity一定是2的次幂</span><br>        <span class="hljs-comment">/**此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值，</span><br><span class="hljs-comment">        capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1 */</span><br>        threshold = (<span class="hljs-keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="hljs-number">1</span>);<br>        table = <span class="hljs-keyword">new</span> Entry[capacity];<br>        initHashSeedAsNeeded(capacity);<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>Hash</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**这是一个神奇的函数，用了很多的异或，移位等运算</span><br><span class="hljs-comment">对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀*/</span><br><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> h = hashSeed;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != h &amp;&amp; k <span class="hljs-keyword">instanceof</span> String) &#123;<br>            <span class="hljs-keyword">return</span> sun.misc.Hashing.stringHash32((String) k);<br>        &#125;<br><br>        h ^= k.hashCode();<br><br>        h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>        <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>    &#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回数组下标</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>加入 <code>Map</code> 的具体流程如下:</p><p><a href="https://www.dmxcg.xyz/img/Java/Map/hash2.png"><img src="/2021/03/08/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81-Map/hash2.png" alt="具体流程"></a></p><p>把自己写的类放入 <code>HashMap</code> 一定要写 <code>Hashcode</code> 方法和 <code>equals</code> 方法，这样才能成功的判断并放入。</p><p><a href="https://www.dmxcg.xyz/img/Java/Map/hash3.png"><img src="/2021/03/08/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81-Map/hash3.png" alt="put方法"></a></p><p><code>HashMap</code> 也实现了 <code>Cloneable</code> 和 <code>Serializable</code> 表示可以可以复制和JVM序列化</p><p>下面看一下 <code>HashMap</code> 的常见用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">// 判断数组中每个数出现了几次</span><br>    HashMap&lt;Integer, Integer&gt; hashMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">int</span> []nums = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [<span class="hljs-number">10</span>];<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        nums[i] = (<span class="hljs-keyword">int</span>)((Math.random()*<span class="hljs-number">10</span>));<br>        System.out.print(nums[i]+ <span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<span class="hljs-comment">// 初始化数组</span><br><br>    System.out.println();<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num:nums)&#123;<br>        <span class="hljs-keyword">if</span>(!hashMap.containsKey(num))&#123;<span class="hljs-comment">// 是否包含Key</span><br>            hashMap.put(num, <span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            hashMap.compute(num, (key,value)-&gt;value+=<span class="hljs-number">1</span>);<span class="hljs-comment">// lambda 表达式，表示value自增1</span><br>        &#125;<br>    &#125;<br><br>    System.out.println(hashMap);<br>    System.out.println(hashMap.get(<span class="hljs-number">5</span>));<span class="hljs-comment">// 得到Key的值</span><br><br>    hashMap.remove(<span class="hljs-number">5</span>);<br>    System.out.println(hashMap);<br><br>    System.out.println(hashMap.size());<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">7 6 0 3 2 5 2 2 5 2 <br>&#123;<span class="hljs-attribute">0</span>=1, <span class="hljs-attribute">2</span>=4, <span class="hljs-attribute">3</span>=1, <span class="hljs-attribute">5</span>=2, <span class="hljs-attribute">6</span>=1, <span class="hljs-attribute">7</span>=1&#125;<br>2<br>&#123;<span class="hljs-attribute">0</span>=1, <span class="hljs-attribute">3</span>=1, <span class="hljs-attribute">5</span>=2, <span class="hljs-attribute">6</span>=1, <span class="hljs-attribute">7</span>=1&#125;<br>5<br>Copy<br></code></pre></td></tr></table></figure><h3 id="日后再更新…"><a href="#日后再更新…" class="headerlink" title="日后再更新…."></a>日后再更新….</h3>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口与多态-Set</title>
    <link href="/2021/03/06/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81-Set/"/>
    <url>/2021/03/06/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81-Set/</url>
    
    <content type="html"><![CDATA[<h2 id="接口与多态-Set"><a href="#接口与多态-Set" class="headerlink" title="接口与多态(Set)"></a>接口与多态(Set)</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>通过哈希码对集合数组进行内部排序，和添加的顺序无关(如果是普通数会根据hash码内部排序)。下面介绍一下基本使用方法。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    HashSet&lt;String&gt; hash = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>    hash.add(<span class="hljs-string">&quot;一&quot;</span>);<br>    hash.add(<span class="hljs-string">&quot;二&quot;</span>);<br>    hash.add(<span class="hljs-string">&quot;三&quot;</span>);<br>    System.out.println(hash); <span class="hljs-comment">// [一, 三, 二]</span><br>    System.out.println(hash.contains(<span class="hljs-string">&quot;三&quot;</span>)); <span class="hljs-comment">// 是否包含 &quot;三&quot; // true</span><br>    hash.remove(<span class="hljs-string">&quot;三&quot;</span>);<br>    System.out.println(hash); <span class="hljs-comment">// [一, 二]</span><br>    System.out.println(hash.size());<span class="hljs-comment">// set的容量 // 2</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>HashSet</code> 本质上是一个 <code>HashMap</code>, 对集合的迭代次序没有任何保证; 特别是，它不能保证订单会随着时间的推移保持不变。这个类允许 <code>null</code> 元素。虽然 <code>HashSet</code> 在很少量 <code>Integer</code> 数据会自动通过哈希码排序，但是对于一般的数据完全不能保证数据的顺序。</p><p>放入 <code>HashSet</code> 的类必须实现 <code>HashCode</code> 方法，这也是 <code>HashSet</code> 进行存放数据的基础。</p><p><code>HashSet</code> 默认创建一个大小为 16 的容器，加载因子是 0.75 ，意思是到 12 个元素，它会自动扩容，扩容成的大小都是 2 的幂， 这些都可以在构造函数时候进行改变。</p><p><code>HashSet</code> 实现了 <code>Cloneable</code> 和 <code>Serializable</code> 说明是可以克隆和序列化的。</p><p><code>HashSet</code> 线程并不安全，和 <code>HashMap</code> 一样。<code>java.util.concurrent</code> 包下的 <code>ConcurrentHashMap</code> 类是线程安全的。</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p><code>TreeSet</code> 是有序的 <code>set</code> 集合，放入 <code>TreeSet</code> 中的数据会自动内部排序，不同于 <code>HashSet</code> 基于哈希表的结构，<code>TreeSet</code> 是基于二叉树的，这也使得 <code>TreeSet</code> 并不支持放入 <code>null</code> 值。</p><p>由于 <code>TreeSet</code> 是可以放入类结构，这就意味着如果我们要将自己的类通过 <code>TreeSet</code> 存储，那么这个类必须实现 <code>Comparable</code> 接口。</p><p><code>TreeSet</code> 和 <code>HashSet</code> 一样，实现了 <code>Cloneable</code> 接口与 <code>Serializable</code> 接口，保证了可被复制，也可以序列化的特性。</p><p><code>TreeSet</code> 是基于 <code>TreeMap</code> 实现的，使用的是 <code>NavigableMap</code> 来进行数据的存放，使用方法和 <code>HashSet</code> 差不多，但是内部结构是截然不同的，它们适用的领域也是不相同的</p><p>下面简单写一下 <code>TreeSet</code> 的部分方法，更多具体方法可以查找JDK文档。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    TreeSet&lt;Integer&gt; treeSet = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();<br>    treeSet.add(<span class="hljs-number">1</span>);<br>    treeSet.add(<span class="hljs-number">3</span>);<br>    treeSet.add(<span class="hljs-number">2</span>);<br>    System.out.println(treeSet);<span class="hljs-comment">// [1, 2, 3]</span><br><br>    treeSet.remove(<span class="hljs-number">3</span>);<br>    System.out.println(treeSet);<span class="hljs-comment">// [1, 2]</span><br><br>    System.out.println(treeSet.contains(<span class="hljs-number">3</span>));<span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是 <code>TreeSet</code> 同样是 <code>fail-fast</code> 的，是线程不安全的。</p><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>看名字就知道，也是一个的哈希结构，本身也是继承 <code>HashSet</code> 而来的，也实现了和 <code>HashSet</code> 一样的 <code>Serializable</code> 和 <code>Cloneable</code> 接口。默认也为加载因素为0.75，大小为16的容器。</p><p><code>LinkedHashSet</code> 是一个基于哈希表和双向链表的接口，增加删除等方法都是基于链表结构的，所以它的存储结构在逻辑上是有序的，迭代时获取元素的顺序等于元素的添加顺序，注意这里不是访问顺序。</p><p><code>LinkedHashSet</code> 在添加了一个全局的双向链表的结构，所以相比较于 <code>HashSet</code> 而言，查找慢，添加元素稍慢，但迭代访问快，性能更强。也是基于哈希函数查看容器中是否存在，如果不存在才会添加。</p><p>使用方法基本无异，唯一区别就是迭代获取元素的顺序是和添加的顺序一致，这里就不在赘述代码了。</p><p>同样的，<code>LinkedHashSet</code> 也是 <code>fail-fast</code> 线程不安全的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>三种结构各有各的优势，虽然在方法上大相近同，但在底层区别还是不晓得，在实际使用中要通过对源码的分析来确定使用哪个类，才能获得更高的性能。</p><p>三种结构虽然都是线程不安全的，但是原理也都是线程安全类的基础，需要牢牢掌握。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口与多态-List</title>
    <link href="/2021/03/05/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81-List/"/>
    <url>/2021/03/05/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81-List/</url>
    
    <content type="html"><![CDATA[<h2 id="接口与多态-List"><a href="#接口与多态-List" class="headerlink" title="接口与多态(List)"></a>接口与多态(List)</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><code>ArrayList</code> 是基于数组实现的，是一个动态数组，其容量能自动增长。</p><!--more---><p><code>ArrayList</code> 不是线程安全的，只能用在单线程环境下，多线程环境下可以考虑用 <code>Collections.synchronizedList(List l)</code> 函数返回一个线程安全的 <code>ArrayList</code> 类，也可以使用 <code>concurrent</code> 并发包下的 <code>CopyOnWriteArrayList</code> 类。</p><p><code>ArrayList</code> 实现了 <code>Serializable</code> 接口，因此它支持序列化，能够通过序列化传输，实现了 <code>RandomAccess</code> 接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了 <code>Cloneable</code> 接口，能被克隆。</p><p>每个 <code>ArrayList</code> 实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小。随着向 <code>ArrayList</code> 中不断添加元素，其容量也自动增长。自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造 <code>ArrayList</code> 时指定其容量。在添加大量元素前，应用程序也可以使用 <code>ensureCapacity</code> 操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。</p><p>注意，此实现不是同步的。如果多个线程同时访问一个 <code>ArrayList</code> 实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。</p><h4 id="ArrayList的实现："><a href="#ArrayList的实现：" class="headerlink" title="ArrayList的实现："></a>ArrayList的实现：</h4><p>对于ArrayList而言，它实现List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作。下面我们来分析ArrayList的源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs Java">ArrayList定义只定义类两个私有属性：<br> <span class="hljs-comment">/** </span><br><span class="hljs-comment">    * The array buffer into which the elements of the ArrayList are stored. </span><br><span class="hljs-comment">    * The capacity of the ArrayList is the length of this array buffer. </span><br><span class="hljs-comment">    */</span>  <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Object[] elementData;  <br> <br>   <span class="hljs-comment">/** </span><br><span class="hljs-comment">    * The size of the ArrayList (the number of elements it contains). </span><br><span class="hljs-comment">    * </span><br><span class="hljs-comment">    * <span class="hljs-doctag">@serial</span> </span><br><span class="hljs-comment">    */</span>  <br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br></code></pre></td></tr></table></figure><p><code>elementData</code> 储存 <code>ArrayList</code> 内的元素，<code>size</code> 表示长度。</p><p>有个关键字需要解释： <code>transient</code> 。</p><p>Java的 <code>serialization</code> 提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用 <code>serialization</code> 机制来保存它。为了在一个特定对象的一个域上关闭 <code>serialization</code> ，可以在这个域前加上关键字 <code>transient</code>。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法:"></a>基本用法:</h4><p>上一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ArrayList list = <span class="hljs-keyword">new</span> ArrayList();<br><br>    String[] Array = <span class="hljs-string">&quot;Hello World Java&quot;</span>.split(<span class="hljs-string">&quot; &quot;</span>);<br><br>    list.add(Array[<span class="hljs-number">0</span>]);<br>    list.add(Array[<span class="hljs-number">1</span>]);<br>    list.add(Array[<span class="hljs-number">2</span>]);<br>    list.add(<span class="hljs-number">5</span>);<br><br>    System.out.println(list.get(<span class="hljs-number">1</span>).getClass());<br>    System.out.println((<span class="hljs-keyword">int</span>)list.get(<span class="hljs-number">3</span>) + <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">World</span><br><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p><code>ArrayList</code> 也是可以添加相同的元素的。</p><p>下面我们看一下 <code>ArrayList</code> 最基本的增删改查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    list.add(<span class="hljs-number">4</span>);<br>    list.add(<span class="hljs-number">3</span>);<br>    list.add(<span class="hljs-number">1</span>);<br>    System.out.println(list);<span class="hljs-comment">// [4, 3, 1]</span><br><br>    list.add(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">// 在2处插入2</span><br>    System.out.println(list);<span class="hljs-comment">// [4, 3, 2, 1]</span><br><br>    list.sort(<span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> o1-o2;<br>        &#125;<br>    &#125;);<span class="hljs-comment">// 排序</span><br>    System.out.println(list);<span class="hljs-comment">// [1, 2, 3, 4]</span><br><br>    list.remove(<span class="hljs-number">0</span>);<span class="hljs-comment">// 删除0处的元素</span><br>    System.out.println(list);<span class="hljs-comment">// [2, 3, 4]</span><br><br>    list.set(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>);<span class="hljs-comment">// 将0处的元素改为8</span><br>    System.out.println(list);<span class="hljs-comment">// [8, 3, 4]</span><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/java/java-arraylist.html">更多方法</a></p><p>我们看一下 <code>ArrayList</code> 中的遍历。</p><p>第一种：通过迭代器遍历，即通过Iterator去遍历</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">Integer</span> value = <span class="hljs-literal">null</span>;<br><span class="hljs-built_in">Iterator</span> iter = <span class="hljs-keyword">list</span>.<span class="hljs-built_in">iterator</span>();<br><span class="hljs-keyword">while</span> (iter.hasNext()) &#123;<br>    value = (<span class="hljs-keyword">Integer</span>)iter.next();<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>第二种：随机访问，通过索引值去遍历，因为ArrayList实现了RandomAccess接口，so，她支持通过索引值去随机访问元素：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">Integer</span> <span class="hljs-keyword">value</span> = null;<br><span class="hljs-built_in">int</span> <span class="hljs-built_in">size</span> = list.<span class="hljs-built_in">size</span>();<br>for (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">size</span>; i++) &#123;<br>    <span class="hljs-keyword">value</span> = (<span class="hljs-keyword">Integer</span>)list.get(i);        <br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>第三种：for循环遍历，如下所示：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">Integer</span> <span class="hljs-keyword">value</span> = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">Integer</span> integ:list) &#123;<br>    <span class="hljs-keyword">value</span> = integ;<br>&#125;<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>如果实际测试下来我们可以发现，遍历ArrayList时，使用随机访问(即，通过索引序号访问)效率最高，而使用迭代器的效率最低！</p><h4 id="ArrayList的优缺点"><a href="#ArrayList的优缺点" class="headerlink" title="ArrayList的优缺点"></a>ArrayList的优缺点</h4><p><strong>优点</strong>:</p><ol><li><code>ArrayList</code> 底层以数组实现，是一种随机访问模式，再加上它实现了 <code>RandomAccess</code> 接口，因此查找速度快；</li><li><code>ArrayList</code> 在顺序添加一个元素的时候非常方便，只是往数组里面添加了一个元素而已；</li></ol><p><strong>缺点</strong>:</p><ol><li>删除元素的时候，涉及到一次元素复制，如果要复制的元素很多，那么就会比较耗费性能</li><li>插入元素的时候，涉及到一次元素复制，如果要复制的元素很多，那么就会比较耗费性能</li></ol><p><strong>ArrayList线程问题</strong>:</p><p><code>ArrayList</code> 是线程不安全的，这个由它的实现方式决定。</p><p>我们知道ArrayList在添加一个元素的时候，需要两个步骤，第一步在Items[Size]的位置存放此元素，第二步增大Size的值，在单线程运行的情况，比如两个苹果两个人吃，一个人吃一个，这个是并发的，互不影响，但是如果一个人吃两个苹果，要保证同时吃完，就需要这个苹果吃一点，停下来再去吃一点另一个苹果，既然Add方法内部是需要分两步走，那就是线程A在0的位置赋了一个值，然后停下来去B线程ArrayList 0的位置又赋了一个值，其实是重复在一个位置赋值，然后回到A线程，执行Size增加，也就是ArrayList的大小增加了，原来Size是1，现在变成2，然后停下来继续执行线程B，又增加了一个空间位置，size大小就变成了3，结果就是0的位置有值，1和2的索引位置都没有值实际大小是3，跟想要的结果0和1赋不同的值，结果不对，so线程不安全。</p><p>解决线程不安全的方法：</p><ol><li>继承Arraylist，然后重写或按需求编写自己的方法，这些方法要写成synchronized，在这些synchronized的方法中调用ArrayList的方法。</li><li>List list = Collections.synchronizedList(new ArrayList());</li></ol><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p><code>LinkedList</code> 是基于链表设计的，而且是双向链表，所以它具有双向链表的特性。</p><ul><li>链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。</li><li>除了实现 <code>List</code> 接口外，LinkedList还为在列表的开头及结尾 <code>get、remove和insert</code> 元素提供了统一的命名方法。这些操作可以将链接列表当作栈，队列和双端队列来使用。</li></ul><p>从源码上看，<code>LinkedList</code> 继承的类与实现的接口如下</p><p><code>Collection</code> 接口、<code>List</code> 接口、<code>Cloneable</code> 接口、<code>Serializable</code> 接口、<code>Deque</code> 接口（5个接口）</p><p><code>AbstractCollection</code> 类、<code>AbstractList</code> 类、<code>AbstractSequentialList</code> 类（3个类） 。</p><p>其中 <code>Deque</code> 定义了一个线性 <code>Collection</code> ，支持在两端插入和删除元素。</p><h4 id="API操作"><a href="#API操作" class="headerlink" title="API操作"></a>API操作</h4><ol><li><p>节点Node结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>        E item;<span class="hljs-comment">//元素值</span><br>        Node&lt;E&gt; next;<span class="hljs-comment">//后置节点</span><br>        Node&lt;E&gt; prev;<span class="hljs-comment">//前置节点</span><br>        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>            <span class="hljs-keyword">this</span>.item = element;<br>            <span class="hljs-keyword">this</span>.next = next;<br>            <span class="hljs-keyword">this</span>.prev = prev;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>构造方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">LinkedList</span>(<span class="hljs-params"></span>)</span> &#123;&#125;<br> <span class="hljs-comment">//调用addAll(c)  表示将集合c所有元素插入链表中</span><br> <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">LinkedList</span>(<span class="hljs-params">Collection&lt;? <span class="hljs-keyword">extends</span> E&gt; c</span>)</span> &#123;<br>     <span class="hljs-built_in">this</span>();<br>     addAll(c);<br> &#125;<br>Copy<br></code></pre></td></tr></table></figure></li></ol><p>下面实际用例来看看具体是怎么增删改查的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<br><br>    list.add(<span class="hljs-number">1</span>);<span class="hljs-comment">//增加一个节点</span><br>    list.add(<span class="hljs-number">3</span>);<br>    list.add(<span class="hljs-number">4</span>);<br>    System.out.println(list);<span class="hljs-comment">// [1, 3, 4]</span><br>    list.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<span class="hljs-comment">// 在1处插入2</span><br>    System.out.println(list);<span class="hljs-comment">// [1, 2, 3, 4]</span><br>    list.remove(<span class="hljs-number">0</span>);<span class="hljs-comment">// 删除第一个元素</span><br>    System.out.println(list);<span class="hljs-comment">// [2, 3, 4]</span><br>    list.set(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">// 将0位设置为1</span><br>    System.out.println(list);<span class="hljs-comment">// [1, 3, 4]</span><br>    Integer a = list.get(<span class="hljs-number">0</span>);<br>    System.out.println(a);<span class="hljs-comment">// 1</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/java/java-linkedlist.html">更多方法</a></p><p>下面看一下 <code>LinkedList</code> 的一般的遍历</p><ol><li><p>一般的for循环(随机访问)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">int</span> size = list.size();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;size; i++) &#123;<br>    list.get(i);        <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>for–each循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">for</span> (Integer integ:list) <br></code></pre></td></tr></table></figure></li><li><p>迭代器iterator</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">for</span>(Iterator iter = list.iterator(); iter.hasNext();)<br>    iter.next();<br></code></pre></td></tr></table></figure></li></ol><h4 id="小结"><a href="#小结" class="headerlink" title="小结:"></a>小结:</h4><ol><li>底层实现：LinkedList的实现是基于双向链表的，且头结点中不存放数据</li><li>构造方法：无参构造方法直接建立一个仅包含head节点的空链表；包含Collection的构造方法，先调用无参构造方法建立一个空链表，而后将Collection中的数据加入到链表的尾部后面。</li><li>查找删除：源码中都划分为该元素为null和不为null两种情况来处理，LinkedList中允许元素为null。</li><li>LinkedList是基于链表实现的，因此不存在容量不足的问题，所以这里没有扩容的方法。</li><li>LinkedList是基于链表实现的，因此插入删除效率高，查找效率低（虽然有一个加速动作）。</li><li>注意源码中还实现了栈和队列的操作方法，因此也可以作为栈、队列和双端队列来使用。</li></ol><h3 id="ArrayList-和-LinkedList-异同"><a href="#ArrayList-和-LinkedList-异同" class="headerlink" title="ArrayList 和 LinkedList 异同"></a>ArrayList 和 LinkedList 异同</h3><p><strong>相同点</strong>：</p><ol><li>接口实现：都实现了List接口，都是线性列表的实现</li><li>线程安全：都是线程不安全的，都是基于fail-fast机制</li></ol><p><strong>不同点</strong>：</p><ol><li>底层:ArrayList内部是数组实现，而LinkedList内部实现是双向链表结构</li><li>接口：ArrayList实现了RandomAccess可以支持随机元素访问，而LinkedList实现了Deque可以当做队列使用</li><li>性能：新增、删除元素时ArrayList需要使用到拷贝原数组，而LinkedList只需移动指针，查找元素 ArrayList支持随机元素访问,而LinkedList只能一个节点的去遍历</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/24247566">https://zhuanlan.zhihu.com/p/24247566</a> [↩]</li><li><a href="https://www.runoob.com/java/java-arraylist.html">https://www.runoob.com/java/java-arraylist.html</a> [↩]</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划:最长子数组和系列</title>
    <link href="/2021/03/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E7%B3%BB%E5%88%97/"/>
    <url>/2021/03/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="动态规划-最长子数组和系列"><a href="#动态规划-最长子数组和系列" class="headerlink" title="动态规划:最长子数组和系列"></a>动态规划:最长子数组和系列</h2><p>官方解释: 从动态规划角度讲，最大子数组和是以一类较简单的 <code>DP</code> 问题，但它的状态设计比较经典，同时也是很多问题的基础组件，需要专门掌握。</p><p>果然是我太菜了</p><span id="more"></span><h3 id="1-最大子序和"><a href="#1-最大子序和" class="headerlink" title="1. 最大子序和"></a>1. 最大子序和</h3><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">刷题地址 53. 最大子序和</a></p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>示例 1</strong>：</p><figure class="highlight subunit"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-2</span>,1,<span class="hljs-string">-3</span>,4,<span class="hljs-string">-1</span>,2,1,<span class="hljs-string">-5</span>,4]<br>输出：6<br>解释：连续子数组 [4,<span class="hljs-string">-1</span>,2,1] 的和最大，为 6 。<br></code></pre></td></tr></table></figure><p><strong>示例 2</strong>：</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [1]</span><br><span class="hljs-string">输出：1</span><br></code></pre></td></tr></table></figure><p><strong>提示</strong>：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1</span> &lt;= nums.<span class="hljs-built_in">length</span> &lt;= <span class="hljs-number">3</span> * <span class="hljs-number">10e4</span><br><span class="hljs-number">-105</span> &lt;= nums[i] &lt;= <span class="hljs-number">10e5</span><br></code></pre></td></tr></table></figure><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>该系列最经典的一题，也是最简单的一题，思路也很简单。思路清晰，先说DP。</p><ol><li>对数组遍历，连续子序列和为 <code>sum</code></li><li>如果 <code>sum&gt;0</code> 就说明对结果有增益</li><li>如果小于0就表示没有增益，直接舍去前面的结果，将 <code>sum</code> 赋值为 <code>nums[i]</code>。</li><li>记录每次遍历是sum的最大值</li></ol><p>代码还是很简洁的</p><h4 id="代码-Java"><a href="#代码-Java" class="headerlink" title="代码(Java)"></a>代码(Java)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br>        <span class="hljs-keyword">if</span>(len&lt;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res = Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-keyword">if</span>(sum&gt;<span class="hljs-number">0</span>)&#123;<br>                sum += nums[i];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                sum = nums[i];<br>            &#125;<br>            res = Math.max(res, sum);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-乘积最大子数组"><a href="#2-乘积最大子数组" class="headerlink" title="2. 乘积最大子数组"></a>2. 乘积最大子数组</h3><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">刷题地址:152. 乘积最大子数组</a></p><p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p><p><strong>示例 1</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [2,3,-2,4] </span><br><span class="hljs-section">输出: 6</span><br><span class="hljs-section">解释: 子数组 [2,3] 有最大乘积 6。</span><br>Copy<br></code></pre></td></tr></table></figure><p><strong>示例 2</strong>:</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入: [<span class="hljs-string">-2</span>,0,<span class="hljs-string">-1</span>]<br>输出: 0<br>解释: 结果不能为 2, 因为 [<span class="hljs-string">-2</span>,<span class="hljs-string">-1</span>] 不是子数组。<br>Copy<br></code></pre></td></tr></table></figure><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>和上一题差不多，但是我们要注意，如果遇到负数的话，最大值乘负数会变成最小值，相对应的，最小值乘负数也会变成最大值。我们需要在每次遍历时候记录最大值和最小值，在 <code>nums[i]</code> 为负数时，调换最大值和最小值的数值。</p><h4 id="代码-Java-1"><a href="#代码-Java-1" class="headerlink" title="代码(Java)"></a>代码(Java)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> len = nums.length;<br>        <span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">int</span> res = Integer.MIN_VALUE;<br>        <span class="hljs-keyword">int</span> imax = <span class="hljs-number">1</span>, imin = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]&lt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">int</span> temp = imax;<br>                imax = imin;<br>                imin = temp;<br>            &#125;<br>            imax = Math.max(imax*nums[i], nums[i]);<br>            imin = Math.min(imin*nums[i], nums[i]);<br><br>            res = Math.max(imax, res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-环形子数组的最大和"><a href="#3-环形子数组的最大和" class="headerlink" title="3. 环形子数组的最大和"></a>3. 环形子数组的最大和</h3><p>给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。</p><p>在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当 <code>0 &lt;= i &lt; A.length</code> 时 <code>C[i] = A[i]</code>，且当 <code>i &gt;= 0</code> 时 <code>C[i+A.length] = C[i]</code>）</p><p>此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。（形式上，对于子数组 <code>C[i], C[i+1], ..., C[j]</code>，不存在 <code>i &lt;= k1, k2 &lt;= j</code> 其中 <code>k1 % A.length = k2 % A.length</code>）</p><p><strong>示例 1</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1,-2,3,-2]</span><br>输出：<span class="hljs-number">3</span><br>解释：从子数组 <span class="hljs-selector-attr">[3]</span> 得到最大和 <span class="hljs-number">3</span><br>Copy<br></code></pre></td></tr></table></figure><p><strong>示例 2</strong>：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：<span class="hljs-comment">[5,-3,5]</span><br>输出：10<br>解释：从子数组 <span class="hljs-comment">[5,5]</span> 得到最大和 5 + 5 = 10<br>Copy<br></code></pre></td></tr></table></figure><p><strong>示例 3</strong>：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：[3,<span class="hljs-string">-1</span>,2,<span class="hljs-string">-1</span>]<br>输出：4<br>解释：从子数组 [2,<span class="hljs-string">-1</span>,3] 得到最大和 2 + (<span class="hljs-string">-1</span>) + 3 = 4<br>Copy<br></code></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>思路清晰，先说DP。<br>稍微变通一下就是很简单的一道题，因为只包含两种情况，一种就是第一题的情况，另一种其实就是肯定包括第一位和最后一位，找出最大的子数组其实也就是找到第二位和倒数第二位之间最小的连续子序列，然后用总和减去即可。</p><h4 id="代码-Java-2"><a href="#代码-Java-2" class="headerlink" title="代码(Java)"></a>代码(Java)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubarraySumCircular</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] A)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> len = A.length;<br>        <span class="hljs-keyword">if</span>(len&lt;<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> A[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">int</span> s1 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans1 = Integer.MIN_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>            sum += A[i];<br>            s1 = Math.max(s1+A[i], A[i]);<br>            ans1 = Math.max(s1, ans1);<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> s2 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> ans2 = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len-<span class="hljs-number">1</span>;i++)&#123;<br>            s2 = Math.min(s2+A[i], A[i]);<br>            ans2 = Math.min(ans2, s2);<br>        &#125;<br>        ans2 = sum - ans2;<br><br>        <span class="hljs-keyword">return</span> Math.max(ans1, ans2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-最大子矩阵"><a href="#4-最大子矩阵" class="headerlink" title="4. 最大子矩阵"></a>4. 最大子矩阵</h3><p><a href="https://leetcode-cn.com/problems/max-submatrix-lcci/">刷题地址:面试题 17.24. 最大子矩阵</a></p><p>给定一个正整数、负整数和 0 组成的 N × M 矩阵，编写代码找出元素总和最大的子矩阵。</p><p>返回一个数组 <code>[r1, c1, r2, c2]</code> ，其中 <code>r1</code>, <code>c1</code> 分别代表子矩阵左上角的行号和列号，<code>r2</code>, <code>c2</code> 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。</p><p>注意：本题相对书上原题稍作改动</p><p><strong>示例</strong>：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">   <span class="hljs-comment">[-1,0]</span>,</span><br><span class="hljs-comment">   <span class="hljs-comment">[0,-1]</span></span><br><span class="hljs-comment">]</span><br>输出：<span class="hljs-comment">[0,1,0,1]</span><br>解释：输入中标粗的元素即为输出所表示的矩阵<br>Copy<br></code></pre></td></tr></table></figure><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>看着挺唬人的一道题，也还是第一道题的二维化，我们遍历两次从第 <code>i</code> 行开始的 <code>j</code> 行，每一列的数加在一起变成了一个新的数组 <code>b[]</code>，然后算b的最大连续子序列，同时记录下左上的坐标，在每次出现最大值时更新右下坐标即可，思路还是很清晰的。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] getMaxMatrix(<span class="hljs-keyword">int</span>[][] matrix) &#123;<br>        <span class="hljs-keyword">int</span> []ans = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [<span class="hljs-number">4</span>];<br>        <span class="hljs-keyword">int</span> lenx = matrix.length;<br>        <span class="hljs-keyword">int</span> leny = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span> []b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[leny];<br>        <span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>, col = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> max = Integer.MIN_VALUE;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;lenx;i++)&#123;<br>            Arrays.fill(b, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;lenx;j++)&#123;<br>                <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>;k&lt;leny;k++)&#123;<br>                    b[k] += matrix[j][k];<br><br>                    <span class="hljs-keyword">if</span>(sum&gt;<span class="hljs-number">0</span>)&#123;<br>                        sum += b[k];<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        sum = b[k];<br>                        row = i;<br>                        col = k;<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span>(sum &gt; max)&#123;<br>                        max = sum;<br>                        ans[<span class="hljs-number">0</span>] = row;<br>                        ans[<span class="hljs-number">1</span>] = col;<br>                        ans[<span class="hljs-number">2</span>] = j;<br>                        ans[<span class="hljs-number">3</span>] = k;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-矩形区域不超过-K-的最大数值和"><a href="#5-矩形区域不超过-K-的最大数值和" class="headerlink" title="5. 矩形区域不超过 K 的最大数值和"></a>5. 矩形区域不超过 K 的最大数值和</h3><p><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">刷题地址:363. 矩形区域不超过 K 的最大数值和</a></p><p>给定一个非空二维矩阵 matrix 和一个整数 k，找到这个矩阵内部不大于 k 的最大矩形和。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入: matrix = <span class="hljs-string">[[1,0,1],[0,-2,3]]</span>, k = <span class="hljs-number">2</span><br>输出: <span class="hljs-number">2</span> <br>解释: 矩形区域 <span class="hljs-string">[[0, 1], [-2, 3]]</span> 的数值和是 <span class="hljs-number">2</span>，且 <span class="hljs-number">2</span> 是不超过 k 的最大数字（k = <span class="hljs-number">2</span>）。<br>Copy<br></code></pre></td></tr></table></figure><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>思路清晰，先不说DP，就是上面一道题的变体，最接近 <code>k</code> 而不大于 <code>k</code>, 直接对上一题的 <code>b[]</code> 进行暴力遍历咯，找到所有情况直接选择最优解。</p><p>PS：实际情况因为一般都要查询多次，为避免重复计算一般选用二维前缀和，在前缀和篇章细嗦。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSumSubmatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = Integer.MIN_VALUE;<br>        <span class="hljs-keyword">int</span> lenx = matrix.length;<br>        <span class="hljs-keyword">int</span> leny = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span> []b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[leny];<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;lenx;i++)&#123;<br>            Arrays.fill(b, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=i;j&lt;lenx;j++)&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> l=<span class="hljs-number">0</span>;l&lt;leny;l++)&#123;<br>                    b[l] += matrix[j][l];<br>                &#125;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;x&lt;leny;x++)&#123;<br>                    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y=x;y&lt;leny;y++)&#123;<br>                        sum += b[y];<br>                        <span class="hljs-keyword">if</span>(sum&lt;=k)&#123;<br>                            res = Math.max(res, sum);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode124.二叉树中的最大路径和</title>
    <link href="/2021/03/01/leetcode124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/"/>
    <url>/2021/03/01/leetcode124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="leetcode124-二叉树中的最大路径和"><a href="#leetcode124-二叉树中的最大路径和" class="headerlink" title="leetcode124.二叉树中的最大路径和"></a>leetcode124.二叉树中的最大路径和</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">刷题地址</a></p><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><span id="more"></span><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p><strong>示例1</strong>：</p><figure class="highlight tap"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs tap">输入：root = [1,2,3]<br>输出：6<br>解释：最优路径是<span class="hljs-number"> 2 </span>-&gt;<span class="hljs-number"> 1 </span>-&gt;<span class="hljs-number"> 3 </span>，路径和为<span class="hljs-number"> 2 </span>+<span class="hljs-number"> 1 </span>+<span class="hljs-number"> 3 </span>= 6<br>Copy<br></code></pre></td></tr></table></figure><p><strong>示例2</strong>：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：root = [-10,9,20,null,null,15,7]<br>输出：42<br>解释：最优路径是<span class="hljs-number"> 15 </span>-&gt;<span class="hljs-number"> 20 </span>-&gt;<span class="hljs-number"> 7 </span>，路径和为<span class="hljs-number"> 15 </span>+<span class="hljs-number"> 20 </span>+<span class="hljs-number"> 7 </span>= 42<br>Copy<br></code></pre></td></tr></table></figure><p><code>root</code> 对象所在的类：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>     int <span class="hljs-keyword">val</span>;<br>     TreeNode left;<br>     TreeNode right;<br>     TreeNode() &#123;&#125;<br>     TreeNode(int <span class="hljs-keyword">val</span>) &#123; <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>; &#125;<br>     TreeNode(int <span class="hljs-keyword">val</span>, TreeNode left, TreeNode right) &#123;<br>         <span class="hljs-keyword">this</span>.<span class="hljs-keyword">val</span> = <span class="hljs-keyword">val</span>;<br>         <span class="hljs-keyword">this</span>.left = left;<br>         <span class="hljs-keyword">this</span>.right = right;<br>     &#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一个比较经典的递归题，路径的含义通俗的来说就是在二叉树中没有分叉的线经过的子节点，只要满足不分叉，可以随意走。</p><p>我们考虑如果将问题缩小</p><p><a href="https://www.dmxcg.xyz/img/leetcode/124.jpg"><img src="/2021/03/01/leetcode124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/124.jpg" alt="leetcode124"></a></p><p>所有的路径情况就是</p><ul><li>左中右 <code>b + a + c</code></li><li>左 <code>b + a</code></li><li>右 <code>c + a</code></li></ul><p>用递归方法</p><ul><li>递归调用 <code>b</code> 和 <code>c</code></li><li>计算 <code>b + a</code> 和 <code>c + a</code>，选择较大的值作为返回值</li><li>更新到结果(全局最大和)</li></ul><p>即：<code>f(n) = max(max(0, f(n-&gt;left)) + n-&gt;val, max(0, f(n-&gt;right))+n-&gt;val)</code></p><p>如果节点的数值是负数，应当能舍就舍，即不走该路径 <code>max(0, x)</code> 。如果是不能绕过的根节点，其实可以直接先设置全局最大和为 <code>INT_MIN</code> 即 <code>-pow(2, 32)</code> 这样更新的时候也就没问题了。</p><p>这么一想，代码就容易多了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = Integer.MIN_VALUE;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//显然没有节点就是0</span><br><br>        <span class="hljs-keyword">int</span> left = Math.max(<span class="hljs-number">0</span>, f(root.left));<br>        <span class="hljs-keyword">int</span> right = Math.max(<span class="hljs-number">0</span>, f(root.right));<br><br>        <span class="hljs-keyword">int</span> count = left + right + root.val;<br>        res = Math.max(res, count);<br><br>        <span class="hljs-keyword">return</span> Math.max(left+root.val, right+root.val);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        f(root);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/03/01/leetcode124-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/124result.jpg" alt="result"></p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口与多态(中)</title>
    <link href="/2021/03/01/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81(%E4%B8%AD)/"/>
    <url>/2021/03/01/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81(%E4%B8%AD)/</url>
    
    <content type="html"><![CDATA[<h2 id="接口与多态-中"><a href="#接口与多态-中" class="headerlink" title="接口与多态(中)"></a>接口与多态(中)</h2><p>让我们来看看常见而实用的接口，下面的接口一定要理解并弄明白。</p><h3 id="1-Serializable"><a href="#1-Serializable" class="headerlink" title="1. Serializable"></a>1. Serializable</h3><p>一个对象序列化的接口，一个类只有实现了Serializable接口，它的对象才能被序列化。</p><span id="more"></span><h4 id="什么是序列化？"><a href="#什么是序列化？" class="headerlink" title="什么是序列化？"></a>什么是序列化？</h4><p>序列化是将对象状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它将流转换为对象。这两个过程结合起来，可以轻松地存储和传输数据。</p><p>当我们需要把对象的状态信息通过网络进行传输，或者需要将对象的状态信息持久化，以便将来使用时都需要把对象进行序列化。</p><p><code>Serializable</code> 在源码上也只是一个声明，就是告知JVM，让JVM帮助这个类进行序列化，而自己不用具体去写方法。</p><h4 id="为什么要定义serialversionUID变量"><a href="#为什么要定义serialversionUID变量" class="headerlink" title="为什么要定义serialversionUID变量"></a>为什么要定义serialversionUID变量</h4><p>如果我们标识了 <code>Serializable</code> 却没有具体实现，接口会默认生成一个 <code>serialVersionUID</code> 变量，但是接口端的 <code>serialVersionUID</code> 异常敏感，反序列化可能导致异常，所以建议自己定义一个 <code>serialVersionUID</code>。</p><p>下面看一段示例</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> salary;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSalary</span><span class="hljs-params">(<span class="hljs-keyword">int</span> salary)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.salary = salary;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Employee&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;age=&quot;</span> + age +<br>                <span class="hljs-string">&quot;, salary=&quot;</span> + salary +<br>                <span class="hljs-string">&quot;, name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeEmployee</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br><br>            Employee em = <span class="hljs-keyword">new</span> Employee();<br><br>            em.setAge(<span class="hljs-number">18</span>);<br><br>            em.setName(<span class="hljs-string">&quot;abc&quot;</span>);<br><br>            em.setSalary(<span class="hljs-number">10000</span>);<br><br><br>            ObjectOutputStream objectOutputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;abc&quot;</span>)));<br><br>            objectOutputStream.writeObject(em);<br>            System.out.println(<span class="hljs-string">&quot;序列化成功&quot;</span>);<br>            objectOutputStream.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            System.out.println(<span class="hljs-string">&quot;WriteEmployee&quot;</span> + ex.getMessage());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Employee <span class="hljs-title">readEmployee</span><span class="hljs-params">()</span></span>&#123;<br>        Employee me = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-keyword">try</span>&#123;<br>            ObjectInputStream objectInputStream = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;abc&quot;</span>)));<br><br>            me = (Employee) objectInputStream.readObject();<br><br>            System.out.println(<span class="hljs-string">&quot;反序列化成功&quot;</span>);<br><br>            System.out.println(me);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception ex)&#123;<br>            System.out.println(<span class="hljs-string">&quot;readEmployee:&quot;</span>+ex.getMessage());<br>        &#125;<br>        <span class="hljs-keyword">return</span> me;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        writeEmployee();<br>        readEmployee();<br>    &#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">序列化成功<br>反序列化成功<br>Employee&#123;<span class="hljs-attribute">age</span>=18, <span class="hljs-attribute">salary</span>=10000, <span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;abc&#x27;</span>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>如果没 <code>serialversionUID</code> 在反序列化时候就回抛出异常，这个 <code>serialVersionUID</code> 的详细的工作机制是：在序列化的时候系统将 <code>serialVersionUID</code> 写入到序列化的文件中去，当反序列化的时候系统会先去检测文件中的 <code>serialVersionUID</code> 是否跟当前的文件的 <code>serialVersionUID</code> 是否一致，如果一直则反序列化成功，否则就说明当前类跟序列化后的类发生了变化，比如是成员变量的数量或者是类型发生了变化，那么在反序列化时就会发生 <code>crash</code> ，并且回报出错误。</p><h3 id="2-Comparable-和-Comparator"><a href="#2-Comparable-和-Comparator" class="headerlink" title="2. Comparable 和 Comparator"></a>2. Comparable 和 Comparator</h3><p>顾名思义咯，俩兄弟都是比较两个对象用的，要的是学习两个独特的用法和区别。</p><h4 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h4><p>先看源码</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Comparable</span>&lt;<span class="hljs-symbol">T</span>&gt; &#123;<br>    <span class="hljs-built_in">int</span> compareTo(T t);<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>所以如果一个类实现了 <code>Comparable</code> 接口，一定需要重写 <code>compareTo</code> 方法，用自己给定的规则对两个创建的对象进行比较。</p><p>示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Employee</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> salary;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> salary, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.salary = salary;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Employee o)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.salary - o.salary;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Employee a = <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">18</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>        Employee b = <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">18</span>, <span class="hljs-number">101</span>, <span class="hljs-string">&quot;B&quot;</span>);<br><br>        <span class="hljs-keyword">if</span>(a.compareTo(b)&gt;<span class="hljs-number">0</span>)&#123;<br>            System.out.println(a.name+<span class="hljs-string">&quot;工资高&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a.compareTo(b)==<span class="hljs-number">0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;一样高&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            System.out.println(b.name+<span class="hljs-string">&quot;工资高&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">B</span>工资高<br>Copy<br></code></pre></td></tr></table></figure><p>我们看 <code>Comparable</code> 接口还是比较简单的，只需要实现 <code>comparaTo</code> 方法即可，如果指定对象的类型与此对象不能进行比较，则引发 <code>ClassCastException</code> 异常（引入泛型可以规避这种情况）。</p><h4 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h4><p>先看一下源码</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">CmowerComparator</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Comparator</span>&lt;<span class="hljs-symbol">Cmower</span>&gt; &#123;<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> compare(Cmower o1, Cmower o2) &#123;<br>        <span class="hljs-keyword">return</span> o1.getAge() - o2.getAge();<br>    &#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>实际上是要你重写类，以及如何比较的方法，举个例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> salary;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> salary, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.salary = salary;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> salary;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Employee a = <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">18</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>        Employee b = <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">18</span>, <span class="hljs-number">101</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>        Employee c = <span class="hljs-keyword">new</span> Employee(<span class="hljs-number">18</span>, <span class="hljs-number">99</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>        List&lt;Employee&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(a);<br>        list.add(b);<br>        list.add(c);<br><br>        list.sort(<span class="hljs-keyword">new</span> EmployeeComparator());<br><br>        <span class="hljs-keyword">for</span>(Employee i:list)&#123;<br>            System.out.println(i.getName());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmployeeComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Employee</span>&gt;</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Employee o1, Employee o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> o1.getSalary() - o2.getSalary();<br>    &#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">C<br><span class="hljs-selector-tag">A</span><br><span class="hljs-selector-tag">B</span><br>Copy<br></code></pre></td></tr></table></figure><p>显然，已经按照工资的顺序排列了。</p><p><code>Comparator</code> 的具体作用就是判断大小的基础上应用如排序方法。</p><h4 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h4><ul><li>一个类实现了 <code>Comparable</code> 接口，意味着该类的对象可以直接进行比较（排序），但比较（排序）的方式只有一种，很单一。</li><li>一个类如果想要保持原样，又需要进行不同方式的比较（排序），就可以定制比较器（实现 <code>Comparator</code> 接口）。</li><li><code>Comparable</code> 接口在 <code>java.lang</code> 包下，而 <code>Comparator</code> 接口在 <code>java.util</code> 包下，算不上是亲兄弟，但可以称得上是表（堂）兄弟。</li></ul><h3 id="3-Cloneable"><a href="#3-Cloneable" class="headerlink" title="3. Cloneable"></a>3. Cloneable</h3><p>标记一个类是可以深复制的，在<a href="https://www.dmxcg.xyz/2021/02/25/%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1-Object%E7%B1%BB%E7%9A%8411%E4%B8%AA%E6%96%B9%E6%B3%95(%E4%B8%8A)/">另一篇博客</a>中讲到如何使用的方法。</p><h3 id="4-Iterable-和-Iterator"><a href="#4-Iterable-和-Iterator" class="headerlink" title="4. Iterable 和 Iterator"></a>4. Iterable 和 Iterator</h3><p>先看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-function">Iterator&lt;T&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function">E <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p><code>Interable</code> 只是返回了 <code>Intertor</code> 的一个实例，原因是实现了 <code>Iterable</code> 的类可以在实现多个 <code>Iterator</code> 内部类，例如 <code>LinkedList</code> 中的 <code>ListItr</code> 和 <code>DescendingIterator</code> 两个内部类，就分别实现了双向遍历和逆序遍历。通过返回不同的Iterator实现不同的遍历方式，这样更加灵活。如果把两个接口合并，就没法返回不同的 <code>Iterator</code> 实现类了。</p><p>上个代码，直观地展示一下实现了 <code>Iterable</code> 的类如何通过返回不同的 <code>Iterator</code> 从而实现不同的遍历方式。 <code>MutilIterator</code> 实现了三种迭代器，分别是默认的前向迭代器，反向迭代器和随机迭代器。主函数中分别调用了三种迭代器进行遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutilIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">String</span>&gt;</span>&#123;<br><br>    <span class="hljs-keyword">private</span> String[] words = <span class="hljs-string">&quot;May I get offers this summer.&quot;</span>.split(<span class="hljs-string">&quot; &quot;</span>);<br><br>    <span class="hljs-comment">// 默认迭代器，前向遍历</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;String&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Iterator&lt;String&gt;() &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> index &lt; words.length;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> words[index++];<br>            &#125;<br><br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">// 反向迭代器</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterable&lt;String&gt; <span class="hljs-title">reverseItertor</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Iterable&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;String&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Iterator&lt;String&gt;() &#123;<br>                    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = words.length - <span class="hljs-number">1</span>;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>                        <span class="hljs-keyword">return</span> index&gt;-<span class="hljs-number">1</span>;<br>                    &#125;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>                        <span class="hljs-keyword">return</span> words[index--];<br>                    &#125;<br>                &#125;;<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">//随机迭代器，注意这里不是创建一个新的Iterator，而是返回了一个打乱的List中的迭代器</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterable&lt;String&gt; <span class="hljs-title">randomized</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Iterable&lt;String&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;String&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>                List&lt;String&gt; shuffled = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(words));<br>                Collections.shuffle(shuffled, <span class="hljs-keyword">new</span> Random(<span class="hljs-number">47</span>));<br>                <span class="hljs-keyword">return</span> shuffled.iterator();<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MutilIterator mi = <span class="hljs-keyword">new</span> MutilIterator();<br><br>        <span class="hljs-keyword">for</span>(String i:mi)&#123;<br>            System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br><br>        <span class="hljs-keyword">for</span>(String i:mi.reverseItertor())&#123;<br>            System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>        System.out.println();<br><br>        <span class="hljs-keyword">for</span>(String i:mi.randomized())&#123;<br>            System.out.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>以上就是三个常见的迭代器的用法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown进阶语法</title>
    <link href="/2021/03/01/Markdown%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/03/01/Markdown%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown进阶语法"><a href="#Markdown进阶语法" class="headerlink" title="Markdown进阶语法"></a>Markdown进阶语法</h1><p>引入HTML的标签语法来实现更进阶的语法</p><span id="more"></span><h2 id="1-更改字体、大小、颜色"><a href="#1-更改字体、大小、颜色" class="headerlink" title="1. 更改字体、大小、颜色"></a><strong>1. 更改字体、大小、颜色</strong></h2><p><strong>语法:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">&quot;黑体&quot;</span>&gt;</span>我是黑体字<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">&quot;微软雅黑&quot;</span>&gt;</span>我是微软雅黑<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">&quot;STCAIYUN&quot;</span>&gt;</span>我是华文彩云<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">red</span>&gt;</span>我是红色<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">#008000</span>&gt;</span>我是绿色<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">Blue</span>&gt;</span>我是蓝色<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">size</span>=<span class="hljs-string">5</span>&gt;</span>我是尺寸<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">face</span>=<span class="hljs-string">&quot;黑体&quot;</span> <span class="hljs-attr">color</span>=<span class="hljs-string">green</span> <span class="hljs-attr">size</span>=<span class="hljs-string">5</span>&gt;</span>我是黑体，绿色，尺寸为5<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br>Copy<br></code></pre></td></tr></table></figure><p><strong>效果如下:</strong></p><p>我是黑体字</p><p>我是微软雅黑</p><p>我是华文彩云</p><p>我是红色</p><p>我是绿色</p><p>我是蓝色</p><p>我是尺寸</p><p>我是黑体，绿色，尺寸为5</p><h2 id="2-为文字添加背景色"><a href="#2-为文字添加背景色" class="headerlink" title="2. 为文字添加背景色"></a><strong>2. 为文字添加背景色</strong></h2><p>借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色。只是将那一整行看作一个表格，更改了那个格子的背景色（bgcolor）。</p><p><strong>语法:</strong></p><table><tr><td bgcolor="yellow">背景色yellow</td></tr></table><p><strong>效果如下:</strong></p><p>背景色yellow</p><h2 id="3-设置文字居中"><a href="#3-设置文字居中" class="headerlink" title="3. 设置文字居中"></a><strong>3. 设置文字居中</strong></h2><p>用p标签或者center</p><p><strong>语法:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span>居中<span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左对齐<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右对齐<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>Copy<br></code></pre></td></tr></table></figure><p><strong>效果如下:</strong></p><p>居中</p><p>左对齐</p><p>右对齐</p><h2 id="4-加入上下标"><a href="#4-加入上下标" class="headerlink" title="4. 加入上下标"></a><strong>4. 加入上下标</strong></h2><p>仍是HTML上下标语法</p><p><strong>语法:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">H<span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span>O  CO<span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span><br>爆米<span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span>TM<span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span><br>Copy<br></code></pre></td></tr></table></figure><p><strong>效果如下:</strong></p><p>H2O CO2<br>爆米TM</p><h2 id="5-超链接"><a href="#5-超链接" class="headerlink" title="5. 超链接"></a><strong>5. 超链接</strong></h2><p>Markdown 支持两种形式的链接语法： 行内式和参考式两种形式。</p><p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p><p>要建立一个行内式的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，注意方括号和圆括号之间一定不能有空格，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可。</p><p><strong>语法:</strong></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">This <span class="hljs-built_in">is</span> [an <span class="hljs-built_in">example</span>](http://<span class="hljs-built_in">example</span>.com/ <span class="hljs-string">&quot;Title&quot;</span>) inline link.<br><br>[This link](http://<span class="hljs-built_in">example</span>.net/) has no <span class="hljs-built_in">title</span> attribute.<br>Copy<br></code></pre></td></tr></table></figure><p><strong>效果如下:</strong></p><p>This is <a href="http://example.com/">an example</a> inline link.</p><p><a href="http://example.net/">This link</a> has no title attribute.</p><p><strong>注：</strong>如果想要在新页面中打开的话可以用html语言的a标签代替。<br><a href="https://www.dmxcg.xyz/2021/02/23/Markdown%E8%BF%9B%E9%98%B6%E8%AF%AD%E6%B3%95/%E8%B6%85%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%9D%80">超链接名</a></p><p>参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">This <span class="hljs-keyword">is</span> [an example][<span class="hljs-built_in">id</span>] <span class="hljs-keyword">reference</span>-style link.<br>Copy<br></code></pre></td></tr></table></figure><p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">[id]: http:<span class="hljs-regexp">//</span>example.com/  <span class="hljs-string">&quot;Optional Title Here&quot;</span><br>Copy<br></code></pre></td></tr></table></figure><p>链接内容的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着 链接网址也可以用尖括号包起来：<br><code>[id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot;</code></p><p>链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写。</p><p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p><p>此外，用这个方法还可以将图片转化为base64编码保存在.md文件中，这将在插入图片中介绍。</p><p><strong>下面是一个参考式链接的范例：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">I</span> get <span class="hljs-number">10</span> times more traffic <span class="hljs-selector-tag">from</span> <span class="hljs-selector-attr">[Google]</span> <span class="hljs-selector-attr">[1]</span> than <span class="hljs-selector-tag">from</span><br><span class="hljs-selector-attr">[Yahoo]</span> <span class="hljs-selector-attr">[2]</span> or <span class="hljs-selector-attr">[MSN]</span> <span class="hljs-selector-attr">[3]</span>.<br><br>  <span class="hljs-selector-attr">[1]</span>: http://google.com/        <span class="hljs-string">&quot;Google&quot;</span><br>  [<span class="hljs-number">2</span>]: http://search.yahoo.com/  <span class="hljs-string">&quot;Yahoo Search&quot;</span><br>  [<span class="hljs-number">3</span>]: http://search.msn.com/    <span class="hljs-string">&quot;MSN Search&quot;</span><br>Copy<br></code></pre></td></tr></table></figure><p>还可以直接用链接名称的方式写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">I</span> get <span class="hljs-number">10</span> times more traffic <span class="hljs-selector-tag">from</span> <span class="hljs-selector-attr">[Google]</span><span class="hljs-selector-attr">[]</span> than <span class="hljs-selector-tag">from</span><br><span class="hljs-selector-attr">[Yahoo]</span><span class="hljs-selector-attr">[]</span> or <span class="hljs-selector-attr">[MSN]</span><span class="hljs-selector-attr">[]</span>.<br><br>  <span class="hljs-selector-attr">[google]</span>: http://google.com/        <span class="hljs-string">&quot;Google&quot;</span><br>  [yahoo]:  http://search.yahoo.com/  <span class="hljs-string">&quot;Yahoo Search&quot;</span><br>  [msn]:    http://search.msn.com/    <span class="hljs-string">&quot;MSN Search&quot;</span><br>Copy<br></code></pre></td></tr></table></figure><h2 id="6-自动链接"><a href="#6-自动链接" class="headerlink" title="6. 自动链接"></a><strong>6. 自动链接</strong></h2><p>除了上面的超链接方式，Markdown 还支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。</p><p><strong>语法:</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">&lt;http:<span class="hljs-regexp">//</span>example.com/&gt;<br>Copy<br></code></pre></td></tr></table></figure><p><strong>效果如下:</strong></p><p><a href="http://example.com/">http://example.com/</a></p><h2 id="8-插入图片"><a href="#8-插入图片" class="headerlink" title="8. 插入图片"></a><strong>8. 插入图片</strong></h2><p>*<strong>这里只说明加入hexo blog较为简单的插入图片方法*</strong></p><p>使用插件<code>hexo-renderer-marked</code>解决，用<code>npm install hexo-renderer-marked</code>命令直接安装，之后在_config.yaml更改配置:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br><span class="hljs-string">Copy</span><br></code></pre></td></tr></table></figure><p>之后就能以该hexo的theme文件夹中source为相对路径的起始点，调用目录中的文件的文件，不影响上传</p><h2 id="9-LaTeX公式"><a href="#9-LaTeX公式" class="headerlink" title="9. LaTeX公式"></a><strong>9. LaTeX公式</strong></h2><p>Markdown还有一大优势就是可以支持 LaTeX 的公式。 $ 表示行内公式 $$ 表示整行公式 访问<a href="https://zhuanlan.zhihu.com/p/110756681">MathJax</a>参考更多使用方法。</p><h2 id="10-参考链接"><a href="#10-参考链接" class="headerlink" title="10. 参考链接"></a><strong>10. 参考链接</strong></h2><p><a href="https://zhuanlan.zhihu.com/p/99319314">Markdown语法及原理从入门到高级</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>文本工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接口与多态</title>
    <link href="/2021/02/27/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
    <url>/2021/02/27/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="接口与多态-上"><a href="#接口与多态-上" class="headerlink" title="接口与多态(上)"></a>接口与多态(上)</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>接口和多态的关系是千丝万缕的，多态是Java三大特性之一，而接口是最能体现多态的，接口和实现类的关系，以及各个实现类之间的关系，不像父类和子类之间，子类和其他子类之间的要求那么严格。</p><span id="more"></span><p>举个例子,拿”吃饭”这个 <code>method</code> 举例…如果把这个 <code>method</code> 声明在父类中,那么子类必须要和父类是”同类”，父类是人，那么”吃饭”这个功能就被限制死了，只能被人来完成…</p><p>如果把这个功能声明在”接口”中，那么完成这个功能的不光能是人，可以狗，可以是猫，可以是任何东西,只要它能”吃饭”…这个就最大限度地体现了”多种形态”…</p><p>接口的多态性，就体现在只关心”你能做什么”，而不关心”你是谁”…</p><h3 id="详细的讲一下多态"><a href="#详细的讲一下多态" class="headerlink" title="详细的讲一下多态"></a>详细的讲一下多态</h3><p>多态存在有三个前提：</p><ol><li>继承关系</li><li>子类要重写父类的方法</li><li>父类引用指向子类对象</li></ol><p>我们先上代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span> &#123;</span><br>    <span class="hljs-keyword">int</span> age = <span class="hljs-number">25</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> salary = <span class="hljs-number">1000</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;打工人工作&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;打工人吃饭&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resign</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;打工人跑路&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-title">extends</span> <span class="hljs-title">Employee</span>&#123;</span><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> salary = <span class="hljs-number">10000</span>;<br>    <span class="hljs-keyword">int</span> age = <span class="hljs-number">30</span>;<br>    @<span class="hljs-function">Override</span><br><span class="hljs-function">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;经理工作&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resign</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;经理跳槽&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bonuses</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;经理领奖金&quot;</span>);<br>    &#125;<br><br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>显然经理也是打工人，所以经理以打工人为超类。但是打工人中 <code>跑路</code> 是用 <code>static</code> 标识的，说明它不可继承。(普通打工人才跑路，经理只有跳槽)</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    Employee a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Manager</span>();<br>    a.<span class="hljs-built_in">work</span>();<br>    a.<span class="hljs-built_in">resign</span>();<br>    a.<span class="hljs-built_in">eat</span>();<br><span class="hljs-comment">//  a.bonuses();//报错，不能调用这个方法</span><br><br>    System.out.<span class="hljs-built_in">println</span>(a.age);<br>    System.out.<span class="hljs-built_in">println</span>(a.salary);<br><br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>运行结果如下</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">经理工作<br>打工人跑路<br>打工人吃饭<br><span class="hljs-number">25</span><br><span class="hljs-number">1000</span><br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>我们用多态的三个前提验证一下</p><ol><li><code>Manager</code> 继承了 <code>Employee</code> 类。</li><li><code>Manager</code> 类重写了 <code>eat</code> 方法。</li><li>父类数据类型的引用指向了子对象， <code>Employee a = new Manager();</code>。</li></ol><p>为什么会出现经理变成了打工人的情况？</p><p>这其实就是多态成员访问的特点：</p><p><strong>成员变量</strong><br>编译看左边(超类)，运行看左边(超类)。</p><p><strong>成员方法</strong></p><p>编译看左边(超类)，运行看右边(子类)。</p><p><strong>静态方法</strong></p><p>编译看左边(超类)，运行看左边(超类)。(静态只与类绑定，和其他一切无关，所以不能被继承)</p><hr><p>这其实也算是多态的一种弊端，即<strong>多态后不能使用子类特有的属性与方法</strong>。</p><p>如果霸王硬上弓，强行转换这个类的属性呢。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>    Employee a = <span class="hljs-built_in">new</span> Manager();<br><br>    Manager b = (Manager) a;<br><br>    b.bonuses();<br>    b.<span class="hljs-keyword">work</span>();<br>    b.eat();<br><br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(b.age);<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(b.salary);<br>&#125;<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>结果是</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">经理领奖金<br>经理工作<br>打工人吃饭<br><span class="hljs-number">30</span><br><span class="hljs-number">10000</span><br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>我们发现硬上弓之后它就从了，b就指向Manager类型了。但是，它仍能使用父类的方法，十分灵活。但我们为什么不一开始就 <code>Manager b = new Manager();</code> 呢。实际上多态就是这样十分灵活的，他可以先以多态形式，如果我们需要强行转换也不是不可以，减少了多余类的创建，也是不错的。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://www.zhihu.com/question/30082151/answer/120520568">JAVA的多态用几句话能直观的解释一下吗？</a> <a href="https://www.dmxcg.xyz/2021/02/27/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81-%E4%B8%8A/#fnref:1">↩</a></li><li>Java核心技术 卷一 P162 </li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode395.至少有K个重复字符的最长子串</title>
    <link href="/2021/02/27/leetcode395-%E8%87%B3%E5%B0%91%E6%9C%89K%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/02/27/leetcode395-%E8%87%B3%E5%B0%91%E6%9C%89K%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="leetcode395-至少有K个重复字符的最长子串"><a href="#leetcode395-至少有K个重复字符的最长子串" class="headerlink" title="leetcode395.至少有K个重复字符的最长子串"></a>leetcode395.至少有K个重复字符的最长子串</h2><p><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">刷题入口</a></p><p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> ，请你找出 <code>s</code> 中的最长子串， 要求该子串中的每一字符出现次数都不少于 <code>k</code> 。返回这一子串的长度。</p><p><strong>示例1：</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs dockerfile">输入：s = <span class="hljs-string">&quot;aaabb&quot;</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：最长子串为 <span class="hljs-string">&quot;aaa&quot;</span> ，其中 <span class="hljs-string">&#x27;a&#x27;</span> 重复了 <span class="hljs-number">3</span> 次。<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">输入：s = <span class="hljs-string">&quot;ababbc&quot;</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">5</span><br>解释：最长子串为 <span class="hljs-string">&quot;ababb&quot;</span> ，其中 <span class="hljs-string">&#x27;a&#x27;</span> 重复了 <span class="hljs-number">2</span> 次， <span class="hljs-string">&#x27;b&#x27;</span> 重复了 <span class="hljs-number">3</span> 次。<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由小写英文字母组成</li><li>1 &lt;= k &lt;= 105</li></ul><p>首先，我们看看负雪明烛大佬的递归方法。<a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/solution/jie-ben-ti-bang-zhu-da-jia-li-jie-di-gui-obla/">原题解地址</a></p><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h3><p>递归看着就挺让人头疼的，但实际用起来还挺好用的。递归的重点就在于把递归函数当成一个普通的函数调用，只管它的输入和输出，不用细想里面的过程会好很多。如果还是头疼，可以吃几片止疼药。</p><p><strong>详细题解：</strong></p><ol><li><strong>递归最基本的是记住递归函数的含义（务必牢记函数定义）</strong>：本题的 <code>longestSubstring(s, k)</code> 函数表示的就是题意，即求一个最长的子字符串的长度，该子字符串中每个字符出现的次数都最少为 <code>k</code> 。函数入参 <code>s</code> 是表示源字符串； <code>k</code> 是限制条件，即子字符串中每个字符最少出现的次数；函数返回结果是满足题意的最长子字符串长度。</li><li><strong>递归的终止条件（能直接写出的最简单 <code>case</code> ）</strong>：如果字符串 <code>s</code> 的长度少于 <code>k</code> ，那么一定不存在满足题意的子字符串，返回 <code>0</code>；</li><li><strong>调用递归（重点）</strong>：如果一个字符 <code>c</code> 在 <code>s</code> 中出现的次数少于 <code>k</code> 次，那么 <code>s</code> 中所有的包含 <code>c</code> 的子字符串都不能满足题意。所以，应该在 <code>s</code> 的所有不包含 <code>c</code> 的子字符串中继续寻找结果：把 <code>s</code> 按照 <code>c</code> 分割（分割后每个子串都不包含 <code>c</code>），得到很多子字符串 <code>t</code>；下一步要求 <code>t</code> 作为源字符串的时候，它的最长的满足题意的子字符串长度（到现在为止，我们把大问题分割为了小问题<code>(s → t)</code>）。此时我们发现，恰好已经定义了函数 <code>longestSubstring(s, k)</code> 就是来解决这个问题的！所以直接把 <code>longestSubstring(s, k)</code> 函数拿来用，于是形成了递归。</li><li><strong>未进入递归时的返回结果</strong>：如果 <code>s</code> 中的每个字符出现的次数都大于 <code>k</code> 次，那么 <code>s</code> 就是我们要求的字符串，直接返回该字符串的长度。</li></ol><p>递归函数是怎么一层一层展开我们不要用自己的脑袋想，交给计算机就完事。</p><p><strong>代码：</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>    public <span class="hljs-built_in">int</span> longest<span class="hljs-constructor">Substring(String <span class="hljs-params">s</span>, <span class="hljs-params">int</span> <span class="hljs-params">k</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s.length<span class="hljs-literal">()</span> &lt; k) return <span class="hljs-number">0</span>;<br>        HashMap&lt;Character, Integer&gt; counter = <span class="hljs-keyword">new</span> <span class="hljs-constructor">HashMap()</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length<span class="hljs-literal">()</span>; i++) &#123;<br>            counter.put(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>, counter.get<span class="hljs-constructor">OrDefault(<span class="hljs-params">s</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">i</span>)</span>, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">char</span> c : counter.key<span class="hljs-constructor">Set()</span>) &#123;<br>            <span class="hljs-keyword">if</span> (counter.get(c) &lt; k) &#123;<br>                <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (String t : s.split(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">c</span>)</span>)) &#123;<br>                    res = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(res, longest<span class="hljs-constructor">Substring(<span class="hljs-params">t</span>, <span class="hljs-params">k</span>)</span>);<br>                &#125;<br>                return res;<br>            &#125;<br>        &#125;<br>        return s.length<span class="hljs-literal">()</span>;<br>    &#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>由于是递归，时间复杂度高是必然的。</p><p><strong>结果：</strong></p><p><a href="https://www.dmxcg.xyz/img/leetcode/395o.jpg"><img src="/2021/02/27/leetcode395-%E8%87%B3%E5%B0%91%E6%9C%89K%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/395o.jpg" alt="result1"></a></p><p>而递归就是把分治法更清晰的展示出来，本质上还是用了分治的方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法 分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一切皆对象:Object类的11个方法</title>
    <link href="/2021/02/25/%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1-Object%E7%B1%BB%E7%9A%8411%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2021/02/25/%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1-Object%E7%B1%BB%E7%9A%8411%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一切皆对象-Object类的11个方法-上"><a href="#一切皆对象-Object类的11个方法-上" class="headerlink" title="一切皆对象:Object类的11个方法(上)"></a>一切皆对象:Object类的11个方法(上)</h2><h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>Object类是一切Java中一切类默认的超类，是包括自建类的所有类继承的一个很重要的类。所有类都可以调用其中的11种方法，这十一种方法具有十分的通用性与易用性，要求每一个都熟练理解并掌握。</p><span id="more"></span><h3 id="1-toString"><a href="#1-toString" class="headerlink" title="1. toString()"></a>1. toString()</h3><p>正如 <code>toString</code> 的名字， <code>toString()</code> 就是将一个对象转换为字符串然后输出。</p><p>让我们来到手撕源码环节</p><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml">public String <span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span> &#123;<br>    return get<span class="hljs-constructor">Class()</span>.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;@&quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span><span class="hljs-keyword">to</span><span class="hljs-constructor">HexString(<span class="hljs-params">hashCode</span>()</span>);<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>一脸蒙蔽，追查源码同样一脸蒙蔽，基本追查不下去，那我们开始实操环节，用我们最经典的 <code>Employee</code> 类做实验。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> Employee &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> double salary;<br>    <span class="hljs-keyword">private</span> LocalDate hireDay;<br><br>    public <span class="hljs-constructor">Employee(String <span class="hljs-params">n</span>, <span class="hljs-params">double</span> <span class="hljs-params">s</span>, <span class="hljs-params">int</span> <span class="hljs-params">year</span>, <span class="hljs-params">int</span> <span class="hljs-params">month</span>, <span class="hljs-params">int</span> <span class="hljs-params">day</span>)</span><br>    &#123;<br>        name = n;<br>        salary = s;<br>        hireDay = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LocalDate</span>.</span></span><span class="hljs-keyword">of</span>(year, month, day);<br>    &#125;<br><br>    public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>        Employee e = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Employee(<span class="hljs-string">&quot;abc&quot;</span>, 1, 2000, 1, 1)</span>;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(e.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br><br>        Integer i = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Integer(<span class="hljs-string">&quot;123&quot;</span>)</span>;<span class="hljs-comment">//我们再拿Integer做实验</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(i);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(i.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(i.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>.get<span class="hljs-constructor">Class()</span>);<span class="hljs-comment">//getClass()类同样是Object中的一个方法，作用是返回类名，我们在下面详细的介绍。</span><br>    &#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>结果是</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">inheritance</span>.Employee@<span class="hljs-number">16</span>d<span class="hljs-number">3586</span><br><span class="hljs-attribute">123</span><br><span class="hljs-attribute">123</span><br><span class="hljs-attribute">class</span> java.lang.String<br><span class="hljs-attribute">Copy</span><br></code></pre></td></tr></table></figure><p>我们发现，<code>i.toString()</code> 并没有基类所带的 <code>@</code> ，说明它可能放弃了基类的教导，转身重写了 <code>toString()</code>，我们追查一下。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public String <span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span> &#123;<br>    return <span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">value</span>)</span>;<br>&#125;<br><br>public static String <span class="hljs-keyword">to</span><span class="hljs-constructor">String(<span class="hljs-params">int</span> <span class="hljs-params">i</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i<span class="hljs-operator"> == </span>Integer.MIN_VALUE)<br>        return <span class="hljs-string">&quot;-2147483648&quot;</span>;<br>    <span class="hljs-built_in">int</span> size = (i &lt; <span class="hljs-number">0</span>) ? <span class="hljs-built_in">string</span><span class="hljs-constructor">Size(-<span class="hljs-params">i</span>)</span> + <span class="hljs-number">1</span> : <span class="hljs-built_in">string</span><span class="hljs-constructor">Size(<span class="hljs-params">i</span>)</span>;<br>    <span class="hljs-built_in">char</span><span class="hljs-literal">[]</span> buf = <span class="hljs-keyword">new</span> <span class="hljs-built_in">char</span><span class="hljs-literal">[<span class="hljs-identifier">size</span>]</span>;<br>    get<span class="hljs-constructor">Chars(<span class="hljs-params">i</span>, <span class="hljs-params">size</span>, <span class="hljs-params">buf</span>)</span>;<br>    return <span class="hljs-keyword">new</span> <span class="hljs-constructor">String(<span class="hljs-params">buf</span>, <span class="hljs-params">true</span>)</span>;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>果然不错，凡是我们知道能用串表示出来的，经过追查，都忘了初心，变成了我们更好用的样子，即直接转换为字符串。只有那些不能用串表示的，才会接过 <code>Object</code> 的摊子。而我们此刻应该去和那些忘了初心的类学习，重写 <code>toString</code>。就以打工人这个类为例。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><span class="hljs-comment">//表示对父类方法的重写</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Employee&#123;&quot;</span> +<br>            <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>            <span class="hljs-string">&quot;, salary=&quot;</span> + salary +<br>            <span class="hljs-string">&quot;, hireDay=&quot;</span> + hireDay +<br>            <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>我们 <code>System.out.println(e.toString());</code> 的结果如下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Employee</span>&#123;name=&#x27;abc&#x27;, salary=<span class="hljs-number">1</span>.<span class="hljs-number">0</span>, hireDay=<span class="hljs-number">2000</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span>&#125;//我这才发现这个苦逼打工人的薪水只有一块钱<br><span class="hljs-attribute">Copy</span><br></code></pre></td></tr></table></figure><p>果然重写之后的 <code>toString</code> 更加适合我们去用。</p><p>这其实也奠定了一个基调，部分时候 <code>Object</code> 的方法要重写成适合使用的模样。</p><h3 id="2-equals"><a href="#2-equals" class="headerlink" title="2. equals()"></a>2. equals()</h3><p><code>equals</code> 方法用于检测一个对象是否等于另一个对象，这是一个合理的默认行为：如果两个对象的引用相等，这两个对象肯定就相等。如果基于状态检测对象的相等于，两个对象有相同的状态，才认为这两个对象是相等的。</p><p>话不多说，我们上一段代码:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">String</span> name)</span></span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span></span>&#123;<br>    <span class="hljs-keyword">String</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;100&quot;</span>);<br>    <span class="hljs-keyword">String</span> s4 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;100&quot;</span>);<br>    System.out.<span class="hljs-built_in">println</span>(s3.<span class="hljs-built_in">equals</span>(s4));<br><br>    Integer itr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Integer</span>(<span class="hljs-string">&quot;123&quot;</span>);<br>    Long lon = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Long</span>(<span class="hljs-string">&quot;123&quot;</span>);<br>    System.out.<span class="hljs-built_in">println</span>(itr.<span class="hljs-built_in">equals</span>(lon));<br><br>    Person person1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>    Person person2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>    System.out.<span class="hljs-built_in">println</span>(person1.<span class="hljs-built_in">equals</span>(person2));<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>结果是 <code>true false false</code></p><p>我们要想知道为什么是这个结果，首先就要研究一下 <code>equals()</code> 的源码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">equals</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> obj</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span>(<span class="hljs-built_in">this</span> == obj);<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>很简单，就是判断两个引用是否指向同一个对象，由于 <code>Person</code> 类并没有重写 <code>equals</code> ，所以继承的就是 <code>Object</code> 中的<code>equals()</code> ，在内存的观点来看，两个 <code>Person</code> 对象显然是不同的。</p><p><a href="https://www.dmxcg.xyz/img/Java/Object/equals1.jpg"><img src="/2021/02/25/%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1-Object%E7%B1%BB%E7%9A%8411%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/equals1.jpg" alt="在内存中的示意图"></a></p><p><a href="https://www.dmxcg.xyz/img/Java/Object/equals1.jpg">在内存中的示意图</a></p><p>在 <code>Integer</code> 中，<code>equals</code> 的实现如下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-type">boolean</span> equals(<span class="hljs-keyword">Object</span> obj)&#123;<br>    <span class="hljs-keyword">if</span>(obj instanceof <span class="hljs-type">Integer</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> == ((<span class="hljs-type">Integer</span>)obj).intValue();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>意思很明确，判断对象类型是否可以为 <code>Integer</code> (参考我的上一篇: 类与继承)，这里 <code>lon</code> 是 <code>Long</code> 类型，所有结果肯定是 <code>false</code> 。</p><p>最后我们看看 <code>String</code> 的实现</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> equals(<span class="hljs-keyword">Object</span> anObject) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == anObject) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (anObject <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">String</span>) &#123;<br>        <span class="hljs-keyword">String</span> anotherString = (<span class="hljs-keyword">String</span>)anObject;<br>        <span class="hljs-built_in">int</span> n = value.length;<br>        <span class="hljs-keyword">if</span> (n == anotherString.value.length) &#123;<br>            <span class="hljs-built_in">char</span> v1[] = value;<br>            <span class="hljs-built_in">char</span> v2[] = anotherString.value;<br>            <span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (n-- != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (v1[i] != v2[i])<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>如果都指向一个引用，毋庸置疑是相等的。接下来有三个步骤</p><ol><li>判断是否为String类型。</li><li>判断这两个字符串底层char数组的长度是否一致。</li><li>循环判断每一个char字符是否相等。</li></ol><p>我们的s3，s4显然不满足第一步，但可以过了下面三关，成功打印出 <code>true</code> 。</p><p>显然，我们超类 <code>Object</code> 的 <code>equals()</code> 只是判断二者引用是否相同，大部分时候，还是需要我们重写 <code>equals()</code> 来定义是否相等。</p><p>由此，我们能回答一个面试的经典问题： <code>==</code> 和 <code>equals()</code> 有什么区别？</p><p><code>==</code> 指的就是引用相同，和超类中的 <code>equals</code> 意义相同，而大部分情况，我们需要重写 <code>equals</code> 来定义两个对象是否相同，这时候含义就与 <code>==</code> 不同了。</p><h3 id="3-hashCode"><a href="#3-hashCode" class="headerlink" title="3. hashCode()"></a>3. hashCode()</h3><p><code>hashCode</code> 方法是由对象导出的一个整形值。散列码没有规律，如果 <code>x</code> 和 <code>y</code> 是两个不同的对象，那么 <code>x.hashCode()</code> 和 <code>y.hashCode()</code> 基本上不会相同。简单的来说，<code>hashCode</code>就像是一个签名，当两个对象的 <code>hashcode</code> 一样，那么两个对象就可能一样，如果不一样，那两个对象肯定不是同一个对象。等于 <code>hashcode</code> 可以确定一个大范围，然后可以使用 <code>equals</code> 来比较。</p><p>即 <code>对象1</code> 和 <code>对象2</code> 签名(散列码) 相等并不能确定两个对象相等，凡是如果两个对象相等，它们的散列码一定是相等的。</p><p>所以 <code>hashcode</code> 可以减少 <code>equals</code> 比较的次数，提高运算效率。</p><p>我们来看一下没有重写的 <code>hashCode</code> 在实战中的表现</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache">    <span class="hljs-attribute">Employee</span> e = new Employee(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-attribute">Employee</span> d = new Employee(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-attribute">System</span>.out.println(e.hashCode()== d.hashCode());<br><span class="hljs-attribute">Copy</span><br></code></pre></td></tr></table></figure><p>结果是 <code>false</code> 。在 <code>equals</code> 中，我们也试验了，<code>e</code> 是不等于 <code>d</code> 的，如果先用 <code>hashCode</code> 检测，就能更有效率的发现二者不相等了。所以我们一般用 <code>hashcode</code> 来进行比较两个东西是不是一样的，可以很容易的排除许多不一样的东西。</p><p><code>hashCode</code> 在官方源码的文档可以提取处几个要点：</p><ol><li><code>hashCode</code> 的存在主要是用于查找的快捷性，如 <code>Hashtable</code> ，<code>HashMap</code>等，<code>hashCode</code>是用来在散列存储结构中确定对象的存储地址的；</li><li>如果两个对象相同，就是适用于 <code>equals(Java.lang.Object)</code> 方法，那么这两个对象的 <code>hashCode</code> 一定要相同</li><li>如果对象的 <code>equals</code> 方法被重写，那么对象的 <code>hashCode</code> 也尽量重写，并且产生 <code>hashCode</code> 使用的对象，一定要和 <code>equals</code> 方法中使用的一致，否则就会违反上面提到的第2点</li><li>两个对象的 <code>hashCode</code> 相同，并不一定表示两个对象就相同，也就是不一定适用于 <code>equals(java.lang.Object)</code> 方法，只能够说明这两个对象在散列存储结构中，如 <code>Hashtable</code> ，他们“存放在同一个篮子里”。</li></ol><p>但我们经过上面两轮发现，<code>Object</code> 中的方法大部分是需要重写的，而 <code>hashCode</code> 在实际应用中非常重要，是需要重写的重中之重，下面我们还是用打工人这个类，重写一下 <code>hashCode</code> 方法。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>public <span class="hljs-built_in">int</span> hash<span class="hljs-constructor">Code()</span> &#123;<br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>hash(get<span class="hljs-constructor">Name()</span>, get<span class="hljs-constructor">Salary()</span>, hireDay);<br>&#125;<br><br>@Override<br>public boolean equals(Object o) &#123;<br>    <span class="hljs-keyword">if</span> (this<span class="hljs-operator"> == </span>o) return <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (!(o instanceof Employee)) return <span class="hljs-literal">false</span>;<br>    Employee employee = (Employee) o;<br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Double</span>.</span></span>compare(employee.get<span class="hljs-constructor">Salary()</span>, get<span class="hljs-constructor">Salary()</span>)<span class="hljs-operator"> == </span><span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>equals(get<span class="hljs-constructor">Name()</span>, employee.get<span class="hljs-constructor">Name()</span>)<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>equals(hireDay, employee.hireDay);<br>&#125;<br><br>public static void main(String<span class="hljs-literal">[]</span> args) &#123;<br>    Employee e = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Employee(<span class="hljs-string">&quot;abc&quot;</span>, 1, 2000, 1, 1)</span>;<br>    Employee d = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Employee(<span class="hljs-string">&quot;abc&quot;</span>, 1, 2000, 1, 1)</span>;<br><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(e.hash<span class="hljs-constructor">Code()</span>== d.hash<span class="hljs-constructor">Code()</span>);<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(e.equals(d));<br>Copy<br></code></pre></td></tr></table></figure><p>结果是:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">true</span><br><span class="hljs-keyword">true</span><br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>和上面没有重写的结果显然就不一样了，实际上这两个对象除了地址不一样，别的不能说几分相像，简直是一模一样。</p><p>但是我们实际情况中肯定更复杂，一个打工人的属性肯定也不会只有这些，一般是按照 <code>id</code> 来确认 <code>hashcode</code> 再确认是否相等的。</p><p>PS: 在覆写 <code>equals()</code> 方法的时候也必须覆写 <code>hashCode()</code> 方法。这样才能确保相等的两个对象拥有相等的 <code>.hashCode</code>。</p><p>再使用 <code>IDEA</code> 进行编程时，如果你需要重写一般会为你生成一个较好的方案，但仍要实际情况实际分析，选择效率与准确性最高的方法。</p><h3 id="4-clone"><a href="#4-clone" class="headerlink" title="4. clone()"></a>4. clone()</h3><p>提到 <code>clone</code> ，显而易见，就是复制一个对象，正如 <code>C++</code> 一样，复制同样分为深复制与浅复制。</p><p>浅复制指被复制对象的所有数据成员都含有与原来对象相同的值，包括引用类型的数据成员，即不复制引用类型数据成员所指向的对象。深复制实现的是数据成员的全面复制，包括复制产生引用成员所指向的对象的副本。</p><p>接下来通过几个实例来分析</p><p>实例1</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>    Employee a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Employee</span>(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    Employee b = a;<br><br>    System.out.<span class="hljs-built_in">println</span>(a);<br>    System.out.<span class="hljs-built_in">println</span>(b);<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>结果是</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">inheritance</span>.Employee@c<span class="hljs-number">3</span>d<span class="hljs-number">3</span>dc<span class="hljs-number">82</span><br><span class="hljs-attribute">inheritance</span>.Employee@c<span class="hljs-number">3</span>d<span class="hljs-number">3</span>dc<span class="hljs-number">82</span><br><span class="hljs-attribute">Copy</span><br></code></pre></td></tr></table></figure><p>其实我们这儿就可以发现，直接打印一个对象就是打印它 <code>toString()</code> 的值，如果重写了，就打印重写的值。这两个指向的地址显然一模一样，就是复制了引用。实际上，这就是<strong>浅复制</strong>。</p><p>从JVM的角度来看</p><p><a href="https://www.dmxcg.xyz/img/Java/Object/JVM1.jpg"><img src="/2021/02/25/%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1-Object%E7%B1%BB%E7%9A%8411%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/JVM1.jpg" alt="不要在意为什么是dog"></a></p><p>实例2</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> throws CloneNotSupportedException </span>&#123;<span class="hljs-comment">//抛出异常</span><br>    Employee a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Employee</span>(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    Employee b = (Employee) a.<span class="hljs-built_in">clone</span>();<br><br>    System.out.<span class="hljs-built_in">println</span>(a);<br>    System.out.<span class="hljs-built_in">println</span>(b);<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>运行，我们发现，就算我们抛出了异常，依然出错。我们就该知道，<code>clone</code> 这个方法不简单, 下面我们来介绍如何用他进行复制。</p><p><code>Object</code> 的 <code>clone()</code> 方法，实现了对象中各个属性的复制，但它的可见范围是 <code>protected</code> 的，所以实体类使用克隆的前提是：</p><ol><li>实现Cloneable接口，这是一个标记接口，自身没有方法。</li><li>覆盖clone()方法，可见性提升为public。</li></ol><p>让我们实现一下</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> class Employee implements Cloneable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;<br>    <span class="hljs-keyword">private</span> LocalDate hireDay;<br><br>    @Override<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">Object</span> clone() <span class="hljs-keyword">throws</span> CloneNotSupportedException&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Employee(<span class="hljs-keyword">String</span> n, <span class="hljs-keyword">double</span> s, <span class="hljs-built_in">int</span> <span class="hljs-built_in">year</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">month</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">day</span>)<br>    &#123;<br>        name = n;<br>        salary = s;<br>        hireDay = LocalDate.of(<span class="hljs-built_in">year</span>, <span class="hljs-built_in">month</span>, <span class="hljs-built_in">day</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        Employee a = <span class="hljs-keyword">new</span> Employee(<span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        Employee b = (Employee) a.clone();<br><br>        System.out.<span class="hljs-built_in">println</span>(a==b);<br>    &#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p><code>implements Cloneable</code> 即表示这个类是可以复制的，这时候才能对其对象进行复制。</p><p>运行的结果是 <code>false</code>, 即 <code>OBject</code> 的 <code>clone</code>，并不能把他俩拽到同一个引用，从JVM上看</p><p><a href="https://www.dmxcg.xyz/img/Java/Object/JVM2.jpg"><img src="/2021/02/25/%E4%B8%80%E5%88%87%E7%9A%86%E5%AF%B9%E8%B1%A1-Object%E7%B1%BB%E7%9A%8411%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/JVM2.jpg" alt="堆"></a></p><p>其实这就是<strong>深复制</strong>，创建了新的一个对象而不是简单的引用。发现这两个对象也是两个地址的。</p><p>大部分情况，我们还是要用深复制，且要根据实际情况考虑是否重写方法</p><h3 id="5-finalize"><a href="#5-finalize" class="headerlink" title="5. finalize()"></a>5. finalize()</h3><p><code>Java9</code> 开始，<code>finalize()</code> 在源码上被标注上了 <code>@Deprecated</code> , 代表这finalize的正式退休。</p><p><code>finalize</code> 方法原本作用就是处理系统资源、执行其他清理或者对象自救，实际上，<code>Object</code> 中的 <code>finalize</code> 只是建议回收资源，并没有正式析构，大部分时候对对象回收还是要重写 <code>finalize</code> 的。</p><p>既然已经退休了，我们就不再学习它了，等到资源回收专题会讲解更适用的方法。</p><h3 id="6-getClass"><a href="#6-getClass" class="headerlink" title="6. getClass()"></a>6. getClass()</h3><p><code>getClass</code> 方法将返回一个对象所属的类，顾名思义，也就是返回对象的类的名称。</p><p>就比如我们的打工人类，我们再次拿来做示范</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Employee a = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Employee(<span class="hljs-string">&quot;abc&quot;</span>, 1, 2000, 1, 1)</span>;<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(a.get<span class="hljs-constructor">Class()</span>);<br>Copy<br></code></pre></td></tr></table></figure><p>结果是</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">class</span> inheritance.Employee<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>很简单，就是返回类名。 <code>getClass()</code> 的实际作用就是获得这个类，进而通过这个类来获取与之相关的信息。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这个是上篇，下篇的方法大多和多线程关系巨大，还比较高级，先掌握好基础，多练习这些方法，在做项目时根据项目的实际情况来重写相对应的方法。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[^1] <a href="https://zhuanlan.zhihu.com/p/27573287">说说Java里的equals（上）</a><br>[^2] <a href="https://zhuanlan.zhihu.com/p/26814793">Java中的HashCode</a><br>[^3] <a href="https://blog.csdn.net/qq_33314107/article/details/80271963">java对象clone()方法</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何上线一个制作完成的网页项目</title>
    <link href="/2021/02/24/%E5%A6%82%E4%BD%95%E4%B8%8A%E7%BA%BF%E4%B8%80%E4%B8%AA%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E7%9A%84%E7%BD%91%E9%A1%B5%E9%A1%B9%E7%9B%AE/"/>
    <url>/2021/02/24/%E5%A6%82%E4%BD%95%E4%B8%8A%E7%BA%BF%E4%B8%80%E4%B8%AA%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E7%9A%84%E7%BD%91%E9%A1%B5%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="如何上线一个制作完成的网页项目"><a href="#如何上线一个制作完成的网页项目" class="headerlink" title="如何上线一个制作完成的网页项目"></a>如何上线一个制作完成的网页项目</h1><p>以下操作以腾讯云为例</p><h2 id="1-租用域名"><a href="#1-租用域名" class="headerlink" title="1. 租用域名"></a><strong>1. 租用域名</strong></h2><p><img src="/2021/02/24/%E5%A6%82%E4%BD%95%E4%B8%8A%E7%BA%BF%E4%B8%80%E4%B8%AA%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E7%9A%84%E7%BD%91%E9%A1%B5%E9%A1%B9%E7%9B%AE/DNSPod.png" alt="购买域名"></p><p>搜索自己喜欢的域名</p><p><strong>例:</strong></p><p><code>www.example.com</code>需要搜索example</p><p><a href="https://www.dmxcg.xyz/img/HTML/example.png"><img src="/2021/02/24/%E5%A6%82%E4%BD%95%E4%B8%8A%E7%BA%BF%E4%B8%80%E4%B8%AA%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E7%9A%84%E7%BD%91%E9%A1%B5%E9%A1%B9%E7%9B%AE/example.png" alt="result"></a></p><p>顶级域名不一定需要<code>com</code>，但不建议使用中文</p><p>PS: 域名购买越长期越优惠</p><h2 id="2-租用一台够用的服务器"><a href="#2-租用一台够用的服务器" class="headerlink" title="2. 租用一台够用的服务器"></a><strong>2. 租用一台够用的服务器</strong></h2><ul><li><p>如何选择服务器?</p><p>个人小网站访问量较少(一天不到1000)，最低配置已经能满足需求。</p><p>流量，数据量，访问量大的按照实际情况购买。</p><p>所在地点尽量购买空间距离近的服务器，但是在国内访问速度差距不大。</p><p>PS: 建议购买有独立公网IP的服务器，<strong>学生认证非常非常优惠!!</strong></p></li><li><p>如何租用服务器?</p><p>*<strong>学生优惠：*</strong><br><a href="https://www.dmxcg.xyz/img/HTML/server.png"><img src="/2021/02/24/%E5%A6%82%E4%BD%95%E4%B8%8A%E7%BA%BF%E4%B8%80%E4%B8%AA%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E7%9A%84%E7%BD%91%E9%A1%B5%E9%A1%B9%E7%9B%AE/server.png" alt="学生优惠"></a></p><p>*<strong>普通租用：*</strong><br><a href="https://www.dmxcg.xyz/img/HTML/serverbuy.png"><img src="/2021/02/24/%E5%A6%82%E4%BD%95%E4%B8%8A%E7%BA%BF%E4%B8%80%E4%B8%AA%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E7%9A%84%E7%BD%91%E9%A1%B5%E9%A1%B9%E7%9B%AE/serverbuy.png" alt="购买服务器"></a></p><p>操作系统建议选常规服务器操作系统CentOS，三种都是命令行操作</p><p>PS: 新用户同样有优惠，但必须第一次购买的就是服务器，后续续费服务器没有优惠</p><p>购买之后在进入云服务器实例中即可以看到(区域一定要选自己购买的区域才能看到)<br><a href="https://www.dmxcg.xyz/img/HTML/instance.png"><img src="/2021/02/24/%E5%A6%82%E4%BD%95%E4%B8%8A%E7%BA%BF%E4%B8%80%E4%B8%AA%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E7%9A%84%E7%BD%91%E9%A1%B5%E9%A1%B9%E7%9B%AE/instance.png" alt="实例"></a></p></li></ul><h2 id="3-域名备案"><a href="#3-域名备案" class="headerlink" title="3. 域名备案"></a><strong>3. 域名备案</strong></h2><p><a href="https://cloud.tencent.com/product/ba">腾讯云备案地址</a></p><p><a href="https://www.dmxcg.xyz/img/HTML/record.png"><img src="/2021/02/24/%E5%A6%82%E4%BD%95%E4%B8%8A%E7%BA%BF%E4%B8%80%E4%B8%AA%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E7%9A%84%E7%BD%91%E9%A1%B5%E9%A1%B9%E7%9B%AE/record.png" alt="备案流程"></a></p><p>按照租用服务器的网站要求进行备案，国内域名服务器只有备案完成的域名才能正常DNS解析。</p><p>期间保持电话畅通。</p><p>PS:<br>· <strong>一切问题工作人员都会联系你帮你解决，不需要担心。</strong><br>· 网站标题不会在任何地方展示，仅作为备案。<br>· 个人网站网站服务内容选其他，备注部分正常填写即可。<br>· 按照要求验证提交，之后坐等就可以了，期间把网站写好，备案完成即可上线。<br>· 备案完成后会受到公安备案信息，建议按照信息要求进行公安备案。</p><h2 id="4-腾讯云静态网站托管上线网站"><a href="#4-腾讯云静态网站托管上线网站" class="headerlink" title="4. 腾讯云静态网站托管上线网站"></a><strong>4. 腾讯云静态网站托管上线网站</strong></h2><p><a href="https://cloud.tencent.com/product/wh">静态网站托管</a></p><p>如果访问量不大，基本为免费使用</p><p><a href="https://www.dmxcg.xyz/img/HTML/static1.png"><img src="/2021/02/24/%E5%A6%82%E4%BD%95%E4%B8%8A%E7%BA%BF%E4%B8%80%E4%B8%AA%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E7%9A%84%E7%BD%91%E9%A1%B5%E9%A1%B9%E7%9B%AE/static1.png" alt="第一步"></a></p><p><a href="https://www.dmxcg.xyz/img/HTML/static2.png"><img src="/2021/02/24/%E5%A6%82%E4%BD%95%E4%B8%8A%E7%BA%BF%E4%B8%80%E4%B8%AA%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E7%9A%84%E7%BD%91%E9%A1%B5%E9%A1%B9%E7%9B%AE/static2.png" alt="第二步"></a></p><p>(免费一定要勾起)</p><p><a href="https://www.dmxcg.xyz/img/HTML/static3.png"><img src="/2021/02/24/%E5%A6%82%E4%BD%95%E4%B8%8A%E7%BA%BF%E4%B8%80%E4%B8%AA%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E7%9A%84%E7%BD%91%E9%A1%B5%E9%A1%B9%E7%9B%AE/static3.png" alt="第三步"></a></p><p><strong>HTML网页主页名称一定要用index.html</strong></p><p>其他文件放在src、img等中以文件夹形式上传</p><p><a href="https://www.dmxcg.xyz/img/HTML/upload.png"><img src="/2021/02/24/%E5%A6%82%E4%BD%95%E4%B8%8A%E7%BA%BF%E4%B8%80%E4%B8%AA%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E7%9A%84%E7%BD%91%E9%A1%B5%E9%A1%B9%E7%9B%AE/upload.png" alt="upload"></a></p><p>随后云产品中选择DNS解析进入</p><p><a href="https://www.dmxcg.xyz/img/HTML/DNS.png"><img src="/2021/02/24/%E5%A6%82%E4%BD%95%E4%B8%8A%E7%BA%BF%E4%B8%80%E4%B8%AA%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E7%9A%84%E7%BD%91%E9%A1%B5%E9%A1%B9%E7%9B%AE/DNS.png" alt="DNSPOD"></a></p><ul><li>DNS解析<ul><li>添加解析</li><li>添加记录</li><li>主机记录为域名前的字符串，例如www，如果想通过域名直接访问，则填@</li><li>记录类型选A, 记录值填服务器的IP地址。</li></ul></li></ul><p>回到静态网站托管界面，进入详细配置，选择添加域名(全称)</p><p>SSL证书处点击申请SSL证书</p><p><a href="https://www.dmxcg.xyz/img/HTML/SSL.png"><img src="/2021/02/24/%E5%A6%82%E4%BD%95%E4%B8%8A%E7%BA%BF%E4%B8%80%E4%B8%AA%E5%88%B6%E4%BD%9C%E5%AE%8C%E6%88%90%E7%9A%84%E7%BD%91%E9%A1%B5%E9%A1%B9%E7%9B%AE/SSL.png" alt="SSL证书"></a></p><p>申请免费SSL证书，一路推荐设置即可</p><p>获得SSL证书后，回到创建自定义域名刷新后出现SSL证书，进入部署。</p><p>复制CNAME地下的地址，到DNS解析中修改添加的记录为CNAME，记录值为复制的地址。</p><p>此刻终于可以通过域名访问自己本地写好的网页，上线成功！！</p><h2 id="5-参考视频"><a href="#5-参考视频" class="headerlink" title="5. 参考视频"></a><strong>5. 参考视频</strong></h2><p><a href="https://www.bilibili.com/video/BV18a4y1Y7e9">BV18a4y1Y7e9</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java类与继承</title>
    <link href="/2021/02/24/Java%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF/"/>
    <url>/2021/02/24/Java%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="类与继承"><a href="#类与继承" class="headerlink" title="类与继承"></a>类与继承</h2><h3 id="1-定义类"><a href="#1-定义类" class="headerlink" title="1. 定义类"></a><strong>1. 定义类</strong></h3><hr><p>类(class)是构造对象的模板与蓝图，由类构造(construct)对象的过程称之为实例(instance) 。标准JAVA库中提供了几千个类可用于各种目的。</p><p>封装(encapsulation)从形式上看，封装就是把数据和行为组合在一个包里，并对对象的使用者隐藏具体的实现方式。对象中的数据称之为实例字段(instance field)，操作数据的过程称为方法(method)。作为一个类的实例，特定对象都有一组特定的实例字段值。这些值的集合就是这个对象的当前状态，再类上调用任何方法都可能改变的个状态。</p><p><strong>· 举例:</strong></p><figure class="highlight processing"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> class Employee &#123;<br>    <span class="hljs-comment">// instance field</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;<br>    <span class="hljs-keyword">private</span> LocalDate hireDay;<br>    <br>    <span class="hljs-comment">// constructor</span><br>    <span class="hljs-keyword">public</span> Employee(<span class="hljs-keyword">String</span> n, <span class="hljs-keyword">double</span> s, <span class="hljs-built_in">int</span> <span class="hljs-built_in">year</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">month</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">day</span>)<br>    &#123;<br>        name = n;<br>        salary = s;<br>        hireDay = LocalDate.of(<span class="hljs-built_in">year</span>, <span class="hljs-built_in">month</span>, <span class="hljs-built_in">day</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// a method</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> getName()&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    ...<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><h3 id="2-继承类"><a href="#2-继承类" class="headerlink" title="2. 继承类"></a><strong>2. 继承类</strong></h3><hr><h4 id="2-1-定义子类"><a href="#2-1-定义子类" class="headerlink" title="2.1 定义子类"></a>2.1 定义子类</h4><p>假设Manager和Employee的关系，继承Employee类来定义Manager，使用关键字extends来辨表示继承。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span>&#123;<br>    add methods and fields<br>&#125;<br><span class="hljs-type">Copy</span><br></code></pre></td></tr></table></figure><p>关键字extends表明正在构造的新类派生于一个已存在的类。这个已存在的类称为超类(superclass)，基类(base class)，父类(parent class); 新类称为子类(subclass)。一般称为超类与子类。</p><p>在Manager类中可以设立新的方法，Employee类的对象不可用。Employee类中的一切public方法在Manager中可用。</p><h4 id="2-2-覆盖方法"><a href="#2-2-覆盖方法" class="headerlink" title="2.2 覆盖方法"></a>2.2 覆盖方法</h4><p>以上的Employee类为例，salary是一个私有变量，所以在Manager类中不能直接调用，在不改变私有的情况下，如何使用salary变量?</p><p>可以使用Employee中的public方法getsalary()返回salary，当然Manager类同样继承了salary方法，在salary()中调用salary()会构成无限递归，此时可以使用:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">super</span>.getSalary()<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>这个语句调用的是超类中的方法。要使用这个变量可以用<code>double salary = super.getSalary();</code>来得到数值。</p><p>子类不能删除任何超类中的字段。</p><h4 id="2-3-子类构造器"><a href="#2-3-子类构造器" class="headerlink" title="2.3 子类构造器"></a>2.3 子类构造器</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs processing">Public Manager(<span class="hljs-keyword">String</span> name, <span class="hljs-keyword">double</span> salary, <span class="hljs-built_in">int</span> <span class="hljs-built_in">year</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">month</span>, <span class="hljs-built_in">int</span> <span class="hljs-built_in">day</span>)<br>&#123;<br>    <span class="hljs-keyword">super</span>(name, salary, <span class="hljs-built_in">year</span>, <span class="hljs-built_in">month</span>, <span class="hljs-built_in">day</span>);<br>    bonus = <span class="hljs-number">0</span>;<span class="hljs-comment">//Manager类比子类多了bones字段</span><br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p><code>super(name, salary, year, month, day);</code>是调用超类的构造器。</p><p>如果子类的构造器没有显示的调用超类的构造器，讲自动地调用超类的无参构造器。如果超类没有无参构造器，Java便会报告一个错误。</p><p>如果声明一个Employee对象 e， e既可以引用Employee类型的变量，也可以引用Manager类型的变量。虚拟机知道e的实际引用对象类型，可以正确的调用相应的方法。</p><p>一个对象可以指示多种实际类型的现象称为多态(polymorphism)。在运行时候能够动态的选择适用的方法，称为动态绑定(dynamic binding)。</p><h4 id="2-4-继承层次"><a href="#2-4-继承层次" class="headerlink" title="2.4 继承层次"></a>2.4 继承层次</h4><p>继承不仅限于一个层次。例如Manager类同样可以派生出新的类。由一个公共超类派生出的所有类的集合称为继承层次(inheritance hierarchy)。在继承层次中，从某个特定的类到其祖先的路径称为该类的继承链(inheritance chain)。</p><p><a href="https://www.dmxcg.xyz/img/Java/chain.png"><img src="/2021/02/24/Java%E7%B1%BB%E4%B8%8E%E7%BB%A7%E6%89%BF/chain.png" alt="inheritance chain"></a></p><h4 id="2-5-多态"><a href="#2-5-多态" class="headerlink" title="2.5 多态"></a>2.5 多态</h4><p>继承的规则为“is-a”关系，例如每个经理都是员工，但每个员工并不是经理，所以讲Manager类设计为Employee的子类是有道理的。</p><p>“is-a”规则的另一种表述是替换原则(substitution principle)。他指出程序中出现超类对象任何地方都可以使用子类对象替换。</p><p><strong>例如:</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Employee e;<br>e = <span class="hljs-keyword">new</span> <span class="hljs-type">Employee</span>(...); <span class="hljs-comment">//Employee object expected</span><br>e = <span class="hljs-keyword">new</span> <span class="hljs-type">Manager</span>(...); <span class="hljs-comment">//OK, Manager can be used as well</span><br>Copy<br></code></pre></td></tr></table></figure><p>正如上述的代码，Java中，对象变量是多态的(polymorphic)，一个超类可以引用其任何一个子类。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe">Manager boss = <span class="hljs-keyword">new</span> <span class="hljs-type">Manager</span>(...);<br>Employee[] staff = <span class="hljs-keyword">new</span> <span class="hljs-type">Employee</span>[<span class="hljs-number">3</span>];<br>staff[<span class="hljs-number">0</span>] = boss;<br>Copy<br></code></pre></td></tr></table></figure><p>是完全正确的。</p><p>但是超类的引用不能赋给子类变量</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">Manager m = staff[i]; <span class="hljs-regexp">//</span>ERROR<br>Copy<br></code></pre></td></tr></table></figure><h4 id="2-6-理解方法调用"><a href="#2-6-理解方法调用" class="headerlink" title="2.6 理解方法调用"></a>2.6 理解方法调用</h4><p>准确地理解如何在对象上应用方法调用很重要。下面假设要调用x.f(args)，隐式参数x声明为类C的一个对象。下面是调用过程的详细描述：</p><ol><li><p>编译器查看对象地声明类型和方法名。注意可能存在多个方法名为f但是参数类型不一样的方法。例如f(int)/f(String)。编译器会一一列举C类中所有名为f的方法和其超类中所有名为f而且可访问的方法。(除private方法)</p></li><li><p>接下来，编译器要确定方法中调用的参数类型。如果在所有名为f的方法中存在一个与提供参数类型完全匹配的方法，就选用这个方法。这个过程称为重载解析(overloading resolution)。如果编译器没有找到参数类型匹配的方法，或者类型转换后有多个方法匹配，编译器会报告一个错误。</p><p><strong>PS:</strong></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">例如，<span class="hljs-built_in">f</span>(int)和<span class="hljs-built_in">f</span>(String)是两个有相同名字不同签名的方法。<br>如果子类中定义了一个和超类签名相同的方法，那么子类中这个方法就会覆盖掉超类中这个相同签名的方法。<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure></li><li><p>如果是private方法、 static方法、 final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法。这称为静态绑定(static binding)。相对应的，如果调用的方法依赖于隐式参数的实际类型，就必须运行时使用动态绑定。</p></li><li><p>程序运行并且采用动态绑定调用方法时，虚拟机必须调用与x所引用对象的实际类型对于的那个方法。假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就会调用这个方法；否则，将在D类的超类中寻找f(String)，以此类推。</p></li></ol><p>每次调用方法都要完成这个搜索，事件开销相当大。因此虚拟机预先为每个类计算了一个方法表(method table)，其中列出所有方法的签名和要调用的实际方法。这样一来在真正调用的时候，虚拟机查这个表就可以了。</p><h4 id="2-7-阻止继承-final类和方法"><a href="#2-7-阻止继承-final类和方法" class="headerlink" title="2.7 阻止继承: final类和方法"></a>2.7 阻止继承: final类和方法</h4><p>不允许扩展的类被称为final类。在定义类的时候使用了final修饰符就表明了这个类是final类。</p><p>声明格式如下:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span><br>&#123;<br>    ...<br>&#125;<br><span class="hljs-type">Copy</span><br></code></pre></td></tr></table></figure><p>类中的某个特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法。</p><p>例如:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span><br><span class="hljs-class">&#123;</span><br>    ...<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    ...<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>字段同样可以声明final。对于字段来说赋值final之后就不允许在改变值。同样，将方法和类声明final原因是确保它们不会再子类中被改变语义。String是常见的final类。</p><h4 id="2-8-强制类型转换"><a href="#2-8-强制类型转换" class="headerlink" title="2.8 强制类型转换"></a>2.8 强制类型转换</h4><p>将一个类型强制转换成另一种类型在Java中提供了一种特殊表示方法:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">double</span> x = <span class="hljs-number">3.405</span>;<br><span class="hljs-keyword">int</span> nx = (<span class="hljs-keyword">int</span>) x;<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>将表达式x的值舍去了小数部分。</p><p>有时候需要将某个类的对象引用转换成另一个类的对象引用。要完成对象引用的强制类型转换:</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">staff[<span class="hljs-number">0</span>] = boss<span class="hljs-comment">;</span><br>Manager boss = (Manager) staff[<span class="hljs-number">0</span>]<span class="hljs-comment">;</span><br>Copy<br></code></pre></td></tr></table></figure><p>进行强制类型转换的唯一原因是：要在暂时忽视对象地实际类型之后使用对象的全部功能。例如，staff数组必须是Employee对象的数组，但我们需要将经理的元素复原成Manager对象，以便能访问新增加的所有变量。</p><p>如果一个子类的引用付给一个超类变量，是允许的。但超类的引用赋予一个子类变量，如果没有提前处理，将产生一个ClassCastException异常。因此，在进行强制转换之前，先查看是否能成功地转换。为此需要使用instanceof操作符</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">if(staff[<span class="hljs-number">1</span>] instanceof <span class="hljs-symbol">Manager</span>)<br>&#123;<br>    boss = (<span class="hljs-symbol">Manager</span>) staff[<span class="hljs-number">1</span>];<br>    ...<br>&#125;<br><span class="hljs-symbol">Copy</span><br></code></pre></td></tr></table></figure><p>综上所述，只能在继承层次内进行强制转换，且在超类强制转换成子类之前，应该使用instanaceof进行检查。</p><p><strong>一般情况下，尽量少用强制类型转换与instanceof运算符</strong></p><h4 id="2-9-抽象类"><a href="#2-9-抽象类" class="headerlink" title="2.9 抽象类"></a>2.9 抽象类</h4><p>在继承结构中，位于上层的类更具有一般性，即抽象性。比如，员工是一个人，学生也是一个人，人在他们的更上层。</p><p>为什么要提供一个高层次的抽象呢？每个人都有一些属性，如姓名。学生与员工都有姓名属性，因此通过引入一个公共的超类，我们就可以吧getName方法放在继承层次结构中的更高一层。</p><p>如果一个方法在员工和学生身上是截然不同的，例如调用工作方法，员工是上班而学生是上课。这时候就可以使用abstract关键字，这样就完全不用实现这个方法了。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> abstract <span class="hljs-keyword">String</span> <span class="hljs-title">getJob</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//no implement required</span><br>Copy<br></code></pre></td></tr></table></figure><p>为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为对象的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">gerJob</span><span class="hljs-params">()</span></span>;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>除了抽象方法，抽象类还可以包含字段和具体方法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> name</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">String</span> getJob();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-function"><span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p>抽象方法在子类中具体实现。扩展抽象类可以有两种选择。一种是在子类中保留抽象类中的部分或所有抽象方法仍未定义，这样就必须将子类也标记未抽象类；另一种做法就是定义全部方法，这样一来，子类就不是抽象的了。</p><p>即使不含有抽象方法，也可以将类声明为抽象类。</p><p>抽象类不能实例化。也就是说，如果讲一个类声明为abstract，就不能创建这个类的对象。例如:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;Name&quot;</span>);<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>需要注意，可以定义一个抽象类的对象变量，但是这样一个变量只能引用非抽象子类的对象。例如:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Person p</span> = nwe Student(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;...&quot;</span>);<br><span class="hljs-attribute">Copy</span><br></code></pre></td></tr></table></figure><p>这里p是一个抽象类型的Person变量，它引用了一个非抽象子类Student的实例。</p><h4 id="2-10-受保护访问"><a href="#2-10-受保护访问" class="headerlink" title="2.10 受保护访问"></a>2.10 受保护访问</h4><p>大部分情况，我们将类中的字段标记为private，而方法标记为public。任何声明为private的内容对其他类都是不可见得。</p><p>不过有些时候，你可能希望限制超类中的某个方法只允许子类访问，更少见的，可能希望允许子类的方法访问超类的某些字段。为此，需要将这些方法声明为保护(pretected)。</p><p>在Java中，保护字段只能由同一个包中的类访问。</p><p><strong>小结</strong><br><strong>1. 仅本类可见——private。</strong><br><strong>2. 对外部完全可见——public</strong><br><strong>3. 对本包合所有子类可见——protected</strong><br><strong>4. 对本包可见——默认，不需要修饰符</strong></p><h4 id="2-11-参考文献"><a href="#2-11-参考文献" class="headerlink" title="2.11 参考文献"></a>2.11 参考文献</h4><ol><li>Java核心技术 卷一(第11版) P155 </li><li>Java编程思想(第4版) P125 </li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Java基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode1052.爱生气的书店老板</title>
    <link href="/2021/02/23/leetcode1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/"/>
    <url>/2021/02/23/leetcode1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="爱生气的书店老板"><a href="#爱生气的书店老板" class="headerlink" title="爱生气的书店老板"></a>爱生气的书店老板</h1><p>今天，书店老板有一家店打算试营业<code>customers.length</code> 分钟。每分钟都有一些顾客<code>（customers[i]）</code>会进入书店，所有这些顾客都会在那一分钟结束后离开。</p><p>在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 <code>grumpy[i] = 1</code>，否则 <code>grumpy[i] = 0</code>。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p><p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。</p><p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。</p><ul><li><strong>我的思路</strong></li></ul><hr><p>先计算出在不存在控制生气时间的情况下客人的人数，再维护一个固定长度为X的滑窗来获得最大滑窗中能通过控制脾气能留住的人</p><ul><li><strong>我的代码:</strong></li></ul><hr><figure class="highlight excel"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs excel">class Solution &#123;<br>    public <span class="hljs-built_in">int</span> maxSatisfied(<span class="hljs-built_in">int</span>[] customers, <span class="hljs-built_in">int</span>[] grumpy, <span class="hljs-built_in">int</span> X) &#123;<br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">len</span> = customers.length;<br>        <span class="hljs-built_in">int</span> res = <span class="hljs-number">0</span>;<br>        for(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>;i++)&#123;<br>            <span class="hljs-built_in">if</span>(grumpy[i]==<span class="hljs-number">0</span>)&#123;<br>                res += customers[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> <span class="hljs-built_in">left</span> = <span class="hljs-number">0</span>, <span class="hljs-built_in">right</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> temp = <span class="hljs-number">0</span>, m_temp = <span class="hljs-number">0</span>;<br>        while(<span class="hljs-built_in">right</span>&lt;X)&#123;<br>            <span class="hljs-built_in">if</span>(grumpy[<span class="hljs-built_in">right</span>]!=<span class="hljs-number">0</span>)&#123;<br>                temp+=customers[<span class="hljs-built_in">right</span>];<br>            &#125;<br>            <span class="hljs-built_in">right</span>++;<br>        &#125;<br>        <span class="hljs-built_in">right</span>--;<br>        while(<span class="hljs-built_in">right</span>&lt;<span class="hljs-built_in">len</span>)&#123;<br>            m_temp = Math.max(m_temp, temp);<br>            <span class="hljs-built_in">if</span>(grumpy[<span class="hljs-built_in">left</span>]!=<span class="hljs-number">0</span>)&#123;temp -= customers[<span class="hljs-built_in">left</span>];&#125;<br>            <span class="hljs-built_in">left</span>++;<br>            <span class="hljs-built_in">right</span>++;<br>            <span class="hljs-built_in">if</span>(<span class="hljs-built_in">right</span>&lt;<span class="hljs-built_in">len</span>&amp;&amp;grumpy[<span class="hljs-built_in">right</span>]!=<span class="hljs-number">0</span>)&#123;temp += customers[<span class="hljs-built_in">right</span>];&#125;<br>        &#125;<br><br>        return res+m_temp;<br>        <br>    &#125;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><p><img src="/2021/02/23/leetcode1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/1.png" alt="1"></p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown入门语法.md</title>
    <link href="/2021/02/22/Markdown%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/02/22/Markdown%E5%85%A5%E9%97%A8%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown入门语法"><a href="#Markdown入门语法" class="headerlink" title="Markdown入门语法"></a>Markdown入门语法</h1><span id="more"></span><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a><strong>1. 标题</strong></h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">This is an H1</span><br><span class="hljs-section">===</span><br><br><span class="hljs-section">This is an H2</span><br><span class="hljs-section">---</span><br>Copy<br></code></pre></td></tr></table></figure><h2 id="2-字体"><a href="#2-字体" class="headerlink" title="2. 字体"></a><strong>2. 字体</strong></h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">**这是加粗**</span><br><span class="hljs-emphasis">__这也是加粗__</span><br><span class="hljs-strong">*这是倾斜*</span><br><span class="hljs-emphasis">_这也是倾斜_</span><br><span class="hljs-strong">***这是加粗倾斜**</span>*<br>~~这是加删除线~~<br>Copy<br></code></pre></td></tr></table></figure><h2 id="3-分割线"><a href="#3-分割线" class="headerlink" title="3. 分割线"></a><strong>3. 分割线</strong></h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span> <span class="hljs-emphasis">* *</span><br><span class="hljs-strong">**<span class="hljs-emphasis">*</span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">**</span></span></span><br><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong">- - -</span></span></span><br><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong">________________<span class="hljs-emphasis">_</span></span></span></span><br><span class="hljs-emphasis"><span class="hljs-strong"><span class="hljs-emphasis"><span class="hljs-strong">Copy</span></span></span></span><br></code></pre></td></tr></table></figure><p>效果如下：</p><hr><hr><hr><hr><hr><h2 id="4-引用"><a href="#4-引用" class="headerlink" title="4. 引用"></a><strong>4. 引用</strong></h2><p>在引用的文字前加 &gt; 即可。 在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; ：</p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">This is a blockquote <span class="hljs-keyword">with</span> two paragraphs. Lorem ipsum dolor sit amet,</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">Vestibulum enim wisi, viverra nec, fringilla <span class="hljs-keyword">in</span>, laoreet vitae, risus.</span><br><span class="hljs-meta">&gt;</span> <br><span class="hljs-meta">&gt;</span> <span class="javascript">Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">id sem consectetuer libero luctus adipiscing.</span><br>Copy<br></code></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p><p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse<br>id sem consectetuer libero luctus adipiscing.</p></blockquote><p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ：</p><h2 id="5-列表"><a href="#5-列表" class="headerlink" title="5. 列表"></a><strong>5. 列表</strong></h2><p>有序列表则使用数字接着一个英文句点作为标记。 示例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 列表内容<br><span class="hljs-bullet">2.</span> 列表内容<br><span class="hljs-bullet">3.</span> 列表内容<br>注意：序号跟内容之间要有空格<br>Copy<br></code></pre></td></tr></table></figure><p>很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果。</p><p>只按第一个数字来排序，因此第一个最好是1。</p><hr><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">* 一级无序列表内容</span><br><br><span class="hljs-comment">       * 二级无序列表内容</span><br><span class="hljs-comment">       * 二级无序列表内容</span><br><span class="hljs-comment">       * 二级无序列表内容</span><br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>效果如下：</p><ul><li>一级无序列表内容<ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul></li></ul><h2 id="6-代码"><a href="#6-代码" class="headerlink" title="6. 代码"></a><strong>6. 代码</strong></h2><p>在Markdown中加入代码块有两种方式： 第一种，只要简单地缩进 4 个空格或是 1 个制表符就可以</p><p><strong>单行代码</strong>：代码之间分别用一个反引号包起来即可；</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">这里有一句代码`代码内容`。<br>Copy<br></code></pre></td></tr></table></figure><p>效果如下：</p><p>这里有一句代码<code>代码内容</code>。</p><p><strong>代码块</strong>：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">\```<br>      代码...<br>      代码...<br>      代码...<br>\```<br>\ 是为了防止转译，实际是没有的。<br>Copy<br></code></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs erlang">代码...<br>代码...<br>代码...<br>Copy<br></code></pre></td></tr></table></figure><h2 id="7-段落与换行"><a href="#7-段落与换行" class="headerlink" title="7. 段落与换行"></a><strong>7. 段落与换行</strong></h2><p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。 <strong>我们在两个不同的文字块之间，一定要空行以示区分，不然就会被归入同一文字块中。</strong> Markdown 允许段落内的强迫换行（插入换行符）。 如果想要空一行，在插入处先按入两个以上的空格然后回车，即可。</p><p>但有时也可以使用标记来强制空行和空格，比如需要首行缩进的时候： 一个空格大小的表示：\  或 \  两个空格的大小表示：\ 或 \ 不换行空格：\ 或 \ 强制空行： \</p>]]></content>
    
    
    
    <tags>
      
      <tag>文本工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
